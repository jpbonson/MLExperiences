\documentclass{ufscThesis}

\usepackage{graphicx}
%\usepackage[labelsep=period]{caption} % O separador de legenda é um .
\usepackage[labelsep=endash]{caption} % O separador de legenda é um -
\usepackage{listings}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{ %
  language=Java,                % the language of the code
  basicstyle=\footnotesize,           % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=2,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add a comment within your code
  morekeywords={*,...}               % if you want to add more keywords to the set
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Identificadores do trabalho
% Usados para preencher os elementos pré-textuais
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\titulo{Aplicação de Agentes \& Artefatos para Acessar a Web Semântica} % Titulo do trabalho
\subtitulo{Desenvolvimento de uma ferramenta de autoria de metadados de objetos de aprendizagem}
\autor{Jéssica Pauli de Castro Bonson}           % Nome do autor
\data{23}{novembro}{2013}                           % Data da publicação do trabalho

\orientador{Prof. Elder R. Santos}                    % Nome do orientador e (opcional) seu título
\coordenador{Prof. Vitório B. Mazzola}              % Nome do coordenador do curso

\grau{Bacharel}
\departamento[o]{Departamento de Informática e Estatística}
\curso[a]{Ciências da Computação}
\documento[o]{Trabalho de Conclusão de Curso}


%%% Sobre a Banca
\numerodemembrosnabanca{2} % Isso decide se haverá uma folha adicional
\orientadornabanca{sim} % Se faz parte da banca definir como sim
%\bancaMembroA{Prof. Presidente da banca} %Nome do presidente da banca
\bancaMembroB{Profa. Jerusa Marchi}      % Nome do membro da Banca
\bancaMembroC{Prof. Ricardo Azambuja Silveira}     % Nome do membro da Banca
%\bancaMembroD{Prof. quarto membro}       % Nome do membro da Banca
%\bancaMembroE{Prof. quinto membro}       % Nome do membro da Banca
%\bancaMembroF{Prof. sexto membro}        % Nome do membro da Banca
%\bancaMembroG{Prof. sétimo membro}       % Nome do membro da Banca

%\dedicatoria{A quem o trabalho é dedicado, se é que o é (opcional)}

%\agradecimento{Agradecimentos opcionais, caso existam pessoas ou entidades a quem se deve apoio ou suporte ao trabalho ora apresentado.}

%\epigrafe{Um bonito pensamento ou citação, se for o caso}{autor do pensamento}

%\textoResumo {Aqui é redigido o resumo do documento...  blabla blablablabla blabla ipsum loren e a sophia também blab ablablabl ablbalbalblab lablablbalb lab lab lab labl a blab lablablab la blab alballbalba lba lba }

\palavrasChave {Sistema Multi-Agentes, Agentes \& Artefatos, Autoria de Metadados, Objetos de Aprendizagem, Web Semântica}

%\textAbstract {Here is written the abstract of the document}

%\keywords {key 1. key 2. ... key n.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Início do documento                                
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%--------------------------------------------------------
% Elementos pré-textuais
\capa  
\folhaderosto %\folhaderosto[comficha] % Se nao quiser imprimir a ficha, é só não usar o parâmetro
\folhaaprovacao
%\paginadedicatoria
\paginaagradecimento
%\paginaepigrafe
%\paginaresumo
%\paginaabstract
\listadefiguras
\listadetabelas 
\listadeabreviaturas
%\listadesimbolos
\sumario

%-------------------------------------------------------------------------------
% Para listagens de algoritmos e de código, recomenda-se consultar os
% pacotes algorithms e lstlistings, que são usados para definir esses
% dois tipos de elementos de texto e possuem os comandos
% \listofalgorithms e \lstlistoflistings, respectivamente.
%-------------------------------------------------------------------------------

%--------------------------------------------------------
% Elementos textuais











\chapter{Introdução}
Este trabalho visa analisar e aplicar a tecnologia de Agentes \& Artefatos (A\&A) para o desenvolvimento de uma ferramenta de autoria de metadados utilizando um repositório semântico.

A\&A baseia-se no conceito de agentes e sistemas multi-agente, uma sub-área da Inteligência Artificial (IA)\abreviatura{IA}{Inteligência Artificial}. Segundo \cite{ref13}, a IA pode ser brevemente definida como um campo que busca compreender e construir entidades inteligentes. O conceito de agentes em IA não possui uma única definição, inicialmente esperava-se que os agentes conseguissem demonstrar um inteligência humana completa, mas atualmente se considera mais factível que os agentes demonstrem apenas alguns aspectos de um comportamento inteligente \cite{ref11}. Uma definição possível para agentes é que se trata de um sistema computacional situado em algum ambiente e capaz de realizar ações autônomas nesse ambiente visando atingir os seus objetivos de projeto \cite{ref77}.

Sistemas Multi-Agente (SMA) consistem de um grupo fracamente acoplado de agentes autônomos que interagem entre si buscando resolver um problema \cite{ref36}. Algumas das características de um SMA é que os agentes não tem conhecimento ou capacidade para resolverem o problema de forma individual, os dados são descentralizados, não há um controle central e a comunicação é assíncrona \cite{ref36}.

O modelo de A\&A surgiu da necessidade\cite{ref7, ref78, ref10, ref3} de desenvolver o ambiente como uma entidade de primeira-classe, e assim permitir que ele seja uma parte do sistema que pode ser modelada e programada para encapsular serviços e funcionalidades que serão utilizadas pelos agentes em tempo de execução. Em A\&A são utilizados artefatos para se modelar o ambiente, \cite{ref5} apresenta dois pontos de vista diferentes sobre esta entidade: Do ponto de vista dos agentes artefatos são entidades que modelam ferramentas e recursos, e que podem ser dinamicamente instanciadas, observadas, compartilhadas, agrupadas e utilizadas para auxiliar as atividades individuais ou coletivas dos agentes. Do ponto de vista dos programadores do SMA, artefatos são abstrações para modelar e programar ambientes funcionais que os agentes podem utilizar, incluindo funcionalidades que afetam a interação entre os agentes e que permitem que eles interajam com o ambiente externo.

Outros dois conceitos revelantes para este trabalho são o de ferramenta de autoria e de repositório semântico. Mais especificamente, é desenvolvida uma ferramenta de autoria de metadados de objetos de aprendizagem. \cite{ref42} define metadados como dados estruturados sobre outros dados, normalmente legíveis por máquinas, que fornecem informações adicionais e contexto para estes dados. De acordo com a IEEE \cite{ref40} um objeto de aprendizagem (OA) é qualquer entidade que pode ser utilizada, reutilizada ou referenciada durante o aprendizado apoiado por computador, como um texto, um vídeo ou um aplicativo. Segundo a W3C \cite{ref39} uma ferramenta de autoria é qualquer aplicação que pode ser utilizada para criar ou modificar conteúdo Web que será usado por outros autores ou usuários finais. Para \cite{ref38} as ferramentas de autoria de objetos de aprendizagem devem possuir ambas ou uma das seguintes características: Oferecer um ambiente para a autoria de conteúdo digital e permitir a gerarão de objetos em conformidade com padrões de metadados. A ferramenta de autoria que será desenvolvida neste trabalho possui apenas a segunda característica, sendo uma ferramenta de autoria de metadados de aprendizagem. Foi decidido desenvolver a ferramenta utilizando o modelo de A\&A por  ela se beneficiar do potencial de reutilização e serviços fornecidos pelo modelo, como o acesso a Web Semântica.

Em relação a repositórios semânticos, \cite{ref74} os definem como ferramentas similares a um Sistema de Gerenciamento de Banco de Dados (SGBD)\abreviatura{SGBD}{Sistema de Gerenciamento de Banco de Dados}, que podem ser usadas para armazenar, administrar e realizar consultas sobre dados estruturados de acordo com o padrão RDF. \cite{ref72} cita que as principais diferenças são que estes repositórios utilizam ontologias como esquemas semânticos, permitindo a realização de inferências sobre os dados, e que trabalham com modelos de dados genéricos e flexíveis (grafos), possibilitando que facilmente interpretem e adotem novas ontologias e esquemas de metadados. Por conta destas diferenças, estes repositórios integram facilmente dados diversos, e possuem uma maior expressividade e capacidade de representação de conhecimento.

\section{Objetivos}
Objetivo Geral : Analisar e aplicar a abordagem de Agentes \& Artefatos para o desenvolvimento de 
um sistema de autoria de metadados de objetos de aprendizagem utilizando um repositório semântico.

Objetivos Específicos:
\begin{itemize}
\item Especificar os requisitos da ferramenta de autoria de metadados. 
\item Compreender a tecnologia de A\&A. 
\item Compreender o armazenamento de dados em repositórios semânticos. 
\item Modelar o repositório semântico com A\&A para poder ser utilizado pelos agentes. 
\item Modelar ou utilizar uma ontologia que será usada pelos agentes para acessar os objetos de aprendizagem do repositório semântico. 
\item Implementar o sistema de autoria de metadados com A\&A. 
\item Contextualizar a contribuição do sistema desenvolvido nas áreas de SMA e e-learning. 
\end{itemize}

\section{Motivação}
A principal motivação deste trabalho é realizar um estudo de caso para o modelo de A\&A. Por ser um modelo recente poucos projetos foram desenvolvidos utilizando-o e pretende-se informar quais foram os resultados positivos e negativos de utilizá-lo para modelar o sistema, além de possíveis sugestões em relação ao framework Cartago, que implementa o modelo de A\&A.

Outra motivação deste trabalho está relacionada à ferramenta de autoria de metadados que será desenvolvida. Até onde se pesquisou, só foi encontrada uma única ferramenta de autoria de objetos de aprendizagem\cite{ref79} que utiliza sistemas multi-agente, sendo que ela é focada no desenvolvimento de objetos de aprendizagem, não no preenchimento dos metadados segundo algum padrão, como a que será desenvolvida neste trabalho.





















\chapter{Fundamentação Teórica}

\section{Agentes e Sistemas Multi-Agente}
\label{sec:agentessma}

\subsection{Agentes}
Os agentes surgiram da necessidade para um número cada vez maior de aplicações de sistemas que consigam decidir por eles mesmos o que eles precisam fazer para satisfazer seus objetivos. Essa necessidade surge para ambientes que mudam rapidamente, são imprevisíveis ou abertos. Exemplos de aplicações deste tipo citadas por \cite{ref18} são um robô explorando um ambiente desconhecido em outro planeta e um agente que busca informações na Internet de acordo com uma consulta.

Não há uma definição universal do termo agente, isso ainda é tema de debates e um dos poucos consensos é de que a noção de autonomia é essencial. Autonomia é descrita por \cite{ref18} como a habilidade dos agentes agirem sem a intervenção de humanos ou outros sistemas, tendo controle sobre o seu estado interno e seu comportamento. Abaixo seguem definições de agentes segundo diferentes autores.

\cite{ref18} descreve que um agente é um sistema computacional que está situado em algum ambiente e é capaz de realizar ações autônomas nesse ambiente visando cumprir seus objetivos de modelagem. Adicionalmente, o autor considera que um agente que seja também inteligente é capaz de realizar ações reativas, um comportamento pró-ativo e habilidades sociais, onde pró-atividade é capacidade do agente ter uma atitude direcionada a cumprir seus objetivos.
\cite{ref13} possui uma definição mais genérica, na qual um agente é qualquer coisa que pode perceber um ambiente através de sensores e pode atuar sobre ele com atuadores.

Para \cite{ref19} um agente autônomo é um sistema situado dentro de uma parte de um ambiente, que percebe este ambiente e atua sobre ele ao longo do tempo de acordo com sua agenda e de forma a afetar o que o agente irá perceber no futuro.
\cite{ref23} distingue o termo agente em dois usos comuns, um fraco e um forte. Na noção fraca um agente é um hardware ou um sistema baseado em software que possui as seguintes propriedades: autonomia, os agentes operam sem uma intervenção direta humana ou de outros sistemas; habilidade social, o agente interage com outros agentes ou humanos através de alguma linguagem de comunicação para agentes; reatividade, os agentes percebem o ambiente e reagem rapidamente às mudanças que ocorrem nele; e pró-atividade, além de reagirem ao ambiente, os agentes também possuem um comportamento direcionado a objetivos.

A noção forte de agentes descrita por \cite{ref23} sugere que, além de ter as propriedades estabelecidas pela noção fraca, um agente é modelado e implementado utilizando conceitos humanos, como noções mentais (conhecimento, crença, intenção, obrigação), e as vezes também noções emocionais. Outra característica citada é a racionalidade, segundo este autor um agente é racional se ele agir de forma a atingir seus objetivos, e não agir de alguma maneira que possa impedi-lo de atingi-los.

Na Figura \ref{fig:teste1} é mostrado um modelo básico do funcionamento de um agente. Um agente possui um conjunto de sensores que permitem entender informações sensoriais do ambiente na forma de percepções e um repertório de ações que podem ser executadas para modificar ou inspecionar o ambiente através de atuadores. Uma ação possui pré-condições e pós-condições, ou seja, condições que ele assume serem verdadeiras e efeitos no ambiente após a execução da ação, sendo que estas ações podem falhar. Dentro do agente ocorre o processo de decisão sobre qual ação efetuar, o modo como este processo é realizado varia de acordo com a arquitetura de agente utilizada.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.5]{figuras/figura1.png}
\caption{Modelo básico de um agente \cite{ref16}}
\label{fig:teste1}
\end{center}
\end{figure}

Um exemplo de um agente pela noção fraca seria um termostato, com ações para alterar a temperatura do ambiente e sensores para captar essa temperatura, porém não possuindo habilidade social. Outro exemplo seria um robô que explora uma área desconhecida a procura de um objeto, com atuadores para se locomover, pegar e largar o objeto, e sensores para detectar o objeto procurado ou obstáculos no caminho, este agente pode ser forte ou fraco, dependendo de como for implementado. E por fim um agente jogador de xadrez, com atuadores para movimentar suas peças no jogo e sensores para perceber o estado do jogo, que seria um exemplo da noção forte, pois armazenaria as regras do jogo como um conhecimento.

Neste trabalho é utilizada a teoria de agentes BDI (Belief-Desire-Intention) e a linguagem de agentes Jason. A linguagem Jason foi escolhida por fornecer um suporte direto ao modelo de A\&A. Mais informações sobre teorias, arquiteturas e linguagens de agentes podem ser consultadas no Apêndice \ref{apendices:background}.

\subsection{Sistemas Multi-Agente}
\cite{ref36} define Sistema Multi-Agente (SMA)\abreviatura{SMA}{Sistema Multi-Agente} como um sistema composto por uma coleção de agentes autônomos que buscam resolver um problema. Os autores também citam algumas características de SMAs:

\begin{itemize}
\item cada agente possui informações e capacidades limitadas para resolver o problema, possui um ponto de vista limitado;
\item não há um sistema de controle global;
\item os dados são descentralizados;
\item a computação é assíncrona.
\end{itemize}

De acordo com \cite{ref36} SMAs são adequados para representar problemas que possuem múltiplas formas de serem resolvidos, múltiplas perspectivas e/ou múltiplas entidades. Isso porque SMAs podem resolver problemas de forma distribuída, concorrente e utilizando diversos tipos de interação entre os agentes. Estas interações incluem: cooperação (agentes trabalhando juntos buscando cumprir um mesmo objetivo), coordenação (organizar a resolução do problema de forma a explorar atividades benéficas, e evitar atividades maléficas para essa resolução) e negociação (chegar a um acordo aceitável para todas as partes envolvidas). A flexibilidade e a natureza de alto nível destas interações provêm o poder fundamental deste paradigma. Outras vantagens relevantes de SMAs incluem: robustez, eficiência, capacidade para interoperações entre sistemas legados já existentes, e a habilidade para resolver problemas em que os dados, o controle e o conhecimento estejam distribuídos.

Um exemplo de SMA citado por \cite{ref36} é um sistema de controle de tráfego aéreo. Cada agente controla um avião e tem como objetivo chegar ao seu destino com baixo consumo de combustível mantendo uma distância segura dos outros aviões. Agentes envolvidos em uma situação de conflito negociam com um dos agentes conflitantes para tentar resolvê-lo. Os agentes também planejam sua rota, de forma a melhor atingir seu objetivo.

Os autores também citam algumas áreas em que SMAs já foram utilizados com sucesso: manufatura, controle de processo, sistema de telecomunicação, controle de tráfego aéreo, administração de tráfego e de transporte, filtragem e coleta de informações, comércio eletrônico, administração de processos de negócio, entretenimento e cuidado médico.
\\*

A Figura \ref{fig:a5} apresenta as camadas de abstração de um ambiente sob um ponto de vista no qual um sistema multi-agente é dividido nos seguintes níveis: organizacional/social, agentes e ambiente.

O nível organizacional e social é composto de estruturas e regras, é nele que as interações sociais acontecem, e elas seguem as estruturas e regras estabelecidas neste nível. Um agente pode ter diferentes papéis, as regras do nível organizacional definem restrições em cada papel, quais normas ele deve respeitar e quais responsabilidades ou missões ele possui. As estruturas definem a topologia das interações e das relações sobre o controle da atividade.

O nível dos agentes é composto por agentes individuais, autônomos e situados. Estes agentes percebem e agem sobre o nível de ambiente, que é definido como um conjunto de recursos e serviços que os agentes podem acessar e controlar. O ambiente pode ser endógeno, dentro do próprio SMA, ou exógeno, externo ao SMA.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.55]{figuras/figura5.png}
\caption{Camadas de abstração de um SMA, retirado e traduzido de \cite{ref16}.}
\label{fig:a5}
\end{center}
\end{figure}

\cite{ref23} descreve um exemplo interessante para a utilidade de um SMA: O principal sistema de controle aéreo do país Rutitania para de funcionar de repente, devido as terríveis condições climáticas. Mas felizmente os sistemas de controle aéreo computadorizados dos países vizinhos negociam entre si para rastrear e tratar os vôos afetados, e uma situação possivelmente desastrosa passa sem maiores incidentes.
\\*

No Apêndice \ref{apendices:jadejiac} são descritos os frameworks JIAC e Jade, escolhidos devido a sua ampla utilização \cite{ref44,ref45,ref46,ref47,ref48}.

\subsection{Jason}
Nesta seção serão dadas mais informações sobre a linguagem de programação Jason \cite{ref35}. Como o Jason é baseado em uma versão expandida do AgentSpeak, primeiro será descrito como os agentes desta linguagem são programados.

Um agente AgentSpeak é criado através da especificação de um conjunto de crenças e um conjunto de planos. As crenças são representadas por predicados lógicos de primeira-ordem. Existem dois tipos de objetivos nesta linguagem: objetivos de realização, prefixados com !, e objetivos de teste, prefixados com ?. Objetivos de realização determinam que o agente quer atingir um estado de mundo em que este objetivo esteja concluído, e para isso iniciam a execução de planos. Objetivos de teste retornam a unificação do predicado associado com uma das crenças dos agentes, e falham caso não consigam unificar. Eventos de gatilho definem quais eventos podem iniciar a execução de um plano, um evento pode ser interno (cumprir um objetivo) ou externo (atualização de crenças ou percepção do ambiente). Existem dois tipos de eventos de gatilho: adição, prefixados com +, e deleção atitudes mentais, prefixado com -. Por fim, um plano é ativado por um evento de gatilho em um determinado contexto (predicado lógico), e é composto por uma sequência de ações básicas ou objetivos.

Abaixo é mostrado um exemplo de trecho de código de um agente AgentSpeak. O primeiro plano (+concerto) é ativado quando o agente percebe que haverá um concerto do artista A no local V, e que ele também gosta deste artista A. Ao ser ativado, o plano cria o objetivo de reservar ingressos para esse concerto, ativando o próximo plano. O segundo plano (+!reservar\_ingressos) é ativado caso ele acredite que o telefone não esteja ocupado, e realiza uma sequência de ações que inclui ligar para o local V e criar o objetivo de escolher os assentos no local.

\begin{lstlisting}[frame=tb]
+concerto(A,V) : gosta(A)
    <- !reservar_ingressos(A,V).

+!reservar_ingressos(A,V) : not ocupado(telefone)
    <- ligar(V);
         ...;
         !escolher_assentos(A,V).
\end{lstlisting}

As principais diferenças entre AgentSpeak e Jason são:
\begin{itemize}
\item negação forte;
\item manipulação de falhas de planos;
\item comunicação entre agentes baseada na teoria de atos de fala, junto com anotações nas crenças sobre a origem da informação;
\item anotações nos rótulos dos planos, permitindo o uso de funções de seleção mais elaboradas;
\item suporte para o desenvolvimento de ambientes;
\item suporte para sistemas multi-agentes distribuídos;
\item funções de seleção personalizáveis, funções de confiança e arquitetura personalizável.
\item uma biblioteca de ações internas essenciais;
\item extensibilidade através de ações internas definidas pelo(a) usuário(a);
\item um agente pode possuir conjunto de de objetivos iniciais;
\item base de crenças pode possuir regras semelhantes ao Prolog;
\item operador +-, que adiciona uma crença depois de remover a primeira ocorrência desta crença.
\end{itemize}

Esta seção dará enfoque ao desenvolvimento de ambientes em Jason. Os ambientes nesta linguagem são classes Java, e a declaração de qual ambiente um SMA irá usar ocorre no arquivo .mas2j, nesse arquivo também podem ser incluídos parâmetros para o ambiente e a identificação do nodo da rede em que este ambiente está localizado. Um modelo de ambiente em Java é mostrado abaixo, as duas estruturas principais são o construtor e o método executeAction.

O construtor estabelece as percepções iniciais do SMA, as percepções podem ser globais ou individuais. Os métodos de administração de percepções são: addPercept (adiciona percepção), removePercept (retira percepção) e clearPercept (deleta todas as percepções).

O método executeAction contém o código principal do ambiente. Dada uma ação e seus parâmetros e o agente que a executa este método realiza os procedimentos que forem necessários neste modelo de ambiente particular, normalmente isso inclui atualizar as percepções do ambiente. O retorno da execução da ação deve retornar um valor booleano, que indica se a ação falhou ou foi concluída com sucesso.

\begin{lstlisting}[frame=tb]
import java.util.*;
import jason.asSyntax.*; 
import jason.environment.*;

public class <AmbienteNome> extends Environment {

    // membros de classe quaisquer que possam ser necessários

    public <AmbienteNome> (){
        // adiciona as percepções iniciais ao ambiente
        addPercept(Literal.parseLiteral("p(a)"));
        //....
    }

    public boolean executeAction(String ag, Structure act) {
        //...
    {

    // quaisquer outros métodos que possam ser necessários
}
\end{lstlisting}

\section{Agentes \& Artefatos}
\label{sec:agentesartefatos}

\subsection{Introdução}
Agentes \& Artefatos (A\&A) \abreviatura{A\&A}{Agentes \& Artefatos} é um modelo para desenvolvimento de sistemas multi-agente no qual o ambiente é programado como uma entidade de primeira-classe, ou seja, o ambiente é uma parte do sistema que pode ser modelada e programada, junto com os agentes, para encapsular funcionalidades que serão utilizadas pelos agentes em tempo de execução \cite{ref5}. Este modelo possui fundamentação em diversas áreas como a computação, a psicologia, a sociologia e as ciências cognitivas, sendo a Teoria da Atividade (Activity Theory) a principal base teórica \cite{ref1}.

A Teoria da Atividade descreve como as atividades humanas coletivas se desenvolvem e se transformam, tendo o conceito de atividade como a unidade fundamental. Segundo esta teoria, qualquer atividade realizada dentro de uma organização só pode ser compreendida completamente se forem analisadas as ferramentas ou artefatos que possibilitaram as ações e mediaram as interações entre os indíviduos entre si e entre o ambiente. Os artefatos, físicos ou psicológicos, seriam a parte do ambiente que pode ser planejada e controlada para auxiliar as atividades dos indivíduos, alguns exemplos seriam relógios, agendas, linguagens e processos operacionais \cite{ref1, ref2}.

De acordo com \cite{ref5} atualmente há duas perspectivas principais que podem ser adotadas para se definir o ambiente em um SMA. A primeira é a da IA clássica, descrita em \cite{ref13}, na qual a noção de ambiente é utilizada para identificar o mundo externo, onde os agentes atuam e recebem percepções. A outra perspectiva se baseia em trabalhos recentes \cite{ref3, ref14} em Engenharia de Software Orientada para Agentes (Agent-Oriented Software Engineering, AOSE)\abreviatura{AOSE}{Agent-Oriented Software Engineering} que aponta que o ambiente pode ser modelado como uma entidade de primeira classe e que, como é o facilitador e mediador das interações entre os agentes, é também um lugar adequado para se encapsular serviços e funcionalidades que auxiliem as atividades dos agentes. Segundo esta última idéia, o ambiente pode ser construído de forma a melhorar todo o desenvolvimento do sistema, permitindo um maior controle sobre a topologia e funcionalidades do SMA. Conforme \cite{ref17} a definição de ambiente nessa nova perspectiva é a de uma abstração de primeira-classe que provê condições para que os agentes existam e que media tanto a interação entre agentes como o acesso a recursos.

\cite{ref16} relata outros motivos para a Programação Orientada a Ambientes (Environment Oriented Programming, EOP)\abreviatura{EOP}{Environment Oriented Programming} e os categoriza nos níveis básico e avançado. No nível básico, esta programação serve para criar ambientes de teste para ambientes reais ou externos e para facilitar a interface/interação com softwares de ambiente já existentes. No nível avançado ela introduz a noção de externalização, que permite encapsular e modularizar de forma uniforme as funcionalidades do SMA fora do agente, geralmente relacionadas com interação, coordenação, organização ou segurança.

\cite{ref4, ref5}descreve que em A\&A os SMAs são construídos baseando-se em duas abstrações principais: agentes e artefatos. Os agentes são as entidades autônomas e pró-ativas que encapsulam o controle e a lógica de suas ações e buscam cumprir seus objetivos, sendo a abstração básica para modelar e programar as partes autônomas do SMA. Enquanto artefatos representam as entidades passivas e reativas, que podem ser usadas para modelar e programar funcionalidades que podem ser acessadas, usadas e possivelmente adaptadas para auxiliar as atividades dos agentes.

Outras abstrações presentes neste modelo são as áreas de trabalho (workspaces) e o ambiente (environment). Uma área de trabalho representa um lugar no qual ocorre uma ou múltiplas atividades envolvendo um conjunto de agentes e artefatos. Elas servem para definir a topologia do ambiente e podem estar espalhadas entre vários nodos da rede. Uma área de trabalho é um conjunto dinâmico de artefatos, sendo que um artefato só pode estar em uma área por vez, mas um agente pode estar em várias áreas de trabalho ao mesmo tempo. Quando um agente é criado ele automaticamente passa a participar de uma área de trabalho padrão. Além disso, elas permitem criar políticas para o acesso e execução de ações dos agentes. Um ambiente é um conjunto dinâmico de agentes e artefatos, e pode conter diversas áreas de trabalho.

A Figura \ref{fig:a6} apresenta uma relação UML entre as entidades de um SMA no modelo A\&A, sendo que os artefatos, os agentes, a  área de trabalho e o ambiente já foram citados e as entidades manual, operação, eventos observáveis e propriedades observáveis, todas relacionadas com os artefatos, serão explicadas em mais detalhes nas seções a seguir. Na Figura \ref{fig:a6} também são mostradas algumas das ações que um agente pode efetuar sobre um artefato e sobre uma área de trabalho, que também serão explicadas em mais detalhes adiante.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.7]{figuras/figura6.png}
\caption{O modelo A\&A expressado em uma notação similar à UML (Unified Modelling Language), retirado e traduzido de \cite{ref5}.}
\label{fig:a6}
\end{center}
\end{figure}
\abreviatura{UML}{Unified Modelling Language}

A Figura \ref{fig:a7} mostra uma representação de um SMA no modelo A\&A. Neste exemplo o ambiente possui apenas uma área de trabalho, a padaria, que os agentes podem acessar dinamicamente através da porta. Nela situam-se diversos agentes, os padeiros, e diversos artefatos que eles utilizam. O artefato ``canal de comunicação" media a interação entre os agentes e o ambiente externo, os artefatos ``quadro-negro", ``relógio" e ``agenda de tarefas" auxiliam os agentes na execução do trabalho, enquanto o artefato ``bolo" é o próprio alvo do trabalho dos agentes. O artefato ``arquivo" guarda informações que podem ser úteis aos agentes, e em um SMA real provavelmente seria a abstração de um repositório ou de um banco de dados.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.7]{figuras/figura7.png}
\caption{Uma representação metafórica de um SMA de acordo com o modelo A\&A, retirado e adaptado de \cite{ref6}.}
\label{fig:a7}
\end{center}
\end{figure}



\subsection{Artefatos}
\label{sec:artefatos}
Artefatos são entidades computacionais passivas do SMA. Do ponto de vista da modelagem e programação de SMA os artefatos são o modulo básico para se estruturar e organizar o ambiente, provendo um modelo computacional de propósito geral para modelar as funcionalidades disponíveis para os agentes. Do ponto de vista dos agentes os artefatos estruturam, de uma maneira funcional, o mundo no qual eles estão situados e que eles podem criar, utilizar, compartilhar e perceber em tempo de execução \cite{ref5}.

Na Figura \ref{fig:a8} é mostrada uma representação de um artefato. Para que um artefato permita que suas funcionalidades sejam utilizadas pelos agentes ele provê um conjunto de operações (operations), agrupadas em uma interface de utilização (usage interface), e um conjunto de propriedades observáveis (observable properties).

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.8]{figuras/figura8.png}
\caption{Representação abstrata de um artefato, retirado e traduzido de \cite{ref5}.}
\label{fig:a8}
\end{center}
\end{figure}

Uma operação representa um processo computacional executado dentro do artefato, que pode ser ativado por um agente ou por outro artefato. Quando um agente executa uma operação de um artefato a sua atividade ou plano atual é suspenso até ocorrer um evento indicando que a operação foi concluída. É importante ressaltar que o agente não é bloqueado, apenas uma atividade é suspensa, enquanto isso o ciclo do agente continua executando novas atividades ou planos. Do ponto de vista dos agentes, as operações dos artefatos representam ações externas providas pelo ambiente. Isso implica que o repertório de ações de um agente é dinâmico, porque o conjunto de artefatos do ambiente muda dinamicamente, e além disso o próprio conjunto de operações na interface de utilização de um artefato também é dinâmico, pois pode ser alterado junto com mudanças no estado do artefato \cite{ref5}.

Outras características relevantes das operações são que o processo computacional pode ser dividido em várias etapas atômicas. Cada etapa pode possuir uma guarda (guard), que faz com que aquela etapa seja ativada somente quando sua guarda, uma relação booleana, for cumprida. Somente uma etapa é efetuada por vez dentro do artefato, para prevenir inconsistências. Se um agente tentar efetuar uma operação e houver uma etapa de outra operação sendo processada, a operação será efetuada assim que a etapa em execução for concluída \cite{ref5}.

Propriedades observáveis representam variáveis de estado do artefato, que podem ser percebidas pelos agentes e podem se alterar dinamicamente, como resultado de alguma operação. Outro resultado que pode ser gerado pelos artefatos são os sinais (signals) que servem para representar quais eventos não-persistentes ocorreram dentro do artefato. Um artefato também pode possuir variáveis de estado ocultas, usadas pelas suas próprias operações.  Em arquiteturas BDI percepções relacionadas aos valores de propriedades observáveis de um artefato que um agente esteja focando podem ser modeladas diretamente dentro do agente como crenças.

Outra interface que está representada na Figura \ref{fig:a8} é a interface de conexão (link interface), ela possui operações que podem ser acionadas por outros artefatos, contanto que tenham sido previamente conectados entre si por um agente. Assim é possível criar artefatos complexos através de uma composição de artefatos mais simples, essa composição pode ser feita inclusive entre artefatos de diferentes áreas de trabalho, possibilitando que os artefatos compostos sejam distribuídos pela rede.  Essa interface é análoga ao que existe nos artefatos usados por humanos, por exemplo conectando um computador a uma impressora.

Além das características citadas, um artefato também possui um manual com informações sobre quais são e como utilizar suas funcionalidades. Este documento deve ser legível para os agentes. A utilidade dos manuais é facilitar a existência de sistemas abertos e do uso cognitivo de artefatos, no qual os agentes dinamicamente decidem quais artefatos usar de acordo com seus objetivos, e descobrem como utilizá-los. Este é um trabalho em andamento e os pesquisadores da área ainda estão definindo como o manual será feito, uma das opções citada por \cite{ref5, ref6} é utilizar a Web Semântica como referência para criar linguagens e ontologias que possibilitem uma semântica compartilhada da descrição de um artefato.

Por fim, um agente possui um conjunto de ações que pode efetuar sobre um artefato, \cite{ref5} as categoriza em três grupos: (i) ações para criar/encontrar/descartar artefatos; (ii) ações para usar artefatos, executar operações e observar propriedades e sinais; (iii) ações para conectar/desconectar artefatos. Também há ações para entrar e sair de uma área de trabalho. As Figuras \ref{fig:c1}, \ref{fig:c2} e \ref{fig:c3}, retiradas e traduzidas de \cite{ref6}, ilustram algumas das ações citadas em mais detalhes, no contexto da plataforma Cartago.

\cite{ref5} descreve que para auxiliar as ações dos agentes no ambiente cada área de trabalho possui um conjunto de artefatos pré-definidos que provêm funcionalidades essenciais. Existem quatro artefatos padrão:
\begin{itemize}
\item workspace (área de trabalho): Provê funcionalidades para criar, descartar, procurar, conectar e focar (observar) artefatos da área de trabalho. Também provê operações para definir papéis e políticas de acesso e de execução de operações dos artefatos.
\item node (nodo): Provê funcionalidades para criar novas áreas de trabalho e entrar em áreas de trabalho locais ou remotas.
\item blackboard (quadro negro): Provê um espaço de tuplas que os agentes podem utilizar para se comunicar e coordenar. Um exemplo utilizando este artefato para implementar o Jantar dos Filósofos é mostrado no final do capítulo.
\item console: Provê funcionalidades para imprimir mensagens na saída padrão.
\end{itemize}

A Figura \ref{fig:c1} apresenta as dinâmicas de uma área de trabalho. Um agente passa a participar da área de trabalho ``a-areadetrabalho", e então usa o artefato padrão workspace para criar o artefato meuArt. Após isso o artefato está pronto para ser utilizado tanto pelo agente que o criou como pelos outros agentes que estão usando a área de trabalho a-areadetrabalho.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.6]{figuras/figura9.png}
\caption{Exemplos de interações dos agentes com uma área de trabalho, retirada e adaptada de \cite{ref6}.}
\label{fig:c1}
\end{center}
\end{figure}

Na Figura \ref{fig:c2} pode-se observar um agente utilizando um artefato. O agente seleciona a operação minhaOp na interface de utilização do artefato, desencadeando o início de uma nova instância da operação minhaOp dentro do artefato. A execução da operação eventualmente gerará sinais para os agentes que o estejam focando, além de possivelmente alterar as propriedades observáveis do artefato.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.6]{figuras/figura10.png}
\caption{Utilização de um artefato,  retirada e traduzida de \cite{ref5}.}
\label{fig:c2}
\end{center}
\end{figure}

A Figura \ref{fig:c3} demonstra um agente focando um artefato, assim ele passa a perceber todas as mudanças de valor das propriedades observáveis e os sinais que são gerados por este artefato como percepções.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.6]{figuras/figura11.png}
\caption{Foco em um artefato,  retirada e traduzida de \cite{ref5}.}
\label{fig:c3}
\end{center}
\end{figure}

Para uma melhor compreensão do modelo dos artefatos, em \cite{ref6} é citado como exemplo um artefato simples: uma máquina de café. O conjunto de botões da máquina de café representam as operações disponíveis; a tela e as luzes representam as propriedades observáveis e os sinais, como um som indicando que o café está pronto, seriam sinais gerados pelo artefato.

Em \cite{ref9} é citado um outro exemplo, mais complexo, do modelo de A\&A utilizando o framework Cartago, que será explicado em mais detalhes em \ref{sec:framcartago}. O exemplo é um Mundo de Quartos (Rooms World) composto por quartos e corredores, o objetivo dos agentes é manter estes quartos limpos, sendo que eles ficam sujos depois de uma quantidade arbitrária de tempo. Há artefatos disponíveis para auxiliá-los, como uma checklist na frente de cada quarto e um relógio que conta o tempo simulado. Há dois tipos de agentes: os normais, que apenas vão olhando os quartos aleatoriamente a procura de sujeira; e os que utilizam os artefatos, utilizando a checklist de cada quarto e o relógio para anotar o horário em que o quarto foi limpo, e assim poder decidir limpar um quarto ou não de acordo com quanto tempo passou desde a última limpeza. Neste exemplo, os agentes que utilizavam os artefatos obtiveram uma melhor performance do que os normais, pois não perdiam recursos procurando sujeira em quartos recentemente limpos.

\subsection{Funcionalidades dos Artefatos}
\label{sec:FuncArt}
Artefatos podem ter várias funções, \cite{ref5} cita as seguintes: coordenação de agentes, modelagem de mecanismos sociais/organizacionais e modelagem de recursos.
\\*

Coordenação de agentes: Como os artefatos são entidades compartilhadas e podem ser usadas concorrentemente pelos agentes, eles podem facilmente ser utilizados como coordenadores. Um artefato coordenador pode encapsular o estado e as regras que definem a política de coordenação do SMA. Isso serve para manter o funcionamento da coordenação fora do conhecimento dos agentes e permitir que as regras da coordenação sejam alteradas em tempo de execução, através de adaptações realizadas pelos agentes que tiverem permissão para isso. Alguns exemplos de artefatos coordenadores são: quadros-negros (blackboards), buffers limitados (bounded-buffers), barreiras (barriers), agendas (task schedulers), relógios, tabuleiros de jogos, entre outros.

Quadro-negros podem ser definidos como uma memória de compartilhamento global, onde existem informações, conhecimentos e requisições que podem ser lidos e escritos pelos agentes \cite{ref12}. Quadro-negros frequentemente são implementados como espaços de tuplas, um repositório de tuplas que pode ser acessado pelos agentes concorrentemente e onde eles podem inserir (out), ler (rd) e remover (in) conjuntos de dados estruturados chamados tuplas \cite{ref5}. O artefato padrão blackboard funciona desta maneira e é implementado como um espaço de tuplas, um exemplo o utilizando é mostrado no Apêndice \ref{apendices:implcartago}. Buffers limitados são utilizados para sincronização em interações produtor/consumidor. Barreiras fazem com que uma determinada ação só possa ser efetuada após uma certa condição de sincronização ter sido cumprida.

\cite{ref5} cita que na programação de SMAs sem artefatos um quadro-negro seria implementado como um agente, o que seria uma quebra de conceitos já que um quadro negro tipicamente não é modelado para ser autônomo e pró-ativo, mas sim para ser usado por outros agentes para comunicação e coordenação. Adotando a programação de ambiente o quadro-negro é implementado simplesmente como um recurso do ambiente, um artefato, que é acessado pelos agentes em termos de ações e percepções.

\cite{ref5} também descreve um exemplo citando as vantagens de se modelar uma barreira como um artefato em uma situação em que para se sincronizar as atividades de N agentes é necessário que antes de fazer a atividade T2, todos tenham que ter feito a atividade T1. Utilizando uma solução baseada somente na transmissão de mensagens cada agente teria que passar N-1 mensagens para os outros agentes, para assim todos saberem quando os outros concluíram T1, essa solução levaria a uma troca de N(N-1) mensagens. Utilizando uma solução com um agente mediador funcionando como um coordenador, o número de mensagens é reduzido para 2N. Porém se for utilizado um artefato para implementar uma barreira de sincronização que forneça uma operação sincronizar(), de forma que cada artefato só precise chamar uma vez esta operação, são requisitadas apenas N ações para sincronizar. Um exemplo utilizando um artefato sincronizador é descrito em \ref{apendices:implcartago}.
\\*

Mecanismos sociais/organizacionais: No método tradicional de construção de SMAs estes mecanismos costumam ser modelados como uma camada extra de agentes mediadores em que qualquer ação de algum dos agentes participantes que precise ser regida por uma lei deve ser realizada como uma ação comunicativa com os agentes mediadores. A programação de ambiente permite uma perspectiva diferente, no qual os artefatos modelam os mecanismos organizacionais e as regras de interação.

Como um exemplo simples, \cite{ref5} cita desenvolver um Jogo da Velha como um SMA. Os agentes seriam utilizados diretamente para implementar os jogadores, e o tabuleiro, que define e aplica as regras do jogo, seria modelado como um artefato utilizado pelos agentes jogadores. O tabuleiro definiria que ações um agente pode fazer dependendo do estágio do jogo (como ``novo jogo" para iniciar uma nova partida e ``movimento" para jogar durante ela). O artefato também apresentaria o estado do jogo através de suas propriedades observáveis, como ``turno" (vez de qual jogador), ``estado" (estado do jogo: jogando ou terminado) e ``pos(X,Y,S)" (para armazenar o conteúdo das células). Um agente observando o artefato efetuaria um movimento no tabuleiro assim que percebe-se que é o seu turno. \cite{ref5} mostra um exemplo com o código do artefato citado e um exemplo abstrato do código dos agentes que o utilizariam.
\\*

Modelagem de recursos: Um artefato pode ser usado para criar uma camada de abstração para modelar qualquer tipo de recurso que não seja um agente, tanto recursos internos (como base de conhecimento, agenda pessoal, calculadora, GUI (Interface Gráfica com o Usuário)\abreviatura{GUI}{Graphical User Interface}, biblioteca...) ou encapsular recursos externos (como Web Services, banco de dados, sistemas legados, bibliotecas...). Segundo \cite{ref5}alguns benefícios de modelar os recursos como artefatos são: (i) extensão do repertório de ações dos agentes sem ter que extender a linguagem ou arquitetura do agente; (ii) reduz a carga computacional dos agentes, que não precisam se preocupar com detalhes dos recursos, pois são executados dentro dos artefatos; (iii) aumenta a reusabilidade dos recursos; (iv) recursos podem ser criados, modificados ou descartados dinamicamente em tempo de execução.

\subsection{Características do modelo de Agentes \& Artefatos }
Algumas características relevantes dos artefatos são: maleabilidade (podem ser alterados, criados ou descartados pelos agentes dinamicamente), inspectabilidade (através das propriedades observáveis e dos sinais), predictabilidade (o artefato fará apenas as operações que for solicitado, e em etapas definidas) e distributividade (artefatos podem ser distribuídos por diferentes áreas de trabalho, que podem estar distribuídas por diferentes nodos da rede). Além disso, os artefatos permitem que as ações sejam distribuídas entre agentes e também ao longo do tempo \cite{ref5, ref9}.

Uma característica dos artefatos que deve ser frisada é que eles são computacionalmente mais leves que os agentes, afinal eles são apenas entidades passivas e reativas. Por isso características do ambiente que não necessitam da complexidade de um agente para funcionarem sendo modeladas como artefatos diminuem a carga computacional do sistema, além de ser uma forma mais intuitiva de modelagem.

Em relação ao modelo de A\&A como um todo, \cite{ref5, ref6} citam algumas características, apresentadas a seguir, desejáveis que um modelo para programação de SMAs deve ter. O modelo de A\&A atende estas características, especialmente na sua implementação com o framework Cartago.
\begin{itemize}
\item Abstração: O modelo deve preservar a abstração utilizada no nível de agentes e seus conceitos devem ser efetivos e genéricos o suficiente para capturar as principais propriedades de um ambiente.
\item Modularidade: O modelo deve adotar conceitos para modularizar o ambiente, evitando a visão monolítica e centralizada que é geralmente utilizada para se modelar SMAs.
\item Ortogonalidade: O modelo deve ser tão independente quanto possível dos modelos, arquiteturas e linguagens adotadas na programação de agentes, e assim ser capaz de suportar naturalmente sistemas heterogêneos.
\item Extensibilidade dinâmica: O modelo de programação deve suportar a construção, alteração e extensão dinâmica de partes do ambiente, visando ser possível utilizá-lo em sistemas abertos.
\item Reusabilidade: O modelo deve promover o reuso de partes do ambiente em diferentes contextos de aplicação.
\end{itemize}

Além disso, de acordo com \cite{ref6}o modelo de A\&A provê suporte direto e é especialmente vantajoso para SMAs que sejam:
\begin{itemize}
\item Distribuídos: Os agentes podem participar e trabalhar simultaneamente em múltiplas áreas de trabalho, possivelmente situadas em diferentes nodos da rede. Embora artefatos simples não possam ser distribuídos por diferentes áreas de trabalho, é possível distribuir artefatos compostos.
\item Heterogêneos: O modelo de A\&A e sua implementação na plataforma Cartago são ortogonais ao modelo utilizado para programar os agentes, isso permite que agentes de diferentes tipos trabalhem juntos em um mesmo ambiente, compartilhando artefatos.
\item Abertos: Agentes podem entrar e sair de áreas de trabalho dinamicamente, e podem alterar o conjunto de artefatos das áreas de trabalho dinamicamente. Restrições quanto a isso podem ser feitas utilizando uma política de papéis, explicada em mais detalhes na seção \ref{sec:framcartago}
\end{itemize}
Por fim, \cite{ref1} cita algumas áreas com aplicações possíveis para o modelo de A\&A : AOSE (Engenharia de Software Orientada a Agentes), MABS (Multi-Agent Based Simulation, Simulações Baseadas em Multi-Agentes)\abreviatura{MABS}{Multi-Agent Based Simulation}, SOS (Self-Organizing Systems, Sistemas Auto-Organizadores)\abreviatura{SOS}{Self-Organizing Systems} e como base para a criação de linguagens e infraestruturas para SMAs. Em MABS e SOS artefatos servem para modelar as partes do sistema que são melhor representadas como entidades passivas, distribuídas e orientadas a função.


\subsection{Framework de A\&A Cartago}
\label{sec:framcartago}
Há dois frameworks principais para se trabalhar como o modelo A\&A: simpA e Cartago. simpA é descrito separadamente no Apêndice \ref{apendices:simpa}, pois o framework usado neste trabalho é o Cartago, devido a ele já possuir uma integração com a linguagem Jason. A diferença principal entre eles é que o simpA é uma linguagem desenvolvida do zero, enquanto o Cartago foi desenvolvido para ser usado de forma ortogonal sobre algum framework de agentes já existente, em especial, o Jason.

Segundo \cite{ref6} Cartago (Common Artifact infrastructure for Agent Open environment, Infraestrutura Comum de Artefatos para Ambientes Abertos de Agentes) \abreviatura{Cartago}{Common Artifact infrastructure for Agent Open environment}é uma plataforma e infraestrutura que provê um modelo de programação de propósito geral para construir modelos computacionais compartilhados (áreas de trabalho) em que agentes, possivelmente heterogêneos, possam trabalhar juntos. A plataforma é baseada no modelo A\&A, assim os ambientes do Cartago são modelados e construídos em termos de um conjunto de artefatos, reunidos em áreas de trabalho. Cartago é código aberto e é implementado em cima da plataforma Java.

Em detalhes, a plataforma inclui:
\begin{itemize}
\item Uma API baseada em Java para programar e definir novos tipos de artefatos em termos de classes Java e tipos básicos de dados.
\item Uma API que permite que os agentes utilizem o ambiente do Cartago, fornecendo um conjunto de ações para criar e interagir com os artefatos, e para administrar e participar de áreas de trabalho.
\item Um ambiente runtime e ferramentas relacionadas que suportam a distribuição e administração do ambiente, e a administração do ciclo de vida das áreas de trabalho e dos artefatos.
\end{itemize}

Para definir e administrar os aspectos de segurança das áreas de trabalho em um SMA, Cartago utiliza um modelo RBAC (Role-Based Access Control, Controle de Acesso Baseado em Papéis)\abreviatura{RBAC}{Role-Based Access Control}. Isso é feito através da definição de papéis e para cada papel definir políticas especificando quais ações em quais artefatos um agente neste papel pode ou não efetuar. Também pode-se controlar quais agentes podem acessar uma área de trabalho. Como o modelo RBAC é implementado utilizando o artefato padrão workspace, o conjunto de papéis e políticas pode ser inspecionado e alterado dinamicamente.

Cartago é ortogonal quanto aos modelos e plataformas específicas utilizadas para se construir os agentes que utilizam as áreas de trabalho. A intenção é permitir que até mesmo agentes de modelos heterogêneos possam trabalhar em um mesmo ambiente. Para essa integração ser possível foram criados dois conceitos: corpo do agente (agent body) e mente do agente (agent mind). O corpo do agente é a parte do agente que está situada na área de trabalho, contém atuadores (effectors) para agir sobre os artefatos e sensores (sensors) para perceber os eventos observáveis gerados na área de trabalho. A mente do agente é executada externamente, pela plataforma usada para construir o agente.

De um ponto de vista arquitetural são introduzidas pontes (bridges) específicas para cada plataforma de agentes para conectar corpos e mentes, encapsulando o corpo da mente do agente, e assim permitindo que ela controle o corpo e perceba os estímulos coletados pelos sensores. Atualmente existem pontes para as plataformas Jason, Jadex e simpA, mais informações sobre estas pontes estão disponíveis em \cite{ref6, ref5}, e sobre a ponte com Jadex em \cite{ref15}. Como Jason é a plataforma de agentes que foi primeiramente integrada com o Cartago, e a que possui mais exemplos de código, ela foi escolhida como a plataforma de agentes deste trabalho.

Uma representação de como esta integração funciona aparece na Figura \ref{fig:c12}. Nela é mostrada uma aplicação SMA e uma camada de plataformas de execução que dão suporte a essa aplicação. No nível da aplicação são mostrados agentes interagindo entre si (setas pontilhadas), utilizando artefatos (setas contínuas) e recebendo percepções dos artefatos (setas tracejadas). Também são mostrados quatro artefatos distribuídos em duas áreas de trabalho, sendo que o artefato ``KB compartilhada" (knowledge base, base de conhecimento)  está em ambas. No nível das plataformas é mostrado como a aplicação é suportada pelos middlewares, cada mente de agente é modelada em alguma plataforma de agente (Jason, Jadex...) , os artefatos e áreas de trabalho são executados pelo Cartago, enquanto as relações entre eles são modeladas como corpos de agentes, permitindo o recebimento de percepções e a execução de ações. As setas ligando os corpos com as mentes dos agentes representam as pontes.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.6]{figuras/figura12.png}
\caption{Representação de como a integração entre as plataformas de agentes e o Cartago funciona, retirada de \cite{ref6}.}
\label{fig:c12}
\end{center}
\end{figure}

A integração amplia o repertório de ações dos agentes, nativamente provido pela sua plataforma original, com um novo conjunto de ações para tornar possível que utilizem o ambiente baseado em artefatos. Abaixo serão explicadas as novas ações, mais explicações encontram-se na seção \ref{sec:artefatos} e na referência \cite{ref5}. A sintaxe utilizada é Name(Params):Feedback para definir a assinatura das ações, que inclui o nome da ação, parâmetros e opcionalmente o feedback da ação.

\begin{itemize}
\item Criar, entrar e sair de áreas de trabalho locais ou remotas:
\begin{itemize}
\item createWorkspace(AreaDeTrabNome) - Cria uma nova área de trabalho com o nome  AreaDeTrabNome.
\item joinWorkspace(AreaDeTrabNome):AreaDeTrabId - Participa da área de trabalho AreaDeTrabNome, retorna o identificador dela.
\item joinRemoteWorkspace(AreaDeTrabNome,NodoId):AreaDeTrabId - Participa da área de trabalho remota AreaDeTrabNome localizada no nodo Nodoid, retorna o identificador dela.
\item quitWorkspace() - Sair de uma área de trabalho.
\end{itemize}
\item Criar, procurar e descartar artefatos:
\begin{itemize}
\item makeArtifact(ArtNome, ArtTipoNome, ParametrosIniciais): ArtId - Cria um novo artefato chamado ArtNome do tipo ArtTipoNome dentro da área de trabalho. Artefatos podem possuir um mesmo nome lógico em áreas de trabalho diferente, por isso é retornado um ArtId como um identificador único do artefato no SMA. ArtTipoNome é o nome da classe Java da qual este artefato será instanciado.
\item disposeArtifact(ArtId) - Remove um artefato da área de trabalho.
\item lookupArtifact(ArtName): ArtId - Localiza um artefato dado seu nome lógico e retorna o identificador deste artefato.
\item lookupArtifactByType(ArtTipoNome): {ArtId} - Retorna o conjunto de artefatos que são instâncias do tipo ArtTipoNome.
\end{itemize}
\item Usar artefatos:
\begin{itemize}
\item OpNome(Parametros) - Dada uma operação que exista em algum artefato da área de trabalho em que o agente está, esta operação é executada. A ação completa com sucesso caso a operação complete com sucesso. A ação falha se a operação falhar ou se o artefato não possuir esta operação no momento. Para se obter um retorno da operação é necessário usar um parâmetro do tipo OpFeedbackParam na operação do artefato, um exemplo utilizando este parâmetro é mostrado em \cite{ref5}, ele também está disponível no site do Cartago. Caso uma área de trabalho possua múltiplos artefatos com o mesmo nome de operação pode-se utilizar a anotação [artifact\_name(IdArtefato,``NomeArtefato")] para especificar de qual artefato é a operação.
\end{itemize}
\item Observar artefatos:
\begin{itemize}
\item focus(ArtId, {Filter}) - Observa continuamente os eventos gerados pelo artefato identificado por ArtId. Pode ser definido um filtro para selecionar apenas os eventos que o agente estiver interessado. Para agentes BDI, as propriedades observáveis são mapeadas diretamente como crenças na base de crenças. Um agente pode focar múltiplos artefatos ao mesmo tempo. Sempre que um propriedade observável for alterada ou um sinal for gerado um evento observável será enviado para todos os agentes que estejam observando o artefato. É importante notar que um agente pode utilizar um artefato sem necessariamente observá-lo.
\item stopFocus(ArtId) - Para de observar um artefato.
\item observeProperty(PropNome):PropValor - Lê o valor atual de uma propriedade observável. Neste caso o valor da propriedade é retornado pela ação, sem ser gerado uma percepção.
\end{itemize}
\item Conectar e desconectar artefatos:
\begin{itemize}
\item linkArtifacts(LinkingArtId, LinkedArtId, {,Porta}) - Conecta o artefato LinkingArtId ao LinkedArtId. O parâmetro Porta é necessário quando se está conectando o mesmo artefato com múltiplos artefatos.
\item unlinkArtifacts(LinkingArtId, LinkedArtId) - Desconecta os artefatos LinkingArtId e LinkedArtId.
\end{itemize}
\end{itemize}
De acordo com \cite{ref5} tipos de artefatos são modelados diretamente definindo uma classe Java que extenda a biblioteca cartago.Artifact, e usando um conjunto básico de anotações Java, suportadas a partir do JDK 1.5, e métodos herdados para definir os elementos da estrutura e comportamento dos artefatos. Um artefato concreto é criado como uma instância de um tipo de artefato.

Todo artefato possui um método init, que funciona como um construtor de um objeto, esse método define como a instância do artefato será inicializada em tempo de criação e pode receber parâmetros para definir características do artefato. Se esse método gera um erro o artefato não é criado e a ação do agente falha.

Abaixo estão descritas as primitivas disponíveis para os artefatos utilizarem:
\begin{itemize}
\item defineObsProperty(String PropNome, Object... args ) - Cria uma nova propriedade observável com um nome e um valor inicial, que pode ser qualquer tupla de objetos de dados.
\item getObsProperty(String PropNome):ObsProperty - Retorna um objeto ObsProperty encapsulando a propriedade observável.
\item prop.updateObsProperty(Object... args ) - Atualiza a propriedade observável com um determinado valor, sendo ``prop" um objeto ObsProperty.
\item signal(String SinalNome, Object... args ) - gera um sinal que é percebido por todos os agentes que estão observando o artefato.
\item signal(AgentId id, String SinalNome, Object... args ) - gera um sinal que é percebido por apenas um agente específico, caso ele esteja observando o artefato.
\item await(String NomeGuarda, Object... args ) - Suspende a execução da operação até que a condição da guarda seja atendida, quebrando a execução da operação em múltiplas etapas. Ao suspender a execução de uma operação as outras operações do artefato podem ser invocadas antes da operação atual ser concluída. Quando a condição da guarda é atendida e nenhuma outra operação está em execução, a operação suspensa continua sua execução.
\item await\_time(int TempoMilisegundos) - Suspende a execução da operação até que o tempo especifico, em milisegundos, tenha passado. Como no caso da primitiva await, ao suspender a operação o artefato se torna acessível para que os agentes executem outras operações e podem ocorrer atualizações no seu estado observável.
\item execInternalOp(String OpInternaNome, Object... args ) - Executa a operação interna  OpInternaNome.
\item failed(String MensagemDeFalha) - Gera uma exceção que interrompe o fluxo de controle na execução do método.
\item failed(String MensagemDeFalha, String Descricao, Object... args ) - Gera uma exceção que interrompe o fluxo de controle na execução do método. Além da mensagem também é enviado uma descrição da falha.
\item execLinkedOp(ArtifactId id, String OperacaoOutroArtefato, Object... args ) - Executa a operação OperacaoOutroArtefato do artefato ArtefatoId com os parâmetros indicados.
\item execLinkedOp(String Porta, String OperacaoOutroArtefato, Object... args ) - Executa a operação OperacaoOutroArtefato pela porta indicada com os parâmetros indicados.
\end{itemize}

Abaixo são descritas as anotações Java sobre métodos utilizadas no Cartago \cite{ref5}:
\begin{itemize}
\item @OPERATION [(guard=``métodoGuard")]: Usada para indicar que um método é uma operação do artefato. O corpo do método será o comportamento que a operação possui. Uma operação pode opcionalmente possuir uma guarda. O método deve possuir retorno void, e os parâmetros do método serão usados tanto como entradas e saídas da operação.
\item @GUARD: Um método de retorno booleano que define as condições que uma operação com guarda ou um await precisam possuir para continuar a execução.
\item @INTERNAL\_OPERATION: Indica que um método é uma operação interna, ou seja, não está disponível na interface de utilização.
\item @LINK: Indica que um método que é uma operação da interface de conexão do artefato.
\end{itemize}

Algumas observações:
\begin{itemize}
\item O mesmo método pode ser marcado com @OPERATION e @LINK.
\item Ao invés de usar @INTERNAL\_OPERATION e execInternalOp, obtém-se o mesmo efeito deixando um método sem nenhuma anotação e chamando-o da maneira convencional de OO após uma chamada await.
\end{itemize}

Exemplos de implementações com Cartago são descritos no Apêndice \ref{apendices:implcartago}. Uma comparação entre ambientes de agentes modelados em Jason e em Cartago é abordada no Apêndice \ref{apendices:compJasonCartago}.


\section{Ontologias e Repositórios Semânticos}
\label{sec:ontrepsem}

\subsection{Web Semântica}
Atualmente o conteúdo da Web consiste principalmente de arquivos hipertexto e hipermídia distribuídos, acessíveis através de links e de busca por palavra-chave \cite{ref53}. O grande aumento da quantidade e de tipos de conteúdo na Web causa problemas a este paradigma hipertexto, tornando cada vez mais difícil localizar o conteúdo desejado. Além disso o paradigma possui pouco suporte para consultas complexas e para a recuperação, integração, compartilhamento e processamento de informações \cite{ref53}.

Neste contexto, a Web Semântica surgiu como uma extensão da Web atual. Segundo \cite{ref53,ref54}seu o objetivo é permitir que dados sejam compartilhados efetivamente por grandes comunidades e que possam ser processados automaticamente tanto por máquinas como por humanos. \cite{ref53} cita que uma das maiores dificuldades em se cumprir este objetivo é que o conteúdo Web é primeiramente intencionado para ser consumido por usuários humanos e, além disso, grande parte deste conteúdo é desestruturado (textos, imagens, vídeos), sendo assim difícil processá-lo ou compartilhá-lo.

Considerando estes problemas e reconhecendo que ontologias podem solucioná-los, pois provêm um vocabulários de termos com significado bem-definido e legível por máquinas, concluiu-se que um padrão de uma linguagem para ontologias é um pré-requisito para desenvolver a Web Semântica \cite{ref53}, em 2001 a W3C criou um grupo de trabalho para desenvolver este padrão. O resultado, em 2004, foi a primeira versão da linguagem OWL construída sobre a linguagem RDF. Nas seções \ref{sec:ont} e \ref{sec:owl}. serão explicadas em maiores detalhes o que são ontologias e as linguagens RDF e OWL.

\subsection{Ontologias}
\label{sec:ont}
De acordo com \cite{ref53}, para a ciência da computação uma ontologia serve para modelar algum aspecto do mundo, ela introduz um vocabulário que descreve características do domínio sendo modelado e provê uma definição explícita do significado deste vocabulário. \cite{ref53} comenta diversas áreas onde ontologias são utilizadas como biologia, medicina, geografia, geologia e agricultura. Algumas ontologias relevantes da área biomédica desenvolvidas na linguagem OWL citadas pelo autor são SNOMED (Systematized Nomenclature of Medicine-Clinical Terms ), GO (Gene Ontology ), BioPAX (Biological Pathways Exchange ), e U.S. National Cancer Institute thesaurus.

\cite{ref55} acrescenta que ontologias são divididas em categorias, sendo os dois tipos principais:  ontologia de domínio e ontologia superior. Ontologias de domínio são as mais comuns, e servem para compartilhar conceitos e relações de uma área de interesse em particular, como exemplo as ontologias para biomedicina referidas no parágrafo anterior. Ontologias superiores provêm conceitos gerais que podem ser utilizados por diversas ontologias de domínio, um exemplo é a ontologia Dublin Core \cite{ref49}, que busca utilizar metadados para descrever objetos digitais.

A principal utilidade de uma ontologia é representar conhecimento sobre um domínio, segundo \cite{ref60} as ontologias compartilham várias similaridades estruturais, independentemente da linguagem na qual são representadas. A maioria das ontologias utiliza os conceitos de indivíduos (instâncias de classes, objetos), classes (conceitos, conjuntos, tipos de objetos), propriedades (atributos que indivíduos ou classes podem ter) e relações (relacionamentos entre classes e indivíduos). Também é comum existirem restrições (devem ser verdadeiras para que um axioma seja adicionado) e regras (sentenças na forma se...então que descrevem inferências lógicas). Uma ferramenta frequentemente utilizada para o desenvolvimento de ontologias é a Protégé \cite{ref61}, um exemplo de uma ontologia desenvolvida em OWL com o Protégé é descrita na seção \ref{sec:owl}.

Outra funcionalidade importante das ontologias é permitir que possam ser realizadas inferências sobre este conhecimento. \cite{ref56} descreve inferência como a capacidade de se descobrir, através de procedimentos automáticos, novas relações dentro de uma ontologia baseando-se em seus dados, vocabulário e regras sobre estes dados. Mecanismos de inferência também permitem realizar consultas complexas, checar inconsistências e depurar a ontologia.

\cite{ref56} cita dois exemplos comuns de inferências: 1) Se existem as relações ``Flipper é um Golfinho" e ``Golfinhos são Mamíferos", pode-se inferir que ``Flipper é um Mamífero", mesmo que isso não esteja explícito na base de dados; 2) A regra ``Se duas Pessoas possuem o mesmo nome, homepage e endereço de e-mail, então elas são a mesma pessoa" pode ser usada para se inferir que duas pessoas possuem a mesma identidade.

Algumas APIs de motores de inferência OWL frequentemente utilizados são: Pellet \cite{ref57}, FaCT++ \cite{ref58} e Racer \cite{ref59}.

\subsection{RDF e OWL / OWL 2}
\label{sec:owl}
De acordo com \cite{ref56} a linguagem RDF (Resource Description Framework) \cite{ref63}\abreviatura{RDF}{Resource Description Framework} permite descrever recursos Web e relações entre eles. Uma característica chave da linguagem é a utilização de identificadores internacionalizados de recursos (internationalized resource identifier, IRIs) \abreviatura{IRI}{Internationalized Resource Identifier} para se referir diretamente a recursos não-locais, facilitando a integração da informação. RDF é uma linguagem simples, estruturada na forma de um grafo rotulado direcionado e sua única construção sintática são tuplas na forma SUJEITO - PREDICADO - OBJETO, como em ``Mariana é\_mãe\_de Carlos". Para facilitar o compartilhamento de grafos RDF na Web, esta linguagem possui uma serialização para XML.

Embora a linguagem RDF permita adicionar anotações aos dados de forma estruturada, ela não é capaz de resolver o problema de compreensão do significado e da semântica dos termos das anotações. Uma extensão do RDF, o RDFS (RDF Schema) \cite{ref63}, foi criada para amenizar este problema, mas ainda assim é bastante limitada como uma linguagem para ontologias, pois não permite descrever, por exemplo, restrições de cardinalidade ou conjunção de classes.
\\*

A Web Ontology Language (OWL) \cite{ref65} \abreviatura{OWL}{Web Ontology Language}, lançada em 2004 como uma recomendação da W3C, é uma linguagem para ontologias mais expressiva em relação ao RDF/RDFS, e construída sobre o RDF/RDFS. \cite{ref54} descreve que a OWL  pode ser utilizada para definir classes e propriedades assim como em RDFS, mas oferece funcionalidades adicionais, como: descrições de classes como combinações lógicas de outras classes (intersecções, união, complemento, equivalência), restrições de cardinalidade em propriedades, restrições de quantificação (someValuesFrom e allValuesFrom) e definição de propriedades inversas, transitivas, simétricas ou funcionais.

\cite{ref54} afirma que a OWL é única de duas maneiras: 1) É a primeira linguagem para ontologias com uma expressividade razoável a se tornar um padrão notoriamente reconhecido, o que é bastante importante para o reuso de ontologias e para a interoperabilidade das ferramentas que trabalham com elas. 2) OWL é a primeira linguagem para ontologias amplamente utilizada cujo design é baseado na arquitetura Web, isso ocorre porque é uma linguagem não-proprietária; utiliza Universal Resource Identifiers (URIs)\abreviatura{URI}{Universal Resource Identifiers} para identificar recursos de forma não ambígua na Web (similar ao IRI); suporta a ligação de termos entre ontologias, permitindo referência cruzada e reuso de informação; e é baseada em RDF/XML, facilitando o intercâmbio de dados. Uma outra característica relevante da OWL é que ela trabalha com a suposição de um mundo aberto, que é mais adequada a Web, pois normalmente não é razoável assumir que se possui informação completa sobre um domínio.

Na sua primeira versão a OWL provê três sub-linguagens intencionadas para diferentes aplicações, em ordem de expressividade elas são: OWL Lite, OWL DL, e OWL Full. Uma das linguagens mais utilizadas \cite{ref54} é a OWL DL, pois possui um modelo teórico formal baseado na Lógica Descritiva, uma família de formalismos para se representar conhecimento baseados em um conjunto decidível da lógica de primeira ordem. Por causa desta fundamentação teórica, a OWL DL permite que inferências sejam feitas de forma decidível, completa e automática, enquanto ainda mantém um bom nível de expressividade.

Segundo \cite{ref54} uma ontologia OWL consiste de um conjunto de axiomas TBox e ABox. O axiomas TBox descrevem restrições à estrutura do domínio, um exemplo são os axiomas que definem hierarquias de classes e propriedades, como subClassOf. Os axiomas ABox declaram fatos sobre situações concretas, como os axiomas ``Augusto é uma instância de Estudante" e ``Akita, instância de Cachorro, é um animal de estimação de Augusto".

Na Figura \ref{fig:c18} é mostrado um exemplo de uma ontologia OWL desenvolvida na ferramenta Protégé. Nela existem as classes ``Animal", ``Mamífero", ``Pessoa" e ``Cachorro", havendo uma relação de subclasse entre elas, sendo que ``Pessoa" e ``Cachorro" são classes disjuntas. A classe ``Pessoa" possui três instâncias (Ana, Alice e Augusto) e a classe ``Cachorro" possui os indivíduos Akita e Rex. Existem as propriedades de dados nome, sexo e CPF, sendo que CPF tem seu domínio limitado apenas para indivíduos da classe Pessoa e é uma propriedade funcional, ou seja, cada indivíduo só pode ter um CPF. Além das propriedades padrão sobre objetos has\_individual e has\_subclass, também existem as propriedades sobre objetos e\_colega (Pessoa => Pessoa), e\_pet (Cachorro => Pessoa) e tem\_pet (Pessoa => Cachorro), com os respectivos domínio e alcance entre parênteses. A propriedade tem\_pet é inversa de e\_pet, e a propriedade e\_colega é simétrica.

Usando o racionador HermiT 1.3.4 \cite{ref69} sobre esta ontologia foram geradas as seguintes inferências: da relação ``Alice tem\_pet Akita" inferiu-se ``Akita e\_pet Alice", idem para Ana e Rex; e para a relação ``Alice e\_colega Augusto" inferiu-se ``Augusto e\_colega Alice".

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.65]{figuras/figura18.png}
\caption{Exemplo de ontologia OWL desenvolvida no Protégé.}
\label{fig:c18}
\end{center}
\end{figure}

Para se realizar consultas sobre ontologias OWL pode-se usar a SPARQL (SPARQL Protocol and RDF Query Language) \cite{refDEF}\abreviatura{SPARQL}{SPARQL Protocol and RDF Query Language}. SPARQL é uma linguagem para consulta e manipulação de dados RDF. A consulta é feita através do casamento de padrões de grafos ou triplas RDF, e também da conjunção, disjunção ou união destes grafos. Esta linguagem é uma das tecnologias-chave da Web Semântica e é uma recomendação oficial da W3C. A SPARQL permite trabalhar com os dados da Web Semântica de forma federada, possibilita realizar inferências sobre os dados consultados e também permite realizar consultas tanto sobre dados estruturados como semi-estruturados.

Abaixo é mostrado um exemplo de uma consulta em SPARQL, o objetivo dela é responder a pergunta ``Quais são os gases nobres?", após ela é mostrado o resultado retornado por esta consulta. Em PREFIX são definidas as ontologias que serão utilizadas, neste caso uma sobre a tabela periódica e uma auxiliar do XMLSchema. Em SELECT é definido quais dados a consulta retornará, neste caso o nome, símbolo, peso e número dos gases nobres. Em FROM é definida a base de dados que será utilizada. Em WHERE são definidas as condições da consulta, neste caso se deseja um elemento do grupo dos gases nobres, e após isso os axiomas da ontologia são associados  com as variáveis da consulta.

\begin{lstlisting}[frame=tb]
PREFIX table: <http://www.daml.
org/2003/01/periodictable/PeriodicTable#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?nome ?simbolo ?peso ?numero
FROM <http://www.daml.org/2003/01/periodictable/PeriodicTable.
owl>
WHERE {
?elemento table:group ?grupo .
?grupo table:name "Noble gas"^^xsd:string .
?elemento table:name ?nome .
?elemento table:symbol ?simbolo .
?elemento table:atomicWeight ?peso .
?elemento table:atomicNumber ?numero
}
ORDER BY ASC(?nome)
\end{lstlisting}

\begin{table}[h]
\begin{center}
\caption{Resultado da consulta SPARQL ``Quais são os gases nobres?"}
\begin{tabular}{c|c|c|c}
\hline
nome & símbolo & peso & número\\
\hline
argônio & Ar & 39.948 & 18\\
\hline
hélio & He & 4.002602 & 2\\
\hline
criptônio & Kr & 83.798 & 36\\
\hline
neônio & Ne & 20.1797 & 10\\
\hline
radônio & Rn & 222 & 86\\
\hline
xenônio & Xe & 131.293 & 54\\
\hline
\end{tabular}
\end{center}
\end{table}

Por fim, a OWL2 é uma extensão da OWL que, entre outras mudanças, aumenta sua expressividade. Algumas das novas características descritas por \cite{ref54} incluem: restrições de cardinalidade qualificadas, permitindo, por exemplo, descrever que uma mão é composta por 4 dedos e 1 polegar; propriedades que podem ser reflexivas, irreflexivas, assimétricas ou disjuntas; e composição de propriedades em uma cadeia de propriedades, como para capturar o fato de que uma doença que afete uma parte de um órgão afeta o órgão como um todo. OWL2 também provê suporte extendido para tipos de dados e anotações. Informações mais detalhadas sobre a OWL2 podem ser encontradas em \cite{ref52}.

\subsection{Repositórios Semânticos}
A explosão do uso de RDF para representar informações sobre recursos fez com que fosse necessário sistemas em escala Web que pudessem armazenar e processar uma quantidade massiva de dados, e que também pudessem prover funcionalidades poderosas para o acesso e mineração destes dados \cite{ref74}.

Neste contexto foram desenvolvidos os repositórios semânticos, segundo \cite{ref74} não existe uma definição formal para este termo, os autores definem repositórios semânticos como uma ferramenta similar a um Sistema de Gerenciamento de Bando de Dados (SGBD), que pode ser usada para armazenar, administrar e realizar consultas sobre dados estruturados de acordo com o padrão RDF. \cite{ref72} acrescenta que as maiores diferenças destes repositórios em relação a um SGBD são que eles utilizam ontologias como esquemas semânticos, permitindo que se possa realizar inferências sobre os dados; e que eles trabalham com um modelo de dados flexível e genérico (grafos), o que permite que eles facilmente adotem e interpretem novas ontologias ou esquemas de metadados em tempo de execução. Uma consequência disto é que os repositórios semânticos oferecem uma integração facilitada entre dados diversos e oferecem um maior poder analítico sobre os dados.

\cite{ref72} cita Sesame como um dos repositórios semânticos mais populares. Sesame\cite{ref73} é um banco de dados RDF de código-aberto que suporta armazenamento, consulta e inferência sobre dados RDF(S). Ele é um framework Java que fornece uma API extensível, permitindo que outros repositórios possam ser construídos sobre ele. Sesame também é considerado um padrão de-facto para se processar dados RDF \cite{ref71}.

Outro exemplo citado pelos autores é o OWLIM. OWLIM\cite{ref75, ref76} é uma família de repositórios semânticos empacotados como uma camada de armazenamento e inferência (Storage and Inference Layer , SAIL)\abreviatura{SAIL}{Storage and Inference Layer} de alto desempenho para o Sesame. OWLIM suporta a linguagem de consulta SPARQL e oferece suporte para as linguagens RDF(S), OWL 2 RL e OWL 2 QL. Existem três versões de repositórios OWLIM: OWLIM-Lite, OWLIM-SE e OWLIM-Enterprise, que utilizam as mesmas semânticas e mecanismos de inferência. OWLIM-Lite foi projetado para volumes medianos de dados e para prototipação, ele é um repositório in-memory, com um rápido processamento. OWLIM-SE foi desenvolvido para uso comercial e permite administrar volumes massivos de dados. OWLIM-Enterprise é uma infraestrutura clusterizada baseada no OWLIM-SE.

Neste trabalho acessamos o repositório semântico nativo OpenLink Virtuoso\cite{refVIRT}. Virtuoso é um banco de dados SQL objeto-relacional que suporta consultas em SPARQL aos dados RDF. Ele também suporta dados relacionais típicos e dados em XML e possui um servidor para Linked Data. Este repositório é capaz de suportar até cerca de 1 bilhão de triplas.


\subsection{DBPedia}

DBPedia \cite{refXYZ} é construída sobre a Web Semântica, seu objetivo é extrair informações estruturadas da Wikipedia e disponibilizar estas informações na Web. Atualmente a base de conhecimento da DBPedia descreve mais de 2.6 milhões de entidades, juntamente com seus identificadores globais, relacionamentos, descrições, classificações, etc. Estas entidades pertencem a domínios como informações geográficas, pessoas, companhias, filmes, livros, e publicações científicas. A principal ontologia utilizada pela DBPedia é diretamente mapeada dos templates da Wikipedia. Outros ontologias utilizadas são a Yago \cite{refYAGO} e a FOAF \cite{refFOAF}.

DBPedia fornece um endpoint SPARQL público \footnote{http://DBpedia.org/sparql} que permite que consultas sejam feitas a sua base de conhecimento. O repositório semântico OpenLink Virtuoso \cite{refVIRT} é utilizado como um banco de dados back-end. Para utilizar o endpoint SPARQL nós adotamos o mecanismo de consultas da Jena API \cite{refJENA}, um framework Java de código aberto que permite a construção de aplicações para a Web Semântica.

A DBPedia foi escolhida como a base de conhecimento para este trabalho pois é baseada na Wikipedia, uma fonte frequentemente utilizada por estudantes. Além disso, a DBPedia é considerada como a mais famosa base da Web Semântica \cite{refEntrevista}.


\section{Ferramentas de Autoria de Objetos de Aprendizagem}
\label{sec:aprendizagem}

\subsection{Introdução}
Nesta seção estudamos as ferramentas de autoria para facilitar o processo de levantamento de requisitos da ferramenta desenvolvida neste trabalho. Segundo a W3C \cite{ref39} uma ferramenta de autoria é qualquer aplicação ou coleção de aplicações que pode ser utilizadas por autores, colaborativamente ou não, para criar ou modificar conteúdo Web que será usado por outros autores ou usuários finais. Alguns exemplos de ferramentas de autoria segundo esta definição seriam: editores WYSIWYG, ferramentas de autoria multimídia, sistemas de gerenciamento de conteúdo e ferramentas de autoria de objetos de aprendizagem. \cite{ref38} acrescenta que ferramentas de autoria em geral permitem que autores produzam aplicações gráficas através do agrupamento e sequenciamento de diferentes objetos, como texto, imagens, áudio e vídeo.

De acordo com a IEEE \cite{ref40} um objeto de aprendizagem (OA)\abreviatura{OA}{Objeto de Aprendizagem} é qualquer entidade que pode ser utilizada, reutilizada ou referenciada durante o aprendizado apoiado por computador, e pode ser algo simples como um texto ou um vídeo, ou mais complexo, como um hipertexto, um curso ou uma animação. \cite{ref41} considera que um objeto de aprendizagem deve possuir as seguintes características: ser auto-explicativo, modular, agregável, digital, interoperável e reutilizável.

Para \cite{ref38} as ferramentas de autoria de objetos de aprendizagem possuem duas características principais: Oferecem um ambiente para a autoria de conteúdo digital e permitem gerar objetos em conformidade com padrões de metadados. Uma ferramenta de autoria deste tipo pode ter ambas ou apenas uma destas características. No caso deste trabalho, a ferramenta de autoria desenvolvida possui apenas a segunda característica, tendo como principal função auxiliar o preenchimento de metadados conforme um padrão de metadados.

\cite{ref42} define metadados como dados estruturados sobre outros dados, que podem ser objetivos (dados sobre os autores, data de criação, versão...) ou subjetivos (palavras-chave, resumo, revisão...). Metadados servem para fornecer informações adicionais sobre um dado, e assim fornecer o contexto em que aquele dado existe e que relações ele possui com outros dados. Frequentemente metadados são inteligíveis por computadores.

Padrões de metadados estabelecem metadados com uma semântica definida buscando garantir o seu uso e interpretação corretos. Os padrões de metadados para OAs facilitam o compartilhamento, catalogação, descoberta e reuso dos objetos de aprendizagem. Alguns exemplos de padrões para OAs são: DC (Dublin Core)\abreviatura{DC}{Dublin Core} \cite{ref49}, LOM (Learning Object Metadata) \cite{ref40}\abreviatura{LOM}{Learning Object Metadata}, Scorm (Sharable Content Object Reference Model) \cite{ref51}\abreviatura{Scorm}{Sharable Content Object Reference Model} e CanCore \cite{ref50}.

\subsection{Exemplos de Ferramentas de Autoria}
Em \cite{ref38} é realizado um estudo comparativo entre oito ferramentas de autoria de objetos de aprendizagem: Ardora, CourseLab, eXe Learning, FreeLoms, LomPad, Paloma, Reaload e Xerte. Os critérios de comparação foram: facilidade de instalação, abrangência, grau de cobertura do padrão, grau de inteligência, disponibilidade do código-fonte, integração, adaptabilidade, existência de um manual, representação de metadados através de ontologias e enfoque pedagógico. Um resumo dos resultados para cada um destes critérios segue na Tabela 2 abaixo:

\begin{table}[h]
\begin{center}
\caption{Comparação resumida entre ferramentas de autoria do estudo feito por \cite{ref38}}
\begin{tabular}{c|c}
\hline
Critério & Resultado\\
\hline
\hline
Facilidade de instalação & Fácil ou Web\\
\hline
Abrangência & As três primeiras permitem criação de\\
            & conteúdo, a maioria dá suporte para\\
            & os padrões Scorm 1.2 e LOM.\\
\hline
Grau de cobertura & Completo\\
do padrão & \\
\hline
Grau de inteligência & Possuem Dialog Box agrupados\\
 & por nível de afinidade.\\
\hline
Disponibilidade do & Sim, menos FreeLOms, LOMPad\\
código-fonte       &   e Paloma.\\
\hline
Integração com & Sim, de acordo com os padrões\\
algum LMS      & de metadados suportados.\\
\hline
Adaptabilidade dos OAs  & Sim para eXe Learning, LOMPad,\\
para outras plataformas & RELOAD e Xerte.\\
\hline
Existência de um manual & Não \\
\hline
Representação de & Não \\
metadados através& \\
de ontologias    & \\
\hline
Enfoque pedagógico & Não \\
\hline
\end{tabular}
\end{center}
\end{table}

Entre os resultados da pesquisa, os que mais chamaram a atenção em relação a este trabalho foram os itens ``grau de inteligência" e ``representação de metadados através de ontologias", ambos tiveram um resultado unânime. Para o primeiro critério, todas as ferramentas tinham apenas Dialog Box agrupados por nível de afinidade, sem automatização do preenchimento e com pouca ou nenhuma informação sendo fornecida quanto ao significado das tags dos padrões de metadados. Para o segundo critério, nenhuma das ferramentas analisadas representavam os metadados através de ontologias.

Algumas conclusões do próprio estudo sobre esta comparação foram: 1) É necessário facilitar o preenchimento de metadados, pois embora existam ferramentas que auxiliem no preenchimento conforme os padrões, esta ainda é uma tarefa árdua, seja pelo processo de classificação e denominação das informações, seja pela quantidade de campos a preencher. Isso tem como consequências lentidão na produção de novos recursos e baixa taxa de preenchimento de metadados, fazendo com que sejam pouco padronizados. 2) É preciso que uma vez que o OA esteja em um Learning Management System (LMS)\abreviatura{LMS}{Learning Management System}, ele possa fornecer informações sobre a interação do aluno com o objeto, como quais foram os resultados obtidos e os caminhos percorridos. Esse serviço é fornecido por alguns LMS, mas o objeto precisa implementar os metadados necessários.

\subsection{Trabalho Relacionado: Ferramenta CARLOS}
Um dos trabalhos relacionados a este TCC é a ferramenta CARLOS (Collaborative Authoring of Reusable Learning ObjectS)\abreviatura{CARLOS}{Collaborative Authoring of Reusable Learning ObjectS}\cite{ref80} que utiliza um sistema multi-agente para modelar a autoria colaborativa de objetos de aprendizagem, esta ferramenta foi desenvolvida por serem poucas as ferramentas de autoria de objetos de aprendizagem que lidem com a colaboração entre os autores. Este trabalho possui as seguintes características principais: 1) Os autores colaboradores são representados por agentes e delegam a eles a negociação e avaliação das propostas; 2) A troca de mensagens entre os agentes é coordenada através de um protocolo de negociação; 3) A racionalidade dos agentes para avaliar as propostas é modelada em termos de relações de preferência e relevância, descritas com lógica nebulosa; 4) Os resultados das negociações são automaticamente armazenados e consolidados no OA.

Esta ferramenta é semelhante a este trabalho por ser uma ferramenta de autoria de OAs modelada com um sistema multi-agente. As principais diferenças são que CARLOS foca em criar o OA como um todo, tanto o conteúdo quanto os metadados, e utiliza um SMA com um objetivo diferente, auxílio na colaboração entre autores, ao invés de auxílio no preenchimento dos metadados de um OA por uma única pessoa, como neste trabalho.

\subsection{Requisitos da Ferramenta de Autoria deste trabalho}
De acordo com os resultados da pesquisa em \cite{ref38} foram definidos alguns requisitos desejáveis para a ferramenta de autoria de metadados que será desenvolvida neste trabalho:
\begin{itemize}
\item Automatizar e facilitar o preenchimento de metadados, utilizando agentes e o modelo de Agentes \& Artefatos.
\item Representar os metadados e os OAs através de ontologias, permitindo que agentes possam utilizá-los e que seja possível realizar inferências sobre os OAs, ampliando sua utilização pelos agentes.
\item Suportar o padrão de metadados brasileiro OBAA (Projeto OBjetos de Aprendizagem baseados em Agentes) \cite{refOBAA} \abreviatura{OBAA}{Projeto OBjetos de Aprendizagem baseados em Agentes}, que pretende utilizar as tecnologias de SMAs, OAs e computação ubíqua para possibilitar a autoria, armazenamento e recuperação de OAs em tempo hábil, em contextos diversos e através de diferentes plataformas de acesso.
\item Fornecer um tutorial ou manual para a ferramenta, visto que isso não foi disponibilizado por nenhuma das ferramentas estudadas.
\end{itemize}
Também é desejável que a ferramenta seja Web, para facilitar seu acesso e pela ausência de instalações para o usuário, caso isso não seja possível, então a ferramenta será disponibilizada em um arquivo .jar. Outro requisito adicional relevante seria que a ferramenta suporte os populares padrões Scorm e LOM, para que possa ser mais amplamente utilizada.



\section{Trabalhos Relacionados com Acesso de Agentes a Web Semântica}

Nesta seção serão descritos alguns trabalhos relacionados que utilizam agentes para acessar a Web Semântica. Em \cite{refB} os autores desenvolveram a arquitetura de agentes JASDL (Jason AgentSpeak DescriptionLogic), uma extensão da plataforma Jason. O objetivo deste trabalho é fornecer funcionalidades de programação de agentes combinadas com raciocínio ontológico, como generalização da ativação de planos e consultas a base de crenças baseadas em conhecimento ontológico. Para desenvolver esta arquitetura os autores utilizaram a OWL-API como o motor de inferência, que eles consideraram como mais elegante que a Jena API, além de fornecer funcionalidades de debug em caixa preta. \cite{refB} consideram JASDL como a primeira implementação completa de uma linguagem de programação orientada a agentes que utiliza, de forma transparente, ontologias e raciocínio ontológico em um contexto declarativo.

No artigo \cite{refC} é proposto Argonaut, um protótipo que integra Jason com o framework Jena com o objetivo de suportar computação baseada em contexto através de ontologias OWL. Os autores desenvolveram um SMA para a área de computação móvel, onde os agentes auxiliam o usuário a encontrar serviços localmente situados. Argonaut é a primeira abordagem prática a integrar OWl, Jason e Jena \cite{refC}. Neste modelo todas as interações com ontologias são definidas dentro de ações internas do Jason, ou seja, código Java estático. No caso da JASDL, a integração entre agentes e a Web Semântica ocorre de forma mais transparente, ampliando a base de crenças do Jason com a capacidade de raciocínio ontológico.

Em \cite{refA} os autores descrevem ITTALKS, um sistema Web que oferece acesso a informações sobre palestras, seminários e colóquios da área de tecnologia da informação através de notificações automáticas e inteligentes. Para isso, os autores desenvolveram um SMA capaz de acessar a Web Semântica utilizando a linguagem DAML (DARPA Agent Markup Language). A DAML é utilizada para definir as ontologias utilizadas pelo sistema, para a representação da base de conhecimento, raciocínio, e na comunicação entre agentes. Por utilizarem DAML, os agentes do ITTALKS são capazes de inferir informações adicionais sobre as palestras, como por exemplo encontrar palestras compatíveis com os interesses, rotina e localização do usuário, considerando inclusive o trânsito no momento.

Outros trabalhos relacionados relevantes são: \cite{refD} utiliza RDF e OWL como linguagens de descrição de conteúdo e serviços no contexto do framework TAGA (Travel Agent Game in Agentcities); \cite{refE} desenvolveram o EasyMeeting, um sistema ubíquo e inteligente para salas de reunião, que utiliza agentes e ontologias OWL para fornecer serviços e informações baseadas no contexto dos participantes da reunião; e em \cite{refF} é implementado S-APL(Semantic Agent Programming Language), uma linguagem baseada em RDF para a Web Semântica que integra a descrição semântica dos recursos do domínio com a prescrição semântica do comportamento dos agentes.

A principal diferença entre o projeto desenvolvido neste trabalho e os trabalhos relacionados é que nesta proposta a integração entre os agentes e a Web Semântica e feita através de artefatos. Os artefatos são utilizados como um middleware onde as interações ontológicas são processadas, e como uma ferramenta para coordenar os agentes. Algumas das vantagens de se utilizar artefatos para modelar ferramentas e recursos foram descritas na Seção \ref{sec:FuncArt}.



\chapter{Desenvolvimento}

\section{Visão Geral}
Neste trabalho foi desenvolvida uma ferramenta para o preenchimento de metadados de objetos de aprendizagem. Esta ferramenta auxilia no preenchimento dos metadados através recomendações. Na Figura \ref{fig:imgSlides} é mostrada uma visão geral do sistema, onde o usuário preenche os metadados já conhecidos, e então solicita ao sistema que lhe forneça recomendações para preencher um dos campos de metadados. O conhecimento parcial já fornecido pelo usuário é então enviado para o SMA, no qual os agentes utilizam os artefatos para processar consultas em SPARQL na DBPedia, de forma a obter as recomendações. Essas recomendações são então retornadas para a GUI e disponibilizadas para o usuário. É utilizada a linguagem Jason para modelar os agentes e o framework Cartago para programar os artefatos.

\begin{figure}
\begin{center}
\includegraphics[scale=0.45]{figuras/figura1slides.png}
\caption{Visão geral da ferramenta.}
\label{fig:imgSlides}
\end{center}
\end{figure}

Na Figura \ref{fig:imgSlides2} é mostrada uma visão geral do SMA desenvolvido neste trabalho. Existem três tipos de artefatos especializados em buscas semânticas, no caso, busca por indivíduos, por classes, e por categorias. Onde indivíduos e classes são os conceitos estruturais típicos de uma ontologia, e categorias é um conceito com função informativa, derivado no mapeamento da Wikipedia para a DBPedia. Além disso, também existem sub-buscas, busca abrangente e busca específica, na qual a primeira busca uma grande quantidade de resultados, mas de baixa qualidade, e a segunda busca poucos resultados de alta qualidade. Essas duas sub-buscas são disponibilizadas como operações no artefato, que os agentes podem acessar fornecendo como parâmetros a palavra-chave que será utilizada na busca e o limite da busca em largura. O resultado retornado aos agentes são os indivíduos obtidos pela busca. No caso da busca por classes e categorias, são retornados os indivíduos que pertencem as classes e categorias resultantes.

Cada agente é especializado em utilizar um destes três tipos de artefatos, havendo um mapeamento de 1 para 1 entre os agentes e os artefatos, pois o modelo de A\&A não permite que um artefato seja utilizado ao mesmo tempo por mais de um agente. No total existem nove agentes e nove artefatos de busca semântica. Além destes artefatos a Figura \ref{fig:imgSlides2} também representa os artefatos ArtefatoEntrada e ArtefatoSaida, que funcionam como uma integração entre a GUI e o SMA da ferramenta. Eles também servem para coordenar os agentes, onde o ArtefatoEntrada processa o conhecimento parcial em palavras-chaves e as fornece aos agentes, e o ArtefatoSaida recebe os resultados das buscas semânticas dos agentes e os processa em recomendações.

\begin{figure}
\begin{center}
\includegraphics[scale=0.4]{figuras/figura2slides.png}
\caption{Visão geral do sistema multi-agente.}
\label{fig:imgSlides2}
\end{center}
\end{figure}

\section{Ferramenta de Autoria de Metadados}

Na versão atual os campos para os quais podem ser geradas recomendações são Title, Description e Keywords da categoria General do Perfil Compatível Mínimo com OBAA (PM-OBAA-CORE). O perfil PM-OBAA-CORE foi escolhido por ser o perfil básico para um OA se adequar ao padrão OBAA e por ser simples o suficiente para permitir focar em poucos atributos. Este perfil possui quatro categorias de metadados: General, LifeCycle, Technical e Rights. Entre estas categorias somente os metadados Title, Description e Keywords foram escolhidos para gerar sugestões pois são os que possuem uma relação mais direta com as propriedades utilizadas pela DBPedia, como title, abstract e name. A GUI para cada uma das categorias é mostrada nas figuras abaixo (Figuras \ref{fig:imgGUI1} e \ref{fig:imgGUI2}), também é mostrada uma aba adicional (Figura \ref{fig:imgGUI3}), que fornece outra forma de ajuda ao usuário explicando o perfil e cada categoria. Ao passar o mouse pelos símbolos de interrogação o usuário pode ver a descrição do metadado e um exemplo de como utilizá-lo, de forma a ajuda o preenchimento dos metadados mesmo quando não podem ser geradas sugestões para os campos.

\begin{figure}
\begin{center}
\includegraphics[scale=0.4]{figuras/imgGUI1.png}
\caption{Screenshot da categoria General.}
\label{fig:imgGUI1}
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[scale=0.4]{figuras/imgGUI2v2.png}
\caption{Screenshots das categoria LifeCycle, Technical e Rights.}
\label{fig:imgGUI2}
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[scale=0.6]{figuras/imgGUI5.png}
\caption{Screenshot da aba de ajuda.}
\label{fig:imgGUI3}
\end{center}
\end{figure}

Conforme apresentado na Figura \ref{fig:imgGUI1}, os campos para os quais se pode gerar sugestões possuem o botão ``Help me!" ao lado. Quando o usuário clica neste botão requisitando ajuda a GUI coleta os valores já preenchidos pelo usuário para os campos Title, Description e Keywords e os envia para a classe Controladora, responsável por integrar a GUI aos artefatos. Na Figura \ref{fig:imgGUI2} são mostradas screenshots das abas que contém as categorias LifeCycle, Technical e Rights com seus respectivos campos de metadados. Nota-se que em duas das screenshots há um texto em um balão, este texto é mostrado cada vez que o usuário passa o mouse por cima do símbolo de interrogação de um metadado, auxiliando-o com informações extras sobre o preenchimento do campo do metadado. Na Figura \ref{fig:imgGUI3} é mostrada a aba de ajuda, que descreve o perfil de metadados sendo utilizado e dá mais informações sobre as suas categorias.

Após receber os valores da GUI a classe Controladora os processa obtendo as palavras-chaves de cada campo. Os valores obtidos nos campos Title e Description são transformados em palavras-chave utilizando técnicas de NLP (Processamento de Linguagem Natural)\abreviatura{NLP}{Processamento de Linguagem Natural}, esse processamento consiste em utilizar a biblioteca Apache Lucine para remover stopwords (tais como he, she, my, does, was), converter as palavras no plural para o singular, armazenando-as em um conjunto de strings. Para o campo Keywords as palavras-chaves são obtidas simplesmente separando-as pelo símbolo ;.

O conjunto de palavras-chaves é então agrupado em um único conjunto e enviado para um algoritmo de ranqueamento, que seleciona até oito palavras-chaves que apareceram com mais frequência no conjunto. Isso é feito pois se considera que se uma mesma palavra-chave é comum a vários campos ou é repetida várias vezes em uma Description então ela deve ser mais importante do que as que aparecem com menor frequência. O número de palavras-chaves obtidas foi definido como oito pois se considerou que apenas as palavras-chaves mais importantes deveriam ser usadas na busca semântica, de forma a reduzir o tempo de processamento e a quantidade de resultados irrelevantes para o usuário.

Ao completar o pré-processamento dos valores já preenchidos na GUI a classe Controladora envia as 8 palavras-chave selecionadas para o artefato ArtefatoEntrada, juntamente com o campo para o qual as sugestões devem ser geradas. As palavras-chaves ficam então disponíveis no ArtefatoEntrada, que é checado a cada meio segundo pelos agentes. Quando novas palavras-chaves estão disponíveis cada uma é obtida por um agente de um tipo de abordagem de busca semântica, de forma que possam ser processadas paralelamente.

Quando obtém uma palavra-chave o agente a processa utilizando um dos artefatos especializados em uma das abordagens de acesso a DBPedia. Existe um artefato para cada um dos três tipos de abordagens: por indivíduo, por classe e por categoria. Após processar os dados os agentes retornam os indivíduos obtidos ao artefato ArtefatoSaida, que os usa para obter os valores de propriedades equivalentes ao campo para o qual foram pedidas sugestões. Então o artefato retorna a GUI que mostra ao usuário as sugestões solicitadas para o campo. O diagrama para o fluxo de atividades descrito nessa seção é mostrado na Figura \ref{fig:imgICAART}. O processamento das palavras-chaves pelos agentes, artefatos especializados e pelo ArtefatoSaida é descrito em mais detalhes na seção a seguir.

\begin{figure}
\begin{center}
\includegraphics[scale=0.7]{figuras/icaart_portugues.png}
\caption{Diagrama de fluxo da ferramenta de autoria.}
\label{fig:imgICAART}
\end{center}
\end{figure}

\section{Modelo de Sugestões}

\subsection{Abordagens de Busca Semântica}
Para realizar a busca semântica de componentes da ontologia semelhantes às palavras-chaves são utilizadas três tipos de abordagem de busca semântica implementadas por agentes e artefatos: por indivíduos, por classe e por categorias. A busca por indivíduos obtém resultados filtrando diretamente os indivíduos da ontologia, enquanto as por classe e por categorias filtram um grupo de indivíduos (no caso, classes e categorias) e obtém resultados como sendo indivíduos que pertencem a estes grupos. As buscas são feitas pelos artefatos no repositório semântico DBPedia com consultas SPARQL no ponto de acesso Virtuoso, estas consultas são realizadas utilizando a API Jena. Existe um artefato especializado para cada tipo de abordagem, eles fornecem duas formas de utilizar a abordagem: através de uma busca abrangente e de uma busca específica. Essas buscas são um trade-off entre quantidade de resultados e velocidade de processamento, na busca abrangente, por qualidade de resultados, na busca específica. O agente inicialmente utiliza a busca abrangente da abordagem no qual é especializado, e dependendo dos resultados utiliza a busca específica para refiná-los.

\subsection{SMA}
No sistema multi-agente deste trabalho existem três tipos de agentes especializados nas abordagens (atuador\_por\_individuos, atuador\_por\_classes e atuador\_por\_categorias) e um único agente inicializador, responsável por criar o artefatos que os outros agentes utilizarão. Existem três agentes para cada uma das três abordagens possíveis, então no total o SMA é composto por 10 agentes.

Segue abaixo o arquivo .mas2j que configura o sistema:
\begin{lstlisting}[frame=tb]
MAS example01_useobs {

environment: c4jason.CartagoEnvironment

agents:  
inicializador agentArchClass c4jason.CAgentArch #1;
atuador_por_individuos agentArchClass c4jason.CAgentArch #3;
atuador_por_classes agentArchClass c4jason.CAgentArch #3;
atuador_por_categorias agentArchClass c4jason.CAgentArch #3;

classpath: ``../lib/cartago.jar";``../lib/c4jason.jar";``../lib/lib-jena/*.jar";``../lib/lucene-3.6.2/*.jar";``../lib/lucene-3.6.2/contrib/analyzers/common/*.jar";
	
aslSourcePath:
``agents";
\end{lstlisting}

O agente inicializador cria um ArtefatoEntrada, um ArtefatoSaida e três de cada tipo de artefato específico para as abordagens de busca. Os artefatos das abordagens recebem os mesmos nomes dos agentes com números de 1 a 3, desta forma os agentes sabem qual artefato devem usar apenas sabendo o seu próprio nome. Foi necessário criar várias instâncias de cada artefato pois o modelo Cartago possui a propriedade de atomicidade das operações, de forma que mais de um agente não pode utilizar uma mesma operação ao mesmo tempo.

\begin{lstlisting}[frame=tb]
!create_and_use.

+!create_and_use : true
  <- !setupTools;
  	println(``artefatos criados").

// create the tools
+!setupTools: true 
  <- makeArtifact(``entrada",``artifacts.ArtefatoEntrada",[],A1);
  	 makeArtifact(``saida",``artifacts.ArtefatoSaida",[],A2);
	 makeArtifact(``atuador_por_individuos1",``artifacts.AbordagemPorIndividuo",[],A3);
	 makeArtifact(``atuador_por_individuos2",``artifacts.AbordagemPorIndividuo",[],A6);
	 makeArtifact(``atuador_por_individuos3",``artifacts.AbordagemPorIndividuo",[],A9);
	 makeArtifact(``atuador_por_classes1",``artifacts.AbordagemPorClasses",[],A4);
	 makeArtifact(``atuador_por_classes2",``artifacts.AbordagemPorClasses",[],A7);
	 makeArtifact(``atuador_por_classes3",``artifacts.AbordagemPorClasses",[],A10);
	 makeArtifact(``atuador_por_categorias1",``artifacts.AbordagemPorCategoria",[],A5);
	 makeArtifact(``atuador_por_categorias2",``artifacts.AbordagemPorCategoria",[],A8);
	 makeArtifact(``atuador_por_categorias3",``artifacts.AbordagemPorCategoria",[],A11).
\end{lstlisting}

\subsection{Prefixos}
Em SPARQL são definidos prefixos para indicar de forma simplificada que ontologias podem ser utilizadas pela busca semântica. Os prefixos utilizados neste trabalho são:

\begin{lstlisting}[frame=tb]
PREFIX db-prop: <http://dbpedia.org/property/>
PREFIX dbpedia-owl:<http://dbpedia.org/ontology/>
PREFIX rdf:<http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX dbpedia_category: <http://dbpedia.org/resource/Category:>
PREFIX dcterms: <http://purl.org/dc/terms/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX yago:<http://dbpedia.org/class/yago/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
\end{lstlisting}

Este conjunto de prefixos será representado pela chamada ao método getPrefixes() nas buscas com SPARQL.

\subsection{Filtros}
Filtros são utilizados para refinar uma busca semântica com SPARQL de forma a aumentar a qualidade dos resultados obtidos. Foram definidos quatro tipos de filtros: classes simples, classes avançado, categorias simples e categorias avançado. Filtrar por classe ou por categoria significa que indivíduos que sejam direta ou indiretamente subclasses de classes filtradas ou pertençam a categorias filtradas não serão retornados pela busca. Os subtipos simples e avançado indicam o quão restritiva é a filtragem, com avançado considerando mais parâmetros e tendo um processamento mais lento.

O critério para definir quais classes e categorias seriam filtradas foi baseado na funcionalidade desta ferramenta: como ela é usada para preencher metadados apenas de OAs, então são filtradas conceitos que tem pouca relação com ensino e aprendizagem, como literatura de periódicos, shows de televisão, bandas, músicas e times de futebol. Outro critério para definição da filtragem é que foi percebido durante os testes da ferramenta que alguns conceitos que tinham grandes chances de trazerem resultados inúteis para o contexto da ferramenta, como pessoas e profissões, então estes também foram adicionados à filtragem. Em uma versão futura da ferramenta poderia ser habilitada a customização de filtros, de forma que o usuário possa escolher receber sugestões que incluam músicas, por exemplo, caso o OA em questão seja sobre música. A lista completa dos filtros utilizados neste trabalho encontra-se no Apêndice .

\subsection{Abordagem por Individuo}
Na abordagem por indivíduo o objetivo é obter os indivíduos da ontologia que sejam mais semelhantes a palavra-chave recebida. Para isso são procurados na DBPedia indivíduos cujas propriedades db-prop:title ou db-prop:name que contenham a palavra-chave. Na abordagem por indivíduos os filtros de classe simples e avançado são utilizados na busca abrangente, e os filtros de categoria simples e avançado são utilizados para refinar os resultados na busca específica. No momento os agentes sempre efetuam uma busca abrangente e logo em seguida uma busca específica, para aumentar a qualidade dos resultados. Caso a busca especifica sobre os resultados da busca abrangente zere os resultados obtidos, o agente retorna para o ArtefatoSaida os resultados da busca abrangente, ao invés dos da busca específica.

O código do agente atuador\_por\_indivíduo que efetua este raciocínio segue abaixo. Primeiro o agente obtém os artefatos ArtefatoEntrada, ArtefatoSaida e AbordagemPorIndividuo. Então com a intenção !consumeItems ele passa a checar o ArtefatoEntrada a cada 1 segundo, com a operação get\_para\_Individuos(Item). Ao receber uma palavra-chave para processar, o agente a envia junto com um limite de resultados para a operação  executar\_abrangente do artefato AbordagemPorIndividuo. Após receber os indivíduos resultantes, os envia para a operação  executar\_especifico. Na etapa final o agente checa se ao executar a operação executar\_especifico os resultados foram zerados. Se sim, os resultados da busca abrangente são enviados para o ArtefatoSaida, se não os resultados enviados são os da busca específica. O agente utiliza duas operações put neste envio, a primeira envia os resultados para um aglomerado geral de resultados de todos os agentes, e o put\_more\_value envia estes resultados para uma lista específica, utilizada para atribuir mais valor a resultados da abordagem por indivíduos. Este algoritmo de ranqueamento será explicado em mais detalhes na Seção \ref{sec:ProcessamentoResultados}. Artefato de saída.

\begin{lstlisting}[frame=tb]
!observe.

+!observe : true 
  <- .wait(200); 
    ?myTools(A1, A2, Id);  // discover the tools
    println(``agente criado");
    !consumeItems(Id).

+!consumeItems(Id): true
<- .wait(1000);
get_para_Individuos(Item);
!processItem(Item, Id);
!!consumeItems(Id).

+!processItem(null, Id) : true.

+!processItem(Keyword, Id) : true
<-  executar_abrangente(Keyword, 50, Result)[artifact_id(Id)];
	executar_especifico(Result, Result2)[artifact_id(Id)];
	isEmpty(Result2, Test)[artifact_id(``entrada")];
	!decidir(Result1, Result2, Test, Id).	

+!decidir(Result1, Result2, Test, Id) : Test
<- .my_name(Me); println(Me,``: vazio");
	put_more_value(Result2);
	put(Result2).
	
+!decidir(Result1, Result2, Test, Id) : true
<- .my_name(Me); println(Me,``: não vazio");
	put_more_value(Result2);
	put(Result2).

+?myTools(A1, A2, A3): true 
  <- lookupArtifact(``entrada",A1);
  	 lookupArtifact(``saida",A2);
	 .my_name(N);
	 lookupArtifact(N,A3).

-?myTools(A1, A2, A3): true 
  <- .wait(100); 
     ?myTool(A1, A2, A3).
\end{lstlisting}

Abaixo segue o código da operação executar\_abrangente do artefato AbordagemPorIndividuo que executa a busca semântica abrangente utilizando a API Jena. Primeiro é montada uma string com a busca SPARQL para obter indivíduos cujos db-prop:title ou db-prop:name contenham a palavra-chave. Os métodos filtrarClasses(classes\_filtradas\_simples) e filtrarClasses(classes\_filtradas\_avancado) retornam uma string com um filtro de classes, o código deste método está logo abaixo do código da operação. Com a query montada a API Jena é utilizada para se conectar ao ponto de acesso da DBPedia, processar a query, e extrair os resultados. Os resultados são então retornados para o agente através do parâmetro  OpFeedbackParam<Object> result.

\begin{lstlisting}[frame=tb]
@OPERATION
    void executar_abrangente(String keywordrecebida, int limit, OpFeedbackParam<Object> result)
    {
        String keyword = NLPTool.toLowerCase(keywordrecebida);
        
        String queryString = getPrefixes()
                + ``SELECT distinct ?object "
                + ``WHERE {"
                + ``{?object db-prop:title ?title . ?title <bif:contains> \"``+keyword+"\`` . }"
                + `` UNION "
                + ``{?object  db-prop:name ?name. ?name <bif:contains> \"``+keyword+"\`` . }"
                + filtrarClasses(classes_filtradas_simples)
                + filtrarClasses(classes_filtradas_avancado)
                + ``}"
                + ``LIMIT "+limit;
        
        QueryExecution qe = new QueryEngineHTTP(``http://dbpedia.org/sparql", queryString);

        ArrayList<String> individuos = new ArrayList<String>();
        try
        {
            ResultSet results = qe.execSelect();
            for (; results.hasNext();)
            {
                QuerySolution s = results.next();
                individuos.add(s.getResource(``object").toString());
            }
        }
        finally
        {
           qe.close();
        }
        
        result.set(individuos);
        System.out.println(``LOG: Abordagem por Individuos ENDED: "+individuos.size());
    }
\end{lstlisting}

\begin{lstlisting}[frame=tb]
private String filtrarClasses(ArrayList<String> classes)
    {
        String result = ``";
        for(String s: classes)
            result += ``filter (NOT EXISTS {?object a ``+s+" }) .";
        return result; 
    }
\end{lstlisting}

O código da operação para a busca específica é igual ao da busca abrangente, com a diferença que a filtragem ocorre chamando o método filtrarCategorias(categorias\_filtradas, 4) e filtrarCategorias(categorias\_filtradas\_avancado, 3), e a busca não é mais filtrada para classes. A filtragem por categoria ocorre na busca específica por ser muito mais lenta que a filtragem por classes.

O código para filtrarCategorias é mostrado abaixo. Para este filtro foi necessário usar a option TRANSITIVE para limitar a profundidade da busca, pois um indivíduo pode pertencer a um grande número de categorias de forma indireta. O parâmetro T\_MAX define o valor da profundidade.
\\
\\

\begin{lstlisting}[frame=tb]
private String filtrarCategorias(ArrayList<String> categorias, int t_max)
    {
        String option = ``option(TRANSITIVE , T_DISTINCT, t_max(``+t_max+"))";
        String result = ``";
        for(String s: categorias)
            result += ``filter (NOT EXISTS {?object dcterms:subject ?Category . ?Category skos:broader dbpedia_category:``+s+" ``+option+" }) .";
        return result;  
    }
\end{lstlisting}

\subsection{Abordagem por Classes}
Nesta abordagem são selecionadas as classes que possuam a propriedade rdfs:label que contenha a palavra-chave recebida. Na busca abrangente é feita uma seleção de classes com o filtro de classes simples. Após todas as classes tenham sido obtidas ou o número máximo de classes selecionadas tiver sido atingido (limite1) elas são retornadas para o agente. O agente pode então enviar estas classes para a busca especifica, que as refina usando o filtro de classes avançado. Antes de enviar os resultados para o ArtefatoSaida o agente processa as classes para obter todos os indivíduos que são subclasses delas, até um limite de indivíduos determinado pelo agente (limite2). Esta abordagem produz mais resultados que a abordagem por indivíduos, pois o máximo de indivíduos retornados é a multiplicação limite1*limite2.

O código do agente atuador\_por\_classes é semelhante ao do agente para indivíduos e se encontra no Apêndice \ref{apendices:agenteclasses}. As principais diferenças entre os dois são sendo: ela utiliza o get especifico para os agentes da abordagem por classes; possui valores de limite menores, por eles multiplicarem o resultado final; a operação ``executar\_getIndividuos" ser chamada para obter os indivíduos das classes antes de retornar os resultados para o ArtefatoSaida; e a operação put\_less\_value ser chamada ao invés da put\_more\_value, pois percebeu-se nos testes da ferramenta que esta abordagem costuma gerar resultados bastante imprecisos. A imprecisão dos resultados ocorre pois a filtragem não é realizada diretamente sobre os indivíduos obtidos, estes indivíduos são obtidos se possuírem uma relação de subclasse de uma distância de até quatro classes, e porque classes não pertencem a categorias, então os filtros para categorias não puderam ser aplicados.

A operação para executar uma busca abrangente e método utilizado para fazer a filtragem por classe no artefato AbordagemPorClasses são apresentados no Apêndice \ref{apendices:buscaclasses}. A operação faz uma busca SPARQL onde se procura um valor Concept que seja uma classe e cujo título contenha a palavra-chave. Também é feita uma filtragem por classe simples com profundidade igual a 5. As classes obtidas são então retornadas para o agente. A busca específica segue o mesmo padrão da busca abrangente, porém o filtro utilizado é o para classes avançadas com profundidade 5.

O método para obter os indivíduos que são subclasses de uma classe segue abaixo. Este método é chamado várias vezes para cada classe obtida previamente. A profundidade de busca utilizada é 4.

\begin{lstlisting}[frame=tb]
public ArrayList<String> getAllSubClasses(String classe, int limit)
    {
        String queryString = AbordagemPorIndividuo.getPrefixes()
                + ``select distinct ?subclass where {"
                + `` ?subclass a <``+classe+"> option(TRANSITIVE, t_distinct, T_MAX(4))."
                + ``} LIMIT "+limit;
        
        QueryExecution qe = new QueryEngineHTTP(``http://dbpedia.org/sparql", queryString);
                
        ArrayList<String> subclasses = new ArrayList<String>();
        try
        {
            ResultSet results = qe.execSelect();
            for (; results.hasNext();)
            {
                QuerySolution s = results.next();
                subclasses.add(s.getResource(``subclass").toString());
            }
        }
        finally
        {
           qe.close();
        }
        return subclasses;
    }
\end{lstlisting}

\subsection{Abordagem por Categorias}
Esta abordagem é análoga a abordagem por classes, porém são utilizadas categorias, um conceito específico da DBPedia. Cada indivíduo pode estar em várias categorias, e existe uma hierarquia de categorias, com algumas sendo mais amplas e outras mais específicas. Um indivíduo também pode participar de uma categoria indiretamente, por exemplo o indivíduo ``http://dbpedia.org//ontology/American\_bison"

\noindent pertence a categoria ``http://dbpedia.org/resource/Category:Bison",

\noindent cuja categoria mais ampla é ``http://dbpedia.org/resource/Category:

\noindent Bovines", então American\_bison também participa da categoria Bovines. Na busca abrangente é utilizado o filtro para categorias simples, e na busca específica é utilizado o filtro avançado. Por haverem muitas relações entre categorias estouros de memória são comuns durante a filtragem, para se adequar a isso esta abordagem começa com um valor de profundidade inicial igual a 6, e vai reduzindo-o em 2 reiniciando a busca cada vez que ocorre uma exceção de estouro de memória. A operação termina quando o artefato consegue processar a busca SPARQL sem um estouro de memória ou quando o valor da profundidade zera, retornando nenhuma categoria.

O código do agente atuador\_por\_categorias está disponível no Apêndice . Ele é análogo ao do atuador por classes, porém utiliza o get específico para agentes que utilizam a abordagem por categorias e ele chama apenas um método put, pois recebe uma pontuação padrão no ranqueamento, tendo resultados com qualidade intermediária em relação as outras abordagens.

O código da operação de busca abrangente é está disponível no Apêndice \ref{apendices:buscacat}. Ele é composto por três partes, a primeira administra as exceções de estouro de memória e o decréscimo do valor da profundidade como descrito acima. O código para busca específica é igual, apenas chamando o método executar\_especifico2(categorias, t\_max); ao invés de executar\_abrangente2(keyphrase, t\_max, limit). A segunda parte é o código do método que efetua a busca SPARQL. São pesquisados conceitos que sejam categorias e cuja propriedade rdfs:label contenha a palavra-chave. Na busca abrangente utiliza-se o filtro para categorias simples, e na específica o filtro avançado. Por fim, a terceira parte do código é o método para obter os indivíduos que pertencem a uma categoria. Este método é chamado várias vezes para cada categoria obtida previamente. Não há limite para a profundidade da busca, o único limite é a largura da busca definida pelo agente.

\subsection{Processamento dos resultados} \label{sec:ProcessamentoResultados}
Quando os agentes terminam de processar a palavra-chave recebida para obter indivíduos, eles os retornam para o artefato ArtefatoSaida. Todos os agentes utilizam a operação put para retornar os indivíduos, essa operação adiciona os indivíduos a uma lista e aumenta um contador cada vez que é chamada. Quando esse contador chegar em (quantidade de palavras-chaves)*(quantidade de agentes por tipo), ou seja, todos os agentes que obtiveram palavras-chave retornaram os resultados, a operação chama um algoritmo de ranqueamento que retorna os 20 melhores resultados e altera o atributo ``pronto" para true. Este atributo é checado constantemente por uma Thread da classe Controladora para saber quando deve enviar os resultados para a GUI. Adicionalmente, o agentes que atuam por individuo também também a operação put\_more\_value e os por classe chamam a put\_less\_value para adicionar os indivíduos retornados em listas específicas que afetam a pontuação que esses indivíduos receberão no ranqueamento. Abaixo segue o código das operações put, put\_more\_value e put\_less\_value.

\begin{lstlisting}[frame=tb]
@OPERATION
    void put(Object obj)
    {
        ArrayList<String> array = (ArrayList<String>)obj;
        items.addAll(array);

        cont++;
        int quantAgentsPorTipo = 3;
        if(cont ==  Controladora.quantKeywords*quantAgentsPorTipo)
        {
            resultados_por_quant = Rank.rankByQuant(20, items, items_less_value, items_more_value);
            System.out.println(``rankeado: "+resultados_por_quant);
            pronto = true;
        }
    }
    
    @OPERATION
    void put_less_value(Object obj)
    {
        ArrayList<String> array = (ArrayList<String>)obj;
        items_less_value.addAll(array);
    }
    
    @OPERATION
    void put_more_value(Object obj)
    {
        ArrayList<String> array = (ArrayList<String>)obj;
        items_more_value.addAll(array);
    }
\end{lstlisting}

O algoritmo de ranqueamento efetuado pela classe Rank organiza os indivíduos em uma lista sem repetições atribuindo 0 pontos a cada um. Então o algoritmo percorre novamente a lista, aumentando a pontuação do indivíduo cada vez que ele é encontrado, pois se considera que se vários agentes utilizando diferentes abordagens encontraram um mesmo indivíduo, então ele deve ter mais importância que os outros. Indivíduos obtidos pela abordagem por indivíduos recebem 1.3 pontos, pela por categorias 1 ponto e pela por classes 0.8 pontos.

As abordagens valem diferentes quantidades de pontos pois a qualidade dos seus resultados varia bastante. Como a abordagem por indivíduos filtra diretamente os resultados finais, tem resultados melhores e vale mais pontos, mas por ser bastante específica na busca pode gerar poucos resultados. No caso das abordagens por categoria e por classe, ambas possuem o defeito de gerar resultados piores pois o filtro não ocorre diretamente nos indivíduos obtidos, elas também podem gerar uma grande quantidade de resultados finais. Porém nos testes com a ferramenta foi percebido que os resultados da abordagem por categoria ainda são melhores que a por classe, acredita-se que isso ocorra por Category ser um conceito próprio da DBPedia, então está melhor modelada no repositório semântico. O código utilizado para o algoritmo de ranqueamento é mostrado abaixo, o método sortValue usado pelo algoritmo serve para ordenar a lista em ordem decrescente de pontuação.

\begin{lstlisting}[frame=tb]
public static List<String> rankByQuant(int quant, ArrayList<String> individuos, ArrayList<String> less_value, ArrayList<String> more_value)
    {
        if(individuos.isEmpty())
            return new ArrayList<String>();
        Collections.sort(individuos);
        Hashtable<String, Double> ranked = new Hashtable<String, Double>();
        double points;
        for(int i = 0; i < individuos.size(); i++)
        {
            ranked.put(individuos.get(i), 0.0);
        }
        for(int i = 0; i < individuos.size(); i++)
        {
            points = 1;
            if(less_value.contains(individuos.get(i)))
            {
                points = 0.8;
                less_value.remove(individuos.get(i));
            }else if(more_value.contains(individuos.get(i)))
            {
                points = 1.3;
                more_value.remove(individuos.get(i));
            }
            ranked.put(individuos.get(i), ranked.get(individuos.get(i)) + points);
        }
        
        ArrayList<String> s_ranked = sortValue(ranked, false);
        if(quant > s_ranked.size())
            quant = s_ranked.size();
        return s_ranked.subList(0, quant);
    }
\end{lstlisting}

Quando a Thread da classe Controladora percebe que os resultados terminaram de ser ranqueados através do atributo ``pronto" ela chama o método getItemsDevolvidos. Este método obtém valores de propriedades específicas dos indivíduos ranqueados, dependendo do campo para qual foi pedida a sugestão de metadado. Para o campo ``Description" são buscados os valores das propriedades dbpedia-owl:

\noindent abstract e rdfs:comment de cada indivíduo. Para os campos ``Title" e ``Keyword" são buscados os valores das propriedades db-prop:title, db-prop:name, foaf:name e rdfs:label. Caso mais de um valor para uma propriedade seja encontrado apenas o primeiro da lista é retornado, também é retornado apenas um valor no total, com a ordem de prioridade sendo a ordem em que as propriedades apareceram listadas.

Optou-se utilizar várias propriedades por campo porque não existia uma propriedade que todos os indivíduos possuíssem garantidamente. Também optou-se por obter as mesmas propriedades para ambos os campos ``Title" e ``Keyword" porque não foi encontrada uma propriedade específica para palavras-chaves na DBPedia, mas percebeu-se que as quatro propriedades citadas geralmente incluíam poucas palavras, então funcionavam também como palavras-chave. A busca SPARQL utilizada para obter essas propriedades é mostrada abaixo, onde ``individuo" é um individuo da lista de indivíduos ranqueados e ``prop" é a propriedade que se quer obter.

\begin{lstlisting}[frame=tb]
``SELECT distinct ?title "
                + ``WHERE "
                + ``{<``+individuo+"> ``+prop+" ?title . FILTER ( lang(?title) = \``en\") .}"
                + ``LIMIT 5";
\end{lstlisting}

Após obter os valores específicos por campo, a Thread os concatena em uma String e envia como texto para a JTextArea no JDialog que foi mostrado para o usuário ao clicar em ``Help me". São mostrados tanto a URI do indivíduo da onde foi obtida a sugestão como o valor da propriedade buscada. Na Figura \ref{fig:imgProcResultados} o usuário digitou ``bison" no campo Keywords e clicou no botão ``Help me!" para o campo Title.

\begin{figure}
\begin{center}
\includegraphics[scale=0.45]{figuras/imgDesenvolvimento1.png}
\caption{Saída da ferramenta com o campo Keywords preenchido com a palavra ``bison"  para o campo Title.}
\label{fig:imgProcResultados}
\end{center}
\end{figure}

\section{Análise dos Resultados das Abordagens}

Para analisar a qualidade das recomendações feitas pela ferramenta desenvolvida foram definidos alguns critérios. Estes critérios são subjetivos e nem sempre é óbvio se uma sugestão cumpre ou não um critério. O objetivo desta definição é obter uma ideia geral da qualidade das sugestões obtidas, considerando o contexto de um OA utilizado para ensino e aprendizagem.\newline

Critérios:
\begin{itemize}
\item A sugestão é boa se for baseada em um indivíduo que...
\begin{itemize}
\item For um subtipo da palavra-chave.
\item Se possuir uma relação direta de causa-efeito com a palavra-chave.
\end{itemize}
\item A sugestão é ruim se for baseada em um indivíduo que...
\begin{itemize}
\item For um dia comemorativo que inclui a palavra-chave.
\item For o nome de uma organização, empresa, produto, livro ou time esportivo que contiver a palavra-chave.
\item Não houver uma relação visível entre a sugestão e a palavra-chave.
\item For o nome de uma pessoa que não seja a descobridora, inventora ou desenvolvedora da palavra-chave.
\item For um conceito altamente acadêmico da palavra-chave original, com poucas chances de ser útil em um OA para o Ensino Médio.
\end{itemize}
\end{itemize}

Nos casos que houve dúvida se uma sugestão era boa ou ruim, foi dada a ela um meio ponto, se não for possível definir a qualidade para mais uma sugestão, ela também vale meio ponto, totalizando 1 ponto, ou uma classificação como uma única sugestão boa.
\\

Nas Tabelas \ref{table:resultadosA} e \ref{table:resultadosB} são mostradas as quantidades de indivíduos obtidas por cada abordagem e a qualidade destes resultados. Para ambas as palavras-chaves ``bison" e ``tuberculosis" foram obtidos poucos resultados pela abordagem de classes, isso foi comum para várias das palavras-chaves testadas, sendo que quando eram obtidos resultados por essa abordagem eles geralmente eram de baixa qualidade. A abordagem por indivíduos foi a que obteve resultados consistentes com maior frequência, no caso dos dados abaixo, 10 de 23 e 6 de 8 indivíduos foram de boa qualidade.

\begin{table}[h]
\begin{center}
\caption{Resultados por abordagem para a palavra-chave ``bison"}
\label{table:resultadosA}
\begin{tabular}{c|c|c|c}
\hline
Bison & Total de indiv. obtidos & Sugestão boa & Sugestão ruim\\
\hline
\hline
indivíduos & 23 & 10 & 13\\
\hline
classes & 1 & 0 & 1\\
\hline
categorias & 26 & 10 & 16\\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table}[h]
\begin{center}
\caption{Resultados por abordagem para a palavra-chave ``tuberculosis"}
\label{table:resultadosB}
\begin{tabular}{c|c|c|c}
\hline
Tuberculosis & Total de ind. obtidos & Sugestão boa & Sugestão ruim\\
\hline
\hline
indivíduos & 8 & 6 & 2\\
\hline
classes & 0 & 0 & 0\\
\hline
categorias & 20 & 3 & 17\\
\hline
\end{tabular}
\end{center}
\end{table}

Na Tabela \ref{table:resultadosC} é mostrada uma análise da qualidade dos 10 resultados finais ranqueados para diferentes palavras-chaves. Durante os testes, percebeu-se que uma outra utilidade da ferramenta é possibilitar a pesquisa de mais informações a respeito do tópico do OA, já que além da sugestão para o campo solicitado é também mostrado o endereço para o indivíduo na DBPedia. Por isso, essa tabela também mostra se nos indivíduos mostrados para o usuário está incluso um indivíduo que é a definição da palavra-chave enviada para a ferramenta. As palavras-chaves escolhidas foram tanto palavras que podem ser conteúdo de um OA para o Ensino Médio como palavras-chaves para as quais pudessem ser aplicadas os critérios de qualidade de forma bem definida.

\begin{table}[h]
\begin{center}
\caption{Qualidade dos resultados para algumas palavras-chaves}
\label{table:resultadosC}
\begin{tabular}{c|c|c|c}
\hline
Palavra-chave & Sugestão boa & Sugestão ruim & Definição é mostrada?\\
\hline
\hline
tuberculosis & 7 & 3 & sim\\
\hline
bison & 7 & 3 & sim\\
\hline
algebra & 2 & 8 & não\\
\hline
geometry & 1 & 9 & não\\
\hline
morphology & 0 & 10 & não\\
\hline
\end{tabular}
\end{center}
\end{table}

Houveram 70\% de resultados satisfatórios para as palavras-chaves tuberculosis e bison, pois os resultados retornaram vários subtipos destas palavras-chaves. Os resultados para a palavra-chave algebra foram enfraquecidos porque foram retornados vários programas que trabalham com algebra, ao invés de conceitos relacionados à algebra. E tanto para algebra como para geometry foram retornados resultados para conceitos de nível acadêmico, que são considerados de qualidade ruim pois está se considerando o cenário desta ferramenta ser usada para OAs para estudantes de Ensino Médio. Não houve nenhuma boa sugestão gerada para a palavra-chave morphology porque todos os indivíduos retornados representavam livros, e por tanto possuíam informações sobre os livros e não sobre o conceito sendo pesquisado.

Pelos resultados obtidos percebe-se que a ferramenta é eficiente para buscar mais informações sobre um conceito, mas possui um desempenho ruim para obter sugestões específicas para um OA, no cenário de ensino e aprendizagem. Sugestões melhores poderiam ser geradas se fosse usado um repositório semântico específico para ensino e aprendizagem. Tendo em vista que a DBPedia não possui este foco, a amplitude da base semântica gerou tanto problemas em termos de desempenho como de qualidade dos resultados obtidos. Em relação a desempenho, uma busca abrangente leva de 1 a 2 minutos para completar, e uma busca específica pode levar até 10 minutos, isso ocorre pois é necessário utilizar muitos filtros para tentar criar um foco nos resultados para ensino e aprendizagem. E quanto a qualidade, mesmo com a utilização de filtros e com o tempo gasto nas buscas ainda assim são obtidos vários resultados com informações muitos avançadas ou irrelevantes. Ao mesmo tempo, para algumas matérias comuns de sala de aula não foram encontrados nenhum resultado, como logaritmo, entalpia e mercantilismo, pois esses conceitos não foram adicionados à DBPedia.

\chapter{Conclusões}

O objetivo geral deste trabalho foi analisar e aplicar a abordagem de Agentes\&Artefatos para o desenvolvimento de um sistema de autoria de metadados de objetos de aprendizagem utilizando um repositório semântico. Este objetivo possui os seguintes objetivos específicos:
\begin{enumerate}
\item Especificar os requisitos da ferramenta de autoria de metadados. 
\item Compreender a tecnologia de A\&A. 
\item Compreender o armazenamento de dados em repositórios semânticos. 
\item Modelar o repositório semântico com A\&A para poder ser utilizado pelos agentes. 
\item Modelar ou utilizar uma ontologia que será usada pelos agentes para acessar os objetos de aprendizagem do repositório semântico. 
\item Implementar o sistema de autoria de metadados com A\&A. 
\item Contextualizar a contribuição do sistema desenvolvido nas áreas de SMA e e-learning.
\\*
\end{enumerate}

Os três objetivos iniciais foram abordados na parte teórica do trabalho, onde se explicou amplamente SMAs e o modelo de A\&A nas seções \ref{sec:agentessma} e \ref{sec:agentesartefatos}, o funcionamento e conceitos relacionados aos repositórios semânticos foram abordados na seção \ref{sec:ontrepsem}, e uma discussão sobre funcionalidades e requisitos de ferramentas de autoria de metadados foi feita na seção \ref{sec:aprendizagem}. Os quatro principais requisitos citados na seção \ref{sec:aprendizagem} foram implementados:

\begin{itemize}
\item suportar o padrão de metadados OBAA: A ferramenta suporta o perfil PM-OBAA-CORE, considerado o essencial para que um OA seja adequado ao padrão OBAA.
\item facilitar preenchimento dos metadados com A\&A: São fornecidas sugestões para três campos de metadados: Title, Description e Keyword, que foram escolhidos pois tem alto potencial para se obter sugestões.
\item representar metadados com ontologias: Ao invés de criar uma ontologia para representar os OAs, se escolheu utilizar as propriedades da ontologia da DBPedia que eram compatíveis com os campos de metadados para os quais se queria gerar as sugestões, como db-prop:title e db-prop:name para sugestões para o campo Title.
\item fornecer um tutorial para a ferramenta e os metadados: Na GUI da ferramenta são disponibilizados tanto uma aba específica com explicações sobre os metadados e categorias do perfil como ícones de interrogação que fornecem mais informações sobre um metadado específico.
\end{itemize}

Também foi sugerido que a ferramenta fosse Web, para ser mais acessível, e suportasse outros padrões de metadados comuns, como Scorm e LOM, mas se preferiu deixar estas funcionalidades para uma versão futura do trabalho, para que o foco fosse a geração de sugestões.

Quanto aos objetivos 4 e 5, estes foram atingidos utilizando a API Jena em artefatos para criar e processar consultas SPARQL no repositório semântico DBPedia através do ponto de acesso Virtuoso. Foram criados três artefatos especialistas em três tipos de abordagens (por indivíduos, por classes e por categorias) que implementam operações utilizando a API Jena para criar e processar buscas semânticas abrangentes ou específicas, permitindo que os agentes tenham acesso a Web Semântica. A ontologia utilizada foi a da própria DBPedia.

O objetivo 6 também foi alcançado com sucesso: Neste trabalho foi desenvolvida uma ferramenta capaz de obter sugestões para os campos de metadados do perfil PM-OBAA-CORE baseando-se nos campos já preenchidos pelo usuário, que são transformados em palavras-chaves. Estas sugestões são obtidas utilizando um SMA que acessa a DBPedia para obter indivíduos similares as palavras-chaves recebidas, e então obtém os valores de propriedades dos dez indivíduos mais relevantes para retornar como sugestões de preenchimento para o usuário na GUI.

Foram encontradas duas dificuldades na obtenção de sugestões por buscas semânticas na DBPedia, ambas baseadas no fato de a DBPedia não ser um repositório semântico específico para ensino e aprendizagem. Devido aos vários filtros de classes e categorias utilizados para remover resultados que não fossem relevantes para o contexto de ensino e aprendizagem os tempos de consulta à DBPedia são bastante grandes, e mesmo com a utilização destes filtros as sugestões obtidas tiveram uma qualidade baixa este cenário. Além disso, frequentemente não haviam conceitos registrados na DBPedia para matérias comuns de sala de aula. Um possível trabalho futuro para melhorar a performance e qualidade da obtenção de sugestões seria utilizar outro repositório semântico, mais específico para o cenário de ensino e aprendizagem. Este repositório poderia ser tanto um já existente ou criado do zero.

Por fim, quanto ao último objetivo, a principal contribuição deste trabalho para a área de SMA é ter criado uma ferramenta utilizando A\&A que permite que agentes tenham acesso à Web Semântica. Até nosso conhecimento, este é o primeiro protótipo de acesso de agentes à Web Semântica que utiliza esta abordagem. Em relação à área de e-learning, o trabalho desenvolvido é um protótipo inicial para uma ferramenta de geração automática de sugestões para metadados, de forma a facilitar o preenchimento e adequação de OAs à padrões de metadados.

Os artefatos para buscas semânticas desenvolvidos neste trabalho utilizam consultas em SPARQL com estruturas pré-definidas, sendo assim um tanto restritivos. Eles podem ser reutilizados sem grandes modificações para suportar outros tipos de consultas SPARQL, porém seria difícil obter um modelo completamente genérica, já que no final as operações dos artefatos são implementadas em código Java estático. Por outro lado, utilizar artefatos Cartago possibilita interoperabilidade: Qualquer agente BDI pode acessar os artefatos desenvolvidos neste trabalho, mesmo que utilizem linguagens diferentes. Como cada agente utiliza um artefato próprio, as consultas semânticas podem ser processadas em paralelo. Algumas características do modelo de A\&A não foram utilizadas neste trabalho, como a capacidade dos agentes de configurar as propriedades de um artefato para alterar sua funcionalidade em tempo de execução, ou criar e remover artefatos em tempo de execução para alterar as funcionalidades do ambiente.

O principal problema encontrado utilizando o modelo A\&A foi que ele suporta um agente usar vários artefatos ao mesmo tempo, mas um artefato não pode ser utilizado por mais de um agente por vez. O modelo A\&A foi desenvolvido desta forma para evitar conflitos em que mais de um agente pudesse alterar o estado interno do artefato ao mesmo tempo. Contudo, neste trabalho era necessário que vários agentes pudessem executar uma operação para consultar a DBPedia ao mesmo tempo para permitir que o processamento fosse feito em paralelo. Para resolver isso, no nosso modelo foram instanciados um artefato de busca semântica para cada agente. Os artefatos foram identificados com o nome dos agentes que iriam utilizá-los, assim os agentes poderiam saber que artefato devem usar. Essa abordagem foi efetiva para este trabalho, mas não é muito elegante e pode escalar rapidamente em uma situação com um número maior de agentes ou artefatos de busca semântica.

Devido a limitação de tempo algumas funcionalidades pensadas no início do projeto não puderam ser implementadas. Inicialmente planejou-se utilizar o próprio OA para gerar sugestões, em conjunto com o que foi implementado neste trabalho. A princípio isso seria feito apenas para OA's em pdf, o arquivo seria processado utilizando NLP, algumas sugestões que poderiam ser obtidas desta forma são: 1.3. Language (o idioma usado pelo OA), 2.1. Version (a versão do arquivo, poderia ser obtida, por exemplo, procurando pela palavras 'versão' ou 'version') e 2.3.2. Entity (o nome das pessoas que criaram o OA). Também poderiam ser obtidas sugestões para 1.2. Title e 1.5. Keywords, através da análise do texto do OA. Outra funcionalidade seria a de obter sugestões através de comparações entre OAs semelhantes em um mesmo 3Store, através de similaridade entre ontologias. Outro trabalho futuro relevante é comparar a ferramenta de recomendação com outros sistemas similares voltados ao ensino a distância, para avaliar a qualidade das recomendações e o tempo de processamento.

Outros trabalhos futuros possíveis são: agentes configurarem os artefatos para modificar a estrutura das consultas em SPARQL em tempo real, agentes monitorarem os campos da GUI em tempo real; utilizar dados pessoais do usuário como contexto na inferência semântica; implementar outros perfis de metadados do OBAA; implementar suporte para os padrões de metadados Scorm e LOM; a ferramenta ser Web; permitir a customização dos filtros utilizados; e permitir salvar e carregar metadados preenchidos em formato XML.

\chapter{Agradecimentos}
Gostaria de agradecer a orientação do professor Elder Rizzon Santos, que forneceu opiniões e revisões valiosas ao longo do trabalho. Também agradeço o apoio da minha família e do meu marido, presente em todos os momentos deste trabalho.

%\chapter{Direitos Autorais}
%Os autores são os únicos responsáveis pelo conteúdo do material impresso incluído no seu trabalho.

\bibliographystyle{ufscThesis/ufsc-alf}
\bibliography{biblio}

%--------------------------------------------------------
% Elementos pós-textuais

\apendice
\chapter{Background de Sistemas Multi-Agentes} \label{apendices:background}
\section{Teorias de Agentes}
Para \cite{ref23} teorias de agentes são essencialmente especificações, que buscam definir aspectos tais como o que um agente é, que propriedades ele deveria ter, e como pode-se representar e raciocinar sobre estas propriedades.

A abordagem tradicional para se construir agentes é a teoria baseada em lógica, segundo \cite{ref18} ela sugere que um comportamento inteligente pode ser gerado em um sistema se este sistema possuir uma representação simbólica do seu ambiente e do seu comportamento desejado, além de ser capaz de manipular sintaticamente esta representação. A representação simbólica é feita através de um banco de dados de fórmulas lógicas, e a manipulação é realizada através de deduções lógicas ou prova de teoremas. Os agentes que eram implementados de acordo com essa teoria eram chamados de agentes deliberativos e o seu comportamento era determinado pelo seu banco de dados atual e pelas suas regras de dedução.

Um exemplo citado por \cite{ref18} de um agente deliberativo é o ``Mundo do Vácuo" (Vacuum World). Como mostrado na Figura \ref{fig:d1}, nele um agente aspirador habita um mundo de quadrados 3 por 3, e o seu objetivo é manter este mundo limpo. Alguns predicados que ele possui para armazenar informações do ambiente são: localizacao(x,y), que armazena sua localização no mundo; sujeira(x,y),  que indica que a posição (x,y) está suja; e direcao(d), que guarda a direção para a qual o agente está virado. Ações que o agente poderia possuir para cumprir seu objetivo são: limpar, para sugar a sujeira de uma célula suja; andar, para mover-se para frente; e virar, para alterar a direção do movimento. Uma regra de dedução seria ``localizacao(x,y) AND sujeira(x,y) -> executar(limpar)", para o agente limpar uma célula caso ele esteja localizado nela e esta célula esteja suja.

Segundo \cite{ref18} esta teoria possui as qualidades de ser elegante e possuir uma semântica lógica, porém possui várias desvantagens. A primeira é o fato de ser difícil para um ser humano criar e compreender o significado de um grande conjunto de predicados lógicos e regras de dedução, ou conseguir fazer o mapeamento de um ambiente para este conjunto de predicados. O segundo é um problema de performance, porque há um problema de complexidade computacional inerente para se realizar prova de teoremas, isso faz com que o uso de agente deliberativos em sistemas com restrições de tempo seja questionável. Outra desvantagem relevante é que a tomada de decisão destes agente é baseada no princípio da racionalidade calculável, ou seja, é assumido que o ambiente não mudará de forma significante enquanto o agente decide que ação tomar, o que é bastante improvável de ocorrer em sistemas dinâmicos e complexos.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.6]{figuras/figura2.png}
\caption{Agente deliberativo Aspirador no Mundo do Vácuo \cite{ref18}}
\label{fig:d1}
\end{center}
\end{figure}

Atualmente a teoria mais utilizada para se modelar agentes é a BDI (Belief-Desire-Intention, Crença-Desejo-Intenção)\abreviatura{BDI}{Belief-Desire-Intention} \cite{ref20}. Esta teoria é baseada em estudos sobre o raciocínio prático, que envolve dois processos principais: decidir que metas queremos atingir (deliberação) e como as atingiremos (meios-fins). Noções mentais humanas e uma perspectiva social são utilizadas na modelagem dos agentes.

O processo de raciocínio prático de um agente em uma arquitetura BDI está resumido na Figura \ref{fig:d2}, que ilustra os sete componentes principais de um agente BDI. Destes, os conceitos básicos são:
\begin{itemize}
\item Crenças: Um conjunto de crenças que representa a informação que o agente possui sobre si, sobre o ambiente e sobre outros agentes. Função de Revisão de Crenças (FRC) recebe como entrada uma percepção e as crenças atuais do agente, e baseando-se nisso atualiza as crenças do agente.
\item Desejos: São os estados do mundo desejados pelo agente, podem ser contraditórios. Os desejos são gerados pela Função de Geração de Opções, que utiliza as crenças para verificar a viabilidade dos desejos e utiliza as intenções atuais do agente de forma que o desejo não entre em conflito com elas. O subconjunto de desejos consistentes é chamado de objetivos.
\item Intenções: São sequências de ações que o agente se compromete a executar para atingir seus objetivos. As intenções são geradas pelo processo de deliberação, levando-se em conta as crenças, intenções e desejos atuais. Um agente pode possuir várias intenções simultaneamente, a escolha sobre qual dessas intenções será executada é feita pelo componente Ação.
\end{itemize}
Outros conceitos comuns que não aparecem na Figura \ref{fig:d2}, mas que são usados por algumas arquiteturas BDI:
\begin{itemize}
\item Eventos: Alterações nas crenças ou objetivos dos agentes.
\item Capacidades: Atividades que um agente pode realizar.
\item Planos: Raciocínio sobre os cursos de ações necessários para se atingir um objetivo.
\item Regras: Raciocínio sobre as crenças, de forma a inferir conhecimento a partir delas.
\end{itemize}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.9]{figuras/figura3.png}
\caption{Diagrama do processo de raciocínio em uma arquitetura BDI genérica. \cite{ref24}}
\label{fig:d2}
\end{center}
\end{figure}

\cite{ref18} considera que um dos maiores problemas nas arquiteturas BDI é alcançar um equilíbrio na frequência com que um agente deve repensar suas intenções. Em ambientes altamente dinâmicos e imprevisíveis cumprir um objetivo pode se tornar impossível, ou não ser mais necessário. Porém o agente também deve manter compromisso por tempo o suficiente com seus objetivos para que ele possa cumpri-los. O autor também cita que outra dificuldade é implementar os processos de deliberação e meios-fim de forma eficiente.

Segundo \cite{ref18} as duas principais qualidades das arquiteturas BDI são que a forma de raciocínio que ela descreve é bastante intuitiva, e que o sistema possui uma decomposição clara.
\\*\\*\\*\\*\\*

\section{Arquiteturas de Agentes}
Para \cite{ref23} um arquitetura de agentes é um modelo de engenharia de software para agentes, que se preocupa principalmente em satisfazer as propriedades especificadas pelas teorias de agentes. Abaixo seguem-se as arquiteturas de agentes reativos, a arquitetura em camadas e algumas arquiteturas baseadas na teoria de agentes BDI.
\\*

As arquiteturas reativas surgiram, na década de 1980, como uma alternativa aos problemas aparentemente intratáveis da abordagem lógica, descritos na seção anterior. \cite{ref18} comenta que a principal semelhança entre estas arquiteturas era a rejeição da IA simbólica, além de considerarem que o comportamento racional de um agente emerge da interação de vários comportamentos mais simples e do ambiente em que o agente está situado. Estas arquiteturas foram chamadas de reativas porque a tomada de decisão é implementa com um mapeamento direto de uma situação para uma ação, sem que haja um raciocínio sobre o ambiente.

Segundo \cite{ref18} a arquitetura reativa mais conhecida é a arquitetura de subsunção (subsumption architecture), desenvolvida por Rodney Brooks \cite{brooks}. Nesta arquitetura o processo de tomada de decisão é realizado através de um conjunto de comportamentos, no qual cada comportamento pode ser considerado como uma função que continuamente mapeia as percepções de entrada em uma ação a ser executada. Outra característica importante da arquitetura de subsunção é que vários comportamentos podem ser ativados ao mesmo tempo. Para ser possível escolher entre eles, os comportamentos são organizados em camadas. As camadas mais baixas tem maior prioridade para executar e representam comportamentos menos abstratos, como desviar de um obstáculo, enquanto as camadas mais altas possuem menor prioridade e comportamentos mais abstratos, como a comunicação.

Em \cite{ref18} é citado um exemplo no qual um conjunto de veículos autônomos deve explorar um terreno desconhecido em busca de um tipo específico de rocha a ser recolhida, além disso, os veículos não são capazes de se comunicar entre si. Nesta situação, o comportamento de mais baixo nível era desviar de obstáculos, por ser algo que deve ser executado de imediato, evitando que o veículo quebre. Os comportamentos de nível intermediário eram relacionados a buscar e trazer as rochas, e o comportamento de mais alto nível era andar aleatoriamente pelo mapa em busca de rochas, efetuado quando não houvesse nenhum obstáculo ou rocha por perto.

\cite{ref23} também aborda outra arquitetura reativa, o autômato situado (situated automata), desenvolvido por Rosenchein e Kaelbling. Nesta arquitetura um agente é especificado de forma declarativa, com lógica modal, e então essa especificação é compilada em uma máquina que a satisfaça. Esta máquina é capaz de rodar dentro de restrições de tempo, pois não utiliza nenhuma manipulação simbólica. Para esta técnica funcionar é necessário que o mapeamento do mundo para Semântica dos Mundos Possíveis (Possible Worlds Semantics) possa ter uma interpretação concreta em um autômato de estados.

Algumas vantagens da abordagem reativa descritas por \cite{ref18} são: simplicidade, economia, tratabilidade computacional, robusteza e elegância. Porém também são citados alguns problemas destas arquiteturas: os agentes se baseiam em informação local, sendo difícil tomarem decisões levando em consideração informações não-locais; não é possível fazer um agente puramente reativo aprender com a experiência; é muito difícil modelar e entender agentes complexos com esta arquitetura, principalmente porque é difícil compreender as interações entre as camadas.
\\*

As arquiteturas em camadas surgiram como uma solução possível para o requisito de que um agente deve ser capaz de agir tanto de forma reativa como pró-ativa. Para resolver este problema estas arquiteturas decompõe o sistema em subsistemas separados que lidam com diferentes tipos de comportamento com diferentes níveis de abstração, esses subsistemas são organizados em uma hierarquia de camadas que interagem entre si. O fluxo de controle entre estas camadas por ser horizontal ou vertical, sendo que o fluxo vertical pode passar por uma via de sentido único ou de sentido duplo (Figura \ref{fig:d4}). No fluxo horizontal as camadas competem para gerar ações, o que pode levar a inconsistências, além de haver um grande número de interações possíveis entre as camadas. Estes problemas são aliviados nas organizações com fluxo de controle vertical, porém desta forma a tomada de decisão perde flexibilidade, pois o fluxo deve passar por cada uma das camadas.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.7]{figuras/figura4.png}
\caption{Os três tipos de fluxo de controle e de informação que uma arquitetura em camadas pode ter \cite{ref18}.}
\label{fig:d4}
\end{center}
\end{figure}

\cite{ref18} cita duas arquiteturas em camadas como exemplo: TouringMachines, com organização horizontal, e INTERRAP, com organização vertical de duas passagens. A arquitetura TouringMachines consiste de três camadas produtoras de atividades (camada reativa, camada de planejamento, camada de modelagem) que utilizam diferentes níveis de abstração para gerar continuamente sugestões sobre qual ação o agente deve tomar, e um sistema de controle, que decide qual camada decidirá as ações do agente. A arquitetura INTERRAP também possui três camadas de controle (camada reativa, camada de planejamento, camada de planejamento cooperativo), cada camada possui uma base de conhecimento associada à ela, que representa o mundo em diferentes níveis de abstração de acordo com a camada. A utilização de bases de conhecimento é a principal diferença entre essas duas arquiteturas. É relevante notar que a arquitetura de subsunção também é considerada uma arquitetura em camadas\cite{brooks}.

De acordo com \cite{ref18}, as arquiteturas em camadas possuem a vantagem de terem um conceito de fácil compreensão, porém são difíceis de se modelar e compreender para sistemas complexos, por causa das várias interações possíveis entre as camadas.
\\*

Abaixo serão descritas as seguintes arquiteturas, baseadas na teoria BDI descrita na seção anterior: PRS (Georgeff, Lansky), dMARS (Kinny) e IRMA (Bratman, Isreal, Pollack).

PRS (Procedural Reasoning System) \cite{ref23} \abreviatura{PRS}{Procedural Reasoning System}: É um dos modelos de arquitetura de agentes mais conhecidos. A arquitetura inclui uma biblioteca de planos e uma representação simbólica de crenças, desejos e intenções. Crenças são fatos, tanto sobre o ambiente como sobre o próprio agente, e são expressas em lógica de primeira ordem. Desejos são representados como comportamentos do sistema (ao invés de uma representação estática dos estados dos objetivos). A biblioteca de planos contém um conjunto de planos parcialmente elaborados, chamados de áreas de conhecimento, que são associados à condições de invocação que determinam quando um plano será ativado. Áreas de conhecimento podem ser ativadas tanto de uma forma reativa como direcionada a objetivos. O conjunto de áreas de conhecimento ativadas no sistema representam as intenções do agente. Existe um interpretador, que é o responsável por atualizar crenças, invocar áreas de conhecimento e executar ações.

dMARS (Distributed Multi-Agent Reasoning System) \cite{ref27}\abreviatura{dMARS}{Distributed Multi-Agent Reasoning System}: Este modelo é baseado na arquitetura PRS, sendo que um dos objetivos desta arquitetura é ter um tempo de resposta a mudanças confiável, além de prover suporte para operações distribuídas. As capacidades dos agentes dMARS são modeladas como um conjunto de planos sensíveis ao contexto, que podem tanto ser utilizados de forma reativa como pró-ativa. \cite{ref27} cita algumas aplicações que utilizaram a arquitetura dMARS com sucesso: um sistema de diagnóstico de falhas para um ônibus espacial da Nasa, um sistema de simulação de defesa aérea tática para a Força Aérea da Austrália e um sistema de controle de tráfico aéreo civil para os Serviços Aéreos da Austrália.

\cite{ref25} resume o ciclo de funcionamento de agentes das arquiteturas PRS e dMARS com o seguinte comportamento:
\begin{enumerate}
\item Observam o mundo e o estado interno do agente;
\item Atualizam a fila de eventos para refletir os eventos que foram observados;
\item Geram novos desejos possíveis encontrando planos cujo evento de ativação esteja na fila de eventos;
\item Destes planos possíveis, um é selecionado para ser executado e é adicionado à pilha de uma intenção nova ou de uma já existente;
\item Por fim, uma intenção é selecionada e o plano mais alto da pilha desta intenção é executado.
\end{enumerate}

IRMA (Intelligent Resource-bounded Machine Architecture) \cite{ref23} \abreviatura{IRMA}{Intelligent Resource-bounded Machine Architecture}: Esta arquitetura tem quatro estruturas de dados chave: uma biblioteca de planos e uma representação explícita de crenças, desejos e intenções. A arquitetura também possui um motor de inferência (reasoner), para raciocinar sobre o mundo; um analisador meios-fins, para determinar que planos podem ser usados para concluir uma intenção; um analisador de oportunidades, que monitora o ambiente para determinar novas opções para o agente; um processo iterador, que determina o subconjunto das possíveis sequências de ações do agente que são consistentes com as intenções atuais; e um processo deliberador, que realiza a escolha entre opções concorrentes. A arquitetura IRMA foi avaliada com um cenário experimental conhecido como Mundo dos Azulejos (Tileworld).

\section{Linguagens de Agentes}
Para \cite{ref23} uma linguagem de agente é um sistema que permite programar e executar agentes, e que podem utilizar princípios estabelecidos pelas teorias de agentes. A seguir descrevem-se algumas linguagens de agentes, elas estão categorizadas em linguagens baseadas em lógica e linguagens baseadas em BDI.
\\*

Algumas linguagens baseadas na teoria lógica de agentes são descritas por \cite{ref25}: AGENT-0, MetateM, Golog e IMPACT \cite{ref26}.

AGENT-0: É um framework que consiste de um sistema lógico para definir o estado mental dos agentes, junto com uma linguagem interpretada para programar estes agentes. AGENT-0 utiliza lógica multi-modal quantificada, com três modalidades: crença, compromisso e habilidade. A linguagem também provê suporte para noções de tempo. Embora ela não tenha sido amplamente utilizada, a idéia de uma linguagem para agentes baseados em lógica multi-modal serviu de inspiração para o desenvolvimento de muitas outras linguagens de programação para agentes.

MetateM: Esta linguagem utiliza lógica temporal para especificar o comportamento dos agentes, como o que um agente deve fazer agora, o que ele deve fazer a seguir e o que ele garante que irá fazer em algum ponto no futuro. Paralelamente, a linguagem foi desenvolvida em uma versão concorrente para SMAs, chamada Concurrent MetateM.

Golog: É uma linguagem de especificação de alto nível descendente do Prolog e é baseada em cálculo situacional (situation calculus), ela o extende com estruturas de controle e procedimentos. A execução de um programa Golog envolve provar o teorema expresso pelo programa em relação a alguma teoria base. Uma das linguagens sucessoras da Golog foi a ConGolog, que incorpora concorrência, interrupções e ações externas à linguagem original.

IMPACT: Agentes Impact consistem de um código de software com um empacotador associado que ``agentiza" o código. Um conjunto de servidores especializados facilita a interoperabilidade entre os agentes de uma maneira independente de aplicação.
\\*

A seguir serão descritas brevemente algumas linguagens para a programação de agentes baseadas na teoria e arquitetura BDI: AgentSpeak, Jason, 2APL, GOAL e JACK.

AgentSpeak \cite{ref25}: AgentSpeak(L) é uma linguagem de alto-nível baseada nos princípios da teoria BDI, e definida para ser uma extensão da programação lógica que incorpore crenças, eventos, objetivos, ações, planos e intenções. O seu ciclo de raciocínio é bastante similar ao ciclo da arquitetura dMARS. Arquiteturas de Agentes. O comportamento dos agentes é dirigido pelos planos escritos em AgentSpeak. Embora as crenças, desejos e intenções do agente não sejam representadas explicitamente como lógica modal, elas podem ser formalmente atribuídas ou checadas dada uma representação do estado atual do agente.

Jason \cite{ref35}: Jason é um interpretador de uma versão melhorada da linguagem AgentSpeak(L), que inclui comunicação baseada na teoria de atos de fala. Um SMA nesta linguagem pode ser distribuído em uma rede utilizando os frameworks Cartago, JADE ou Saci. O  Jason é implementado em Java, sendo multi-plataforma, e é código-aberto. 

2APL \cite{ref31}: 2APL é uma linguagem de programação de agentes cujo objetivo é facilitar a implementação de SMAs. No nível multi-agente, ela provê estruturas de programação para especificar um SMA em termos de um conjunto de agentes individuais e um conjunto de ambientes sobre os quais os agentes podem atuar. No nível de agentes individuais, a linguagem provê estruturas de programação para implementar crenças, objetivos, planos, ações, eventos e um conjunto de regras que o agente utiliza para decidir que ações irá executar.  As ações podem ser atualização de crenças, ações externas ou ações de comunicação. Outras características da linguagem 2APL são: é uma linguagem de programação modular que permite encapsular os componentes cognitivos em módulos; suporta a implementação tanto de agentes reativos como pró-ativos; e permite que os SMAs sejam distribuídos, através do uso da plataforma Jade.

GOAL \cite{ref33}: Um agente GOAL é um conjunto de módulos que consiste de vários componentes incluindo: conhecimento, crenças, objetivos, regras de ações e especificações de ações. A maioria das seções é opcional. Cada uma destas seções é representada em uma linguagem de representação de conhecimento, como o Prolog ou a SQL. As principais características desta linguagem são: crenças e objetivos declarativos; estratégia de compromisso cega como padrão; seleção de ações baseada em regras; módulos de intenção baseados em políticas; e comunicação em nível de conhecimento.

JACK \cite{ref25, ref34}: JACK é uma plataforma para a construção e execução de SMAs em nível comercial usando uma abordagem baseada em componentes. Esta linguagem de programação de agentes extende o Java com conceitos orientados a agentes, como agentes, capacidades, eventos, planos, bases de conhecimento e administração de recursos e concorrência. JACK se baseia na arquitetura dMARS.

\subsection{2APL}
Esta subseção mostra um código simplificado de um agente e um ambiente 2APL, e faz comparações entre os ambientes programados em Jason e em 2APL.

Os dois exemplos, retirados de \cite{ref16}, se referem a um Mundo de Blocos. O ambiente contém 2 agentes e diversas bombas espalhadas por ele. O objetivo dos agentes é remover as bombas do ambiente, sendo que um agente é responsável por procurar e trazer as bombas para um segundo agente, que está localizado na posição (0,0) do mundo, e apenas elimina as bombas que forem trazidas.

Uma versão reduzida do código do primeiro agente é mostrada abaixo. A seção BeliefUpdates possui um conjunto de regras na estrutura contexto-ação-atualização, que atualiza as crenças do agente dependendo das ações que ele executar. Neste exemplo, em ``{carregando(bomba) }Soltar( ) {not carregando(bomba) }", se o agente acreditar que está carregando uma bomba e realizar a ação ``Soltar", ele passará a acreditar que não está mais carregando a bomba. A seção Belief armazena as crenças e as regras de dedução de conhecimento do agente, como as crenças da posição inicial do agente (inicio(0,1)), da posição das bombas (bomba(3,3)) e a regra limpar(mundoDeBlocos), que indica que se o agente não conhece nenhuma posição em que há uma bomba e não está carregando uma bomba, então o mundo está limpo. Os planos ficam na seção Plans, e neste exemplo há um plano que faz com que o agente realize a ação ``entrar" no ambiente. A seção Goals possui os objetivos do agente, e neste caso o objetivo é cumprir a regra limpar( mundoDeBlocos ).

As duas últimas seções relevantes do exemplo são PG-rules, regras de planejamento de objetivo, e PC-rules, regras de chamada de procedimento. A PG-rule limpar( mundoDeBlocos ) indica que, caso o agente saiba que existe uma bomba em algum (X,Y), ele deve ir até esse (X,Y), pegar a bomba, ir até (0,0) e soltar a bomba, para que o segundo agente possa pegá-la e descartá-la. Em PC-rule, a regra goto(X, Y) implementa os procedimentos que devem ser feitos para o agente ir para (X,Y), neste caso o agente percebe qual é sua posição atual (A,B) e tempo fazer ela se aproximar da posição (X,Y) chamando-se recursivamente.

\begin{lstlisting}[frame=tb]
BeliefUpdates:
{carregando(bomba) }        Soltar( )                          {not carregando(bomba) }
{true}                                 AddBomba(X,Y)            {bomba(X,Y) }
 ...

Beliefs: 
inicio(0,1). 
bomba(3,3). 
limpar( mundoDeBlocos ) :- not bomba(X,Y) , not carregando(bomba). 

Plans: 
B(inicio(X,Y)) ; 
@mundodeblocos( entrar( X, Y, blue ), L ) 

Goals: 
limpar( mundoDeBlocos ) 

PG-rules: 
limpar( mundoDeBlocos )  <- bomba( X, Y ) | 
{ 
    goto( X, Y ); 
    @mundodeblocos( pegar( ), L1 ); 
    Pegar( ); 
    RemoverBomba( X, Y ); 
    goto( 0, 0 ); 
    @mundodeblocos( soltar( ), L2 ); 
    Soltar( ) 
} 
... 

PC-rules: 
goto( X, Y ) <- true | 
{ 
    @mundodeblocos( sentirPosicao(), POS ); 
    B(POS = [A,B]); 
    if B(A > X) then 
    { @mundodeblocos( oeste(), L ); 
        goto( X, Y ) 
    } 
    ...
}

...
\end{lstlisting}

O ambiente em 2APL também é implementado como uma classe Java mas, ao contrário do ambiente em Jason que centraliza a execução de ações em um único método, em 2APL cada ação do agente é mapeada em um método da classe Java, e são esses métodos que geram as percepções dos agentes. No exemplo de código abaixo as ações entrar, sentirPosicao, pegar, norte, entre outras podem ser realizadas sobre o ambiente mundodeblocos.

\begin{lstlisting}
package mundodeblocos; 

public class Env extends apapl.Environment { 

    public void entrar(String agente, Term x, Term y, Term c){...} 
    public Term sentirPosicao(String agente){...} 
    public Term pegar(String agente){...} 
    public void norte(String agente){...} 
    ... 
} 
\end{lstlisting}

\section{Frameworks de SMA: JIAC e Jade}
\label{apendices:jadejiac}

JIAC (Java-based Intelligent Agent Componentware) \cite{ref37}\abreviatura{JIAC}{Java-based Intelligent Agent Componentware} é uma arquitetura e framework de agentes baseada em Java, possui uma estrutura modular e foi desenvolvida em 2002. O framework suporta a modelagem, implementação e implantação de sistemas multi-agentes. JIAC é focado em distribuição, escalabilidade, adaptabilidade, autonomia e segurança, e também permite o reuso de aplicações e serviços através de bibliotecas. Os agentes JIAC são baseados na arquitetura BDI, e sua arquitetura provê suporte para comunicação, administração de processos, planos declarativos e definições de ontologias. SMAs utilizando JIAC venceram os anos de 2007, 2008, 2009, 2010 e obtiveram o terceiro lugar em 2011 do Multi-Agent Programming Contest \footnote{http://multiagentcontest.org}.

A arquitetura e framework JADE (Java Agent DEvelopment Framework) \cite{ref28} \abreviatura{JADE}{Java Agent DEvelopment Framework}é um software implementado na linguagem Java que permite a implementação de sistemas multi-agentes através de um middleware que cumpre as especificações FIPA e através de um conjunto de ferramentas que auxiliam a depuração e a implantação do sistema. JADE permite que a plataforma de agentes possa ser distribuída em diferentes máquinas. Sua arquitetura de comunicação cria e administra filas de mensagens ACL (Agent Communication Language) \abreviatura{ACL}{Agent Communication Language} recebidas, privadas para cada agente, que podem acessá-las de diferentes formas como por um tempo limite, por votação ou por um casamento de padrão. JADE é uma das plataformas de agentes mais utilizadas na comunidade de pesquisa. Jadex é uma extensão do framework básico do JADE utilizando uma arquitetura baseada na BDI.

\chapter{Informações adicionais sobre Agentes \& Artefatos}
\section{Frameworks de A\&A: simpA}
\label{apendices:simpa}
A descrição que se segue é baseada em \cite{ref8}, o artigo também possui um exemplo de programação utilizando simpA para fazer o Jantar dos Filósofos.

simpA é uma extensão baseada em bibliotecas do Java que suporta as abstrações do modelo de A\&A como entidades de primeira-classe, tratando-as como blocos básicos para programar aplicações concorrentes complexas. O framework provê uma camada de abstração orientada a agentes sobre a camada básica de orientação a objetos, utilizando as anotações do Java sobre classes e métodos para definir os novos componentes de programação necessários. simpA é código-aberto e está disponível para download neste website: http://www.alice.unibo.it/simpa

Abaixo segue um exemplo de código de um agente em simpA, adaptado de \cite{ref8}. Este agente realiza uma sequência de atividades, na qual a atividade B depende da atividade A ter sido completada. Em simpA um agente é descrito por uma classe, que deriva da classe Agent, e são usadas anotações Java para definir características de agentes nesta classe, como @ACTIVITY para métodos que representem ações e @ACTIVITY\_WITH\_AGENDA para definir uma sequência de ações. A atividade A cria uma nova crença ``x" de valor 1, com o método memo(nome, valor).  A atividade B utiliza o método getMemo(nome) para obter a crença armazenada por A e imprimi-la na tela. A implementação de artefatos em simpA é muito semelhante a sua implementação no Cartago, e será descrita na seção seguinte.
\\*\\*
\begin{lstlisting}[frame=tb]
public class MeuAgente extends Agent { 

@ACTIVITY_WITH_AGENDA({ 
    @TODO(``atividadeA"), 
    @TODO(``atividadeB", pre=``completed(atividadeA)"), 
}) void main(){} 

@ACTIVITY void atividadeA(){ 
    memo(``x",1); // insere uma nova crença x(1) 
} 

@ACTIVITY void atividadeB(){ 
    int v = getMemo(``x").intValue(0); // lê o primeiro argumento da crença x
    log(``Resultado: "+v); 
} 
}
\end{lstlisting}

\section{Exemplos de implementação com Cartago}
\label{apendices:implcartago}
Serão descritos exemplos implementando um SMA com um artefato Contador, um com um artefato Relógio, um implementando um artefato Sincronizador e um exemplo mais complexo, o Jantar dos Filósofos. Os primeiros exemplos foram retirados e adaptados de \cite{ref6}, e o último exemplo foi retirado de \cite{ref5}, em ambos os artigos se encontram outros exemplos como um artefato sendo um buffer limitado, um artefato GUI, um artefato WebService, um artefato tabuleiro de jogo da velha, entre outros. Todos estes exemplos, inclusive os descritos abaixo, utilizam o Jason como plataforma de agentes. Outros exemplos encontram-se no site da plataforma Cartago: http://cartago.sourcefore.net/ 

Os exemplos serão descritos através da implementação do código Java dos artefatos, os trechos em negrito são da API do Cartago, e de uma imagem da implementação abstrata deste artefato, na qual aparecem as propriedades observáveis do artefato na parte de cima da imagem, e dentro da caixa são listadas as operações que o artefato fornece. Também serão mostrados os códigos dos agentes Jason e a saída da execução do SMA no console.

Como os agentes utilizando os artefatos nos exemplos usam a plataforma Jason, segue uma breve descrição da sintaxe da plataforma, de acordo com \cite{ref5}. Os agentes programados em Jason são definidos por um conjunto de crenças iniciais, um conjunto de objetivos e um conjunto de planos que os agentes podem instanciar e executar dinamicamente para atingir seus objetivos. Os planos dos agentes são descritos por regras do tipo Evento: Contexto <- Corpo, onde Evento representa o evento que ativou o plano, o Contexto é uma fórmula lógica definindo as condições sobre as quais o plano deve ser executado e o Corpo inclui ações, como criar sub-objetivos (!g), atualizar o estado do agente  e executar ações esternas sobre o ambiente. Eventos podem ser adição de crenças (+b), adição de um objetivo (+!g), falha de um plano (-!g) ou remoção de uma crença (-b).

\subsubsection{Artefato Contador}
Este primeiro exemplo serve para demonstrar o básico da criação de um artefato. O artefato Contador possui a propriedade observável ``contagem" de valor 0, definida no método init() com o método defineObsProperty(...), e provê uma operação para incrementá-lo, chamada ``inc", implementada pelo método inc() que obtém a propriedade ``contagem" e a atualiza para contagem+1. Isso é feito através do método getObsProperty(``contagem"), que retorna um objeto ObsProperty prop, representando a propriedade obtida, e se utiliza este objeto para invocar updateValue(...) e assim atualizar o valor da propriedade. A operação ``inc" é composta de uma única etapa atômica. Neste caso, o artefato não possui nenhuma variável de estado, que seria implementada diretamente como um campo de variável do objeto. Um exemplo de uso para este artefato seria registrar a quantidade páginas Web com uma determinada informação encontradas por uma equipe de agentes. Abaixo segue o código da implementação.
\begin{figure}[ht]
\begin{center}
\includegraphics{figuras/figura13.png}
\caption{Representação abstrata do Artefato Contador}
\end{center}
\end{figure}
\begin{lstlisting}[frame=tb]
package Artefatos;

import cartago.*;

public class Contador extends Artifact {

	void init(){
		defineObsProperty(``contagem",0);
	}
	    
	@OPERATION void inc(){
		ObsProperty prop = getObsProperty(``contagem");
		prop.updateValue(prop.intValue()+1);
	}
}
\end{lstlisting}

Abaixo segue o código de um agente Jason simples que utiliza o artefato Contador. O agente no plano inicial +!teste\_contador primeiro cria um artefato com a ação interna makeArtifact, provida pelo Cartago. Esta chamada recebe como parâmetros o nome da instância do artefato (meuContador), a classe do artefato (Artefatos.Contador), uma lista de parâmetros para o método init do artefato ([]) e uma variável que receberá um identificador para este artefato (Id). Após a criação do artefato, o agente o foca através da ação focus(Id), assim as propriedades observáveis do artefato serão mapeadas como crenças no agente. Então o agente chama a operação ``inc" do artefato ``meuContador", mapeada como uma ação interna, três vezes. Antes e após estas chamadas é usado o artefato padrão Console para chamar a operação ``println", escrevendo informações adicionais na tela.

Cada vez que o agente chama a operação ``inc", o valor da propriedade observável ``contagem" é atualizado, gerando a adição da crença +contagem(V), com V sendo o novo valor de ``contagem". O plano para a adição desta crença apenas imprime na tela a frase ``Valor do contador: " com o valor recebido em V.
\begin{lstlisting}[frame=tb]
!testar_contador.

+!testar_contador
  <- makeArtifact(``meuContador",``Artefatos.Contador",[],Id);
     focus(Id);
     println(``Início do teste.");
     inc;
     inc;
     inc;
     println(``Fim do teste.").

+contagem(V):  true
  <- println(``Valor do contador: ",V).
\end{lstlisting}
Abaixo segue a saída da utilização do artefato Contador pelo agente, no console do Jason:
\begin{lstlisting}[frame=tb]
[usuario_contador] Valor do contador: 0
[usuario_contador] Início do teste.
[usuario_contador] Valor do contador: 1
[usuario_contador] Valor do contador: 2
[usuario_contador] Valor do contador: 3
[usuario_contador] Fim do teste.
\end{lstlisting}

Segue também o arquivo exemplo\_contador.mas2j, como exemplo do que o arquivo .mas2j deve ter para utilizar o Cartago. É necessário declarar que o ambiente do SMA é um CartagoEnvironment (ambiente Cartago) e que os agentes utilizam a arquitetura CAgentArch. Também é preciso definir o caminho onde se encontram os pacotes cartago.jar e c4jason.jar. C4Jason quer dizer ``Cartago para Jason" e é o pacote que implementa a ponte entre as duas plataformas.
\begin{lstlisting}[frame=tb]
MAS exemplo_contador {
    environment: c4jason.CartagoEnvironment

    agents:  
    usuario_contador agentArchClass c4jason.CAgentArch;

    classpath: ``.../cartago-2.0.1/lib/cartago.jar";
		``.../cartago-2.0.1/lib/c4jason.jar";    
}
\end{lstlisting}

\subsubsection{Artefato Relógio}
O artefato implementado neste exemplo é um Relógio que lança um tick a cada 0.1 segundos. Este relógio pode ser inicializado e parado pelos agentes. O objetivo do exemplo é demonstrar como uma operação pode ser dividida em etapas e o funcionamento dos sinais.

O artefato Relogio começa sendo inicializado com a propriedade interna ``funcionando" como false e não possui propriedades observáveis. Ele possui as operações ``comecar" e ``parar" disponíveis para os agentes, que respectivamente começam e param a atividade do relógio. Ao ser executada a operação ``comecar" irá testar se o relógio já está funcionando, se sim ele lançará uma mensagem de falha chamando a primitiva ``failed",  caso contrário ``funcionando" será alterada para true, e a segunda etapa da operação, ``contar", será chamada, através da primitiva execInternalOp. ``contar" faz com que o artefato lance um sinal ``tick" a cada 0.1 segundos enquanto ``funcionando" for true, a contagem de tempo é feita com a primitiva await\_time, que suspende a execução dessa etapa da operação até que o tempo definido nela tenha passado. A operação ``parar" simplesmente altera ``funcionando" para false, fazendo com que quando a etapa ``contar" for novamente executada após 0.1 segundos ela saia do loop.
\begin{figure}[ht]
\begin{center}
\includegraphics{figuras/figura14.png}
\caption{Representação abstrata do Artefato Relógio}
\end{center}
\end{figure}
\begin{lstlisting}[frame=tb]
package Artefatos;

import cartago.*;

public class Relogio extends Artifact {

	  boolean funcionando;
	  final static long TEMPO_TICK = 100;

	  void init(){
	    funcionando = false;
	  }

	  @OPERATION void comecar(){
	    if (!funcionando){
	      funcionando = true;
	      execInternalOp(``contar");
	    } else {
	      failed(``já está funcionando");
	    }
	  }

	  @OPERATION void parar(){
	    funcionando = false;
	  }

	  @INTERNAL_OPERATION void contar(){
	      while (funcionando){
	        signal(``tick");
	        await_time(TEMPO_TICK);
	      }
	  }
}
\end{lstlisting}
Abaixo segue o código do agente Jason que utiliza Relogio. Primeiro ele cria uma instância ``meuRelogio" do tipo ``Relogio", então foca essa instância para perceber os sinais que serão gerados, também cria a crença n\_ticks(0) que será atualizada a cada tick do relógio, após isso o agente executa a operação ``comecar" do artefato. Cada vez que o artefato lançar um tick de relógio o sinal será capturado por um dos dois planos +tick. O primeiro plano é executado quando o agente acredita que 10 ticks já foram sinalizados, e então para o relógio. O segundo plano é executado enquanto a quantidade de ticks for menor que 10, e apenas atualiza a crença n\_ticks e informa no console que um tick for percebido.
\begin{lstlisting}[frame=tb]
!testar_relogio.

+!testar_relogio
  <- makeArtifact(``meuRelogio",``Artefatos.Relogio",[],Id);
     focus(Id);
     +n_ticks(0);
     comecar;
     println(``relógio começou.").

+tick: n_ticks(10)  
  <- parar;
     println(``relógio parou.").

+tick: n_ticks(N)  
  <- -+n_ticks(N+1);
     println(``tick percebido!").
\end{lstlisting}

Abaixo segue a saída no MAS Console do Jason:

\begin{lstlisting}[frame=tb]
[usuario_relogio] relógio começou.
[usuario_relogio] tick percebido!
[usuario_relogio] tick percebido!
[usuario_relogio] tick percebido!
[usuario_relogio] tick percebido!
[usuario_relogio] tick percebido!
[usuario_relogio] tick percebido!
[usuario_relogio] tick percebido!
[usuario_relogio] tick percebido!
[usuario_relogio] tick percebido!
[usuario_relogio] tick percebido!
[usuario_relogio] relógio parou.
\end{lstlisting}

\subsubsection{Artefato Sincronizador}
Este exemplo visa mostrar como se pode utilizar guardas para sincronizar agentes. O artefato Sincronizador serve para ser utilizado por uma equipe de agentes que precisam sincronizar antes de proceder com suas ações. Para isso o artefato possui a operação ``sincronizar", que deve ser ativada por cada um dos agentes do grupo que quiserem sincronizar.

Abaixo é mostrado o código no Cartago do artefato Sincronizador. Os atributos ``nProntos" (quantidade de agentes prontos) e ``nParticipantes" (quantidade de agentes participando da sincronização) são propriedades internas do artefato, invisíveis para os agentes. Estas propriedades são inicializadas no método ``init", que recebe a quantidade de participantes como parâmetro. A operação ``sincronizar" primeiro aumenta o contador de agentes prontos, e então espera a guarda ``todosProntos" ser liberada, essa espera é feita através da chamada await com o parâmetro ``todosProntos". Ao chamar await essa instância da operação ``sincronizar" é suspensa, e o plano do agente que chamou esta operação também é suspenso. Quando todos os agentes tiverem ativado a operação ``sincronizar" a guarda será liberada e a operação, e consequentemente o plano do agente, voltam a executar.

\begin{figure}[ht]
\begin{center}
\includegraphics{figuras/figura15.png}
\caption{Representação abstrata do Artefato Sincronizador}
\end{center}
\end{figure}
\begin{lstlisting}[frame=tb]
package Artefatos;

import cartago.*;

public class Sincronizador extends Artifact {

    int nProntos, nParticipantes;

    void init(int nParticipantes) {
        nProntos = 0;
        this.nParticipantes = nParticipantes;
    }

    @OPERATION
    void sincronizar() {
        nProntos++;
        await(``todosProntos");
    }

    @GUARD
    boolean todosProntos() {
        return nProntos == nParticipantes;
    }
}
\end{lstlisting}

Para demonstrar o funcionamento deste artefato foram criados cinco agentes Jason com o código abaixo. O objetivo inicial é !trabalhar, primeiro este plano cria o objetivo setupTools(Id) para preparar o artefato que irá utilizar, dessa forma primeiro o agente tenta chamar makeArtifact para criar o artefato ``sincronizador", caso este plano falhe porque o artefato já existe o agente usa a ação lookupArtifact para procurar o artefato chamado ``sincronizador". Após isso, o agente espera por um tempo entre 0 e 10 segundos, foca no artefato ``sincronizador" e chama a operação ``sincronizar". Quando todos os agentes ativarem a operação ``sincronizar" este plano voltará a executar e imprimirá na tela que a sincronização foi efetuada.

\begin{lstlisting}[frame=tb]
!trabalhar.

+!trabalhar
  <- !setupTools(Id);
  	 println(``Início da sincronização.");
	 .random(N);
	 N2 = N*10000;
	 .wait(N2);
	 println(``Trabalhei por ",N2/1000, `` segundos.");
            focus(Id);
            println(``Ativar operação sincronizar()");
	 sincronizar;
	 println(``Sincronização efetuada!");
	 println(``Fim do teste.").	 

+!setupTools(Id) : true <-
	makeArtifact(``sincronizador",``Artefatos.Sincronizador",[5],Id).
	
-!setupTools(Id) : true <-
	lookupArtifact(``sincronizador",Id).
\end{lstlisting}

Abaixo segue a saída no MAS Console do Jason:
\begin{lstlisting}[frame=tb]
[usuario_sincr4] Início da sincronização.
[usuario_sincr2] Início da sincronização.
[usuario_sincr3] Início da sincronização.
[usuario_sincr1] Início da sincronização.
[usuario_sincr5] Início da sincronização.
[usuario_sincr4] Trabalhei por 1.528724231200107 segundos.
[usuario_sincr4] Ativar operação sincronizar()
[usuario_sincr1] Trabalhei por 5.256301264501251 segundos.
[usuario_sincr1] Ativar operação sincronizar()
[usuario_sincr5] Trabalhei por 6.559502173560134 segundos.
[usuario_sincr5] Ativar operação sincronizar()
[usuario_sincr2] Trabalhei por 6.648731124199021 segundos.
[usuario_sincr2] Ativar operação sincronizar()
[usuario_sincr3] Trabalhei por 7.27029024339723 segundos.
[usuario_sincr3] Ativar operação sincronizar()
[usuario_sincr3] Sincronização efetuada!
[usuario_sincr4] Sincronização efetuada!
[usuario_sincr5] Sincronização efetuada!
[usuario_sincr2] Sincronização efetuada!
[usuario_sincr1] Sincronização efetuada!
[usuario_sincr4] Fim do teste.
[usuario_sincr5] Fim do teste.
[usuario_sincr3] Fim do teste.
[usuario_sincr2] Fim do teste.
[usuario_sincr1] Fim do teste.
\end{lstlisting}

\subsubsection{Jantar dos Filósofos}
Por último, este exemplo soluciona o Problema do Jantar dos Filósofos no Cartago. Este é um problema de programação concorrente proposto por Dijkstra em 1965 e é uma alegoria do que ocorre nos sistemas computacionais multiprocessados que disputam os mesmos recursos limitados e dependem de um algoritmo mestre ou de um sistema operacional para evitar a ocorrência de conflitos entre os processos concorrentes. Nele há cinco filósofos sentados ao redor de uma mesa sobre a qual estão cinco talheres. Diante de cada filósofo há uma refeição e os talheres estão dispostos nos dois lados de cada prato de forma que haja apenas um talher entre cada dois filósofos. Para comer, cada filósofo deve usar dois talheres. Enquanto não comem, os filósofos ficam pensando. Para solucionar este problema é necessário a utilização de um algoritmo que gerencie a janta de forma que nenhum filósofo passe fome.

O artefato utilizado para solucionar este problema é o TupleSpace (espaço de tuplas), este artefato pode ser utilizado sem ser instanciado, pois toda área de trabalho possui uma instância de TupleSpace, chamada ``blackboard", como artefato padrão. O código-fonte deste artefato não será traduzido, para que o exemplo demonstrado possa ser utilizado diretamente programando agentes no Jason+Cartago. As operações ``inp" e ``rdp" tiveram seus trechos de código escondidos, pois não serão utilizadas neste exemplo.

Abaixo segue o código do artefato TupleSpace, ele possui a propriedade interna ``tset" que representa o conjunto de tuplas armazenadas no artefato, esse conjunto é inicializado no método ``init". A operação ``out" apenas adiciona uma nova tupla, com seu nome e parâmetros, no espaço de tuplas. A operação ``in" verifica se a tupla com o dado nome e parâmetros está no espaço de tupla, isso é feito através do uso de um template de tupla com os atributos da tupla procurada, então esse template é usado pela guarda ``foundMatch", que apenas retornará true quando esse template for encontrado no espaço de tuplas, até lá a operação fica suspensa. Após encontrar a tupla ela é removida do espaço de tuplas. A operação ``rd" é semelhante a operação ``in", com a diferença de que ela apenas lê a tupla do espaço de tuplas, sem retirá-la.

\begin{figure}[ht]
\begin{center}
\includegraphics{figuras/figura16.png}
\caption{Representação abstrata do Artefato TupleSpace}
\end{center}
\end{figure}
\begin{lstlisting}[frame=tb]
package cartago.tools; 

import cartago.*; 

public class TupleSpace extends Artifact { 
	 
	TupleSet tset; 
	 
	void init(){ 
		tset = new TupleSet(); 
	} 
	 
	@OPERATION void out(String name, Object... args){ 
		tset.add(new Tuple(name,args)); 
	} 
	 
	@OPERATION void in(String name, Object... params){ 
		TupleTemplate tt = new TupleTemplate(name,params); 
		await(``foundMatch",tt); 
		Tuple t = tset.removeMatching(tt); 
		bind(tt,t); 
	} 

	@OPERATION void inp(String name, Object... params){ 
		(...)
	} 

	@OPERATION void rd(String name, Object... params){ 
		TupleTemplate tt = new TupleTemplate(name,params); 
		await(``foundMatch",tt); 
		Tuple t = tset.readMatching(tt); 
		bind(tt,t); 
	} 

	@OPERATION void rdp(String name, Object... params){ 
		(...)
	} 
	 
	private void bind(TupleTemplate tt, Tuple t){ 
		Object[] tparams = t.getContents(); 
		int index = 0; 
		for (Object p: tt.getContents()){ 
			if (p instanceof OpFeedbackParam<?>){ 
				((OpFeedbackParam) p).set(tparams[index]); 
			} 
			index++; 
		} 
	} 
	 
	@GUARD boolean foundMatch(TupleTemplate tt){ 
		return tset.hasTupleMatching(tt); 
	} 
}
\end{lstlisting}

Há dois tipos de agentes Jason que interagem com o artefato TupleSpace: um garçom e cinco filósofos. O código do agente garçom segue abaixo, ele possui crenças iniciais que definem o número, nome e garfos de cada um dos filósofos. No comando ``for" são adicionados tuplas (garfo, valor), sendo ``valor" de 0 a 4 e tuplas (``filosofo\_init", Nome, Esquerda,  Direita) para cada uma de suas crenças sobre os filósofos. Por fim são adicionadas quatro tuplas (ticket), que os filósofos precisam obter para poder comer e servem para evitar deadlocks.
\begin{lstlisting}[frame=tb]
filosofo(0,``filosofo1",0,1).
filosofo(1,``filosofo2",1,2).
filosofo(2,``filosofo3",2,3).
filosofo(3,``filosofo4",3,4).
filosofo(4,``filosofo5",4,0).

!preparar_mesa.

+!preparar_mesa
  <- for ( .range(I,0,4) ) {
       out(``garfo",I);
       ?filosofo(I,Nome,Esquerda,Direita);
       out(``filosofo_init",Nome,Esquerda,Direita);
     };
     for ( .range(I,1,4) ) {
       out(``ticket");
     };
     println(``pronto.").
\end{lstlisting}

Abaixo segue o código dos agentes filósofos. Primeiro o filósofo descobre seu nome através da ação .my\_name(Eu) e então utiliza essa informação para retirar a tupla com seu nome, juntamente com a informação de quais são seus garfos, então o agente cria duas crenças para armazenar quais são seus garfos da direita e da esquerda e começa o plano +!viver. O plano +!viver consiste de um loop com os sub-objetivos !pensar e !comendo. +!pensar apenas imprime na tela que o filósofo está pensando. +!comendo consiste de três sub-objetivos: !adquirirGarfos,  !comer e !largarGarfos. +!adquirirGarfos tenta obter um ticket e os garfos do filósofo retirando-os do espaço de tupla, caso ele não consiga porque já estão sendo usados, ele ficará esperando até serem liberados. +!comer apenas imprime na tela que o agente está comendo. +!largarGarfos coloca o ticket e os garfos novamente no espaço de tuplas, para que outros filósofos possam comer.
\begin{lstlisting}[frame=tb]
!comecar.

+!comecar
  <- .my_name(Eu);
     in(``filosofo_init",Eu,Esquerda,Direita);
     +meu_garfo_esquerda(Esquerda);
     +meu_garfo_direita(Direita);
     println(Eu,`` pronto.");
     !!viver.
     
+!viver
 <- !pensar;
    !comendo;
    !!viver.

+!comendo 
 <- !adquirirGarfos;
    !comer;
    !largarGarfos.
      
+!adquirirGarfos : 
  meu_garfo_esquerda(F1) \& meu_garfo_direita(F2) 
  <- in(``ticket");
     in(``garfo",F1);
     in(``garfo",F2).
  
+!largarGarfos: 
  meu_garfo_esquerda(F1) \& meu_garfo_direita(F2) 
 <-  out(``garfo",F1);
     out(``garfo",F2);
     out(``ticket").
       
+!pensar 
  <- println(``Pensando").
+!comer 
  <- println(``Comendo").
\end{lstlisting}

Saída da execução do SMA no console do Jason:
\begin{lstlisting}[frame=tb]
[filosofo1] filosofo1 pronto.
[filosofo2] filosofo2 pronto.
[filosofo3] filosofo3 pronto.
[filosofo1] Pensando
[filosofo4] filosofo4 pronto.
[filosofo5] filosofo5 pronto.
[waiter] pronto.
[filosofo2] Pensando
[filosofo5] Pensando
[filosofo5] Comendo
[filosofo2] Comendo
[filosofo5] Pensando
[filosofo2] Pensando
[filosofo3] Pensando
[filosofo1] Comendo
[filosofo4] Pensando
[filosofo1] Pensando
[filosofo1] Comendo
[filosofo3] Comendo
[filosofo3] Pensando
[filosofo5] Comendo
[filosofo2] Comendo
[filosofo1] Pensando
[filosofo2] Pensando
[filosofo4] Comendo
(...)
\end{lstlisting}

\section{Comparação entre ambientes Jason e Cartago}
\label{apendices:compJasonCartago}
Nesta seção é feita uma comparação entre um ambiente Jason e um ambiente Cartago no contexto do ``Robôs de Limpeza" (cleaning robots). Nesse SMA existem dois agentes, r1 e r2, o primeiro tem como objetivo andar por todo o mundo de Marte a procura de lixo, ao encontrar esse lixo r1 leva-o para r2, fixo em uma posição do mapa, que o queima, então r1 volta para o local em que estava antes e continua sua busca.

Primeiro os códigos dos agentes Jason são mostrados e explicados, então são mostrados os ambientes Jason e Cartago para esses mesmos agentes em uma versão adaptada, após isso é mostrada a saída no console do Jason para a execução destes SMAs e por fim, as conclusões desta comparação. Os agentes e ambiente Jason estão no capítulo 2 do manual do Jason, sendo que o ambiente foi foi traduzido e modificado para não ter a interface gráfica e ser mais fácil compreendê-lo e compará-lo com o ambiente Cartago.
\\*

Segue abaixo o código do agente r1. O agente só possui a regra ``em\local(P)", que conclui se r1 está no mesmo local de P. O objetivo inicial do agente é ``checar". O plano deste objetivo é um loop que fica ativo enquanto o agente não encontrar lixo ou enquanto ele não terminar de checar o mundo, esse loop faz com que r1 vá para o próximo slot. O evento de adição de percepção +lixo(r1) indica que foi encontrado lixo, e faz o agente ter o objetivo de carregar o lixo, caso ele ainda não o esteja carregando. O plano para o evento +!carregar\_para(R) faz com que o agente guarde sua posição atual, crie o objetivo de pegar o lixo (e carregá-lo para r2), e após isso volte para a posição que foi armazenada e continue a checar o ambiente. O plano para +!pegar(S,L) cria os objetivos !assegurar\_pegar(S), que garante que o agente conseguirá pegar o lixo, e !ir\_para(L), que faz com que r1 vá para a posição onde está r2, e por fim executa a ação largar, para que r2 possa pegar o lixo.

\begin{lstlisting}[frame=tb]
// Agente r1

/* Initial beliefs and rules */

em_local(P) :- pos(P,X,Y) \& pos(r1,X,Y).

/* Initial goals */

!checar(slots). 

/* Plans */

+!checar(slots) : not lixo(r1) \& not terminou
   <- prox(slot);
      !!checar(slots).
+!checar(slots).

+lixo(r1) : not .desire(carregar_para(r2))
   <- !carregar_para(r2).
   
+!carregar_para(R)   
   <- // lembra para onde tem que voltar
      ?pos(r1,X,Y); 
      -+pos(last,X,Y);
      
      // carrega o lixo para r2
      !pegar(lixo,R);
      
      // volta e continua checando o mundo
      !ir_para(last); 
      !!checar(slots).

+!pegar(S,L) : true
   <- !assegurar_pegar(S); 
      !ir_para(L);
      largar(S).

+!assegurar_pegar(S) : lixo(r1)
   <- pegar(lixo);
      !assegurar_pegar(S).
+!assegurar_pegar(_).

+!ir_para(L) : em_local(L).
+!ir_para(L) <- ?pos(L,X,Y);
           ir_para(X,Y);
           !ir_para(L).
           
+terminou <- .println(``Conclui a busca").
\end{lstlisting}

O código do agente r2 é um único plano de que é ativado quando o agente percebe que há lixo na sua posição, trazido por r1. r2 simplesmente efetua a ação de queimar este lixo.
\begin{lstlisting}[frame=tb]
// Agente r2

/* Plans */
+lixo(r2) : true <- queimar(lixo).
\end{lstlisting}

O código do ambiente Jason é mostrado abaixo. Os ambientes em Jason são organizados com uma classe ambiente principal (MarsEnv) e classes auxiliares para o modelo do ambiente (MarsModel) e a interface gráfica do ambiente (foi omitida neste exemplo). A classe principal possui as declarações globais e os métodos init, executado ao iniciar o sistema, e executeAction,  que realiza os efeitos das ações executadas pelos agentes no ambiente chamando o método correspondente na classe modelo e chama o método auxiliar updatePercepts, que atualiza as percepções fornecidas pelo ambiente de acordo com o seu estado. A classe modelo inicializa a localização das entidades dos ambientes e possui os métodos que correspondem as ações efetuadas pelos agentes, além de atributos que auxiliam estes métodos.

Em relação aos métodos que representam ações na classe modelo: O método ``proxSlot()" altera a posição do agente no mundo para a próxima posição; o método ``irPara(x,y)" altera a posição do agente de forma a aproximá-la da posição (x,y); o método ``pegarLixo()", caso haja lixo na posição do agente, testa se o agente conseguiu pegar o lixo, e se sim altera o atributo auxiliar ``r1TemLixo" para true e remove o lixo desta posição no modelo; o método ``largarLixo()" testa se o agente está carregando lixo, e se sim adiciona lixo na posição do agente e  altera o atributo auxiliar ``r1TemLixo" para false; o método ``queimarLixo()" faz com que o lixo seja removido do mundo, caso haja lixo na posição do agente r2.

\begin{lstlisting}[frame=tb]
import jason.asSyntax.*;
import jason.environment.Environment;
import jason.environment.grid.GridWorldModel;
import jason.environment.grid.Location;

import java.util.Random;
import java.util.logging.Logger;

public class MarsEnv extends Environment {

    public static final int GSize = 7; // tamanho da grade
    public static final int LIXO  = 16; // código do lixo no modelo de grade

    public static final Term    ns = Literal.parseLiteral(``prox(slot)");
    public static final Term    pg = Literal.parseLiteral(``pegar(lixo)");
    public static final Term    dg = Literal.parseLiteral(``largar(lixo)");
    public static final Term    bg = Literal.parseLiteral(``queimar(lixo)");
    public static final Literal g1 = Literal.parseLiteral(``lixo(r1)");
    public static final Literal g2 = Literal.parseLiteral(``lixo(r2)");

    private Logger logger = Logger.getLogger(``marsEnvJason."+MarsEnv.class.getName());

    private MarsModel modelo;
    
    /** Chamado antes da execução do SMA com os args informados no .mas2j */
    @Override
    public void init(String[] args) {
        modelo = new MarsModel();
        updatePercepts();
    }
    
    @Override
    public boolean executeAction(String ag, Structure action) {
        logger.info(ag+`` executando: "+ action);
        try {
            if (action.equals(ns)) {
                modelo.proxSlot();
            } else if (action.getFunctor().equals(``ir_para")) {
                int x = (int)((NumberTerm)action.getTerm(0)).solve();
                int y = (int)((NumberTerm)action.getTerm(1)).solve();
                modelo.irPara(x,y);
            } else if (action.equals(pg)) {
                modelo.pegarLixo();
            } else if (action.equals(dg)) {
                modelo.largarLixo();
            } else if (action.equals(bg)) {
                modelo.queimarLixo();
            } else {
                return false;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        updatePercepts();

        try {
            Thread.sleep(200);
        } catch (Exception e) {}
        return true;
    }
    
    /** cria as percepções dos agentes baseadas no MarsModel */
    void updatePercepts() {
        clearPercepts();
        
        Location r1Loc = modelo.getAgPos(0);
        Location r2Loc = modelo.getAgPos(1);
        
        Literal pos1 = Literal.parseLiteral(``pos(r1," + r1Loc.x + ``," + r1Loc.y + ``)");
        Literal pos2 = Literal.parseLiteral(``pos(r2," + r2Loc.x + ``," + r2Loc.y + ``)");

        addPercept(pos1);
        addPercept(pos2);
        
        if (modelo.hasObject(LIXO, r1Loc)) {
            addPercept(g1);
        }
        if (modelo.hasObject(LIXO, r2Loc)) {
            addPercept(g2);
        }
        
        if(modelo.buscaTerminou == true) {
        	addPercept(Literal.parseLiteral(``terminou"));
        }
    }

    class MarsModel extends GridWorldModel {
        
        public static final int MErr = 2; // max erros ao pegar o lixo
        int nerr; // número de tentativas de pegar o lixo
        boolean r1TemLixo = false; // se r1 está carregando lixo ou não
        boolean buscaTerminou = false;
        
        Random random = new Random(System.currentTimeMillis());

        private MarsModel() {
            super(GSize, GSize, 2);
            
            // localização inicial dos agentes
            try {
                setAgPos(0, 0, 0);
            
                Location r2Loc = new Location(GSize/2, GSize/2);
                setAgPos(1, r2Loc);
            } catch (Exception e) {
                e.printStackTrace();
            }
            
            // localização inicial do lixo
            add(LIXO, 3, 0);
            add(LIXO, GSize-1, 0);
            add(LIXO, 1, 2);
            add(LIXO, 0, GSize-2);
            add(LIXO, GSize-1, GSize-1);
        }
        
        void proxSlot() throws Exception {
            Location r1 = getAgPos(0);
            r1.x++;
            if (r1.x == getWidth()) {
                r1.x = 0;
                r1.y++;
            }
            // termina de procurar na grade
            if (r1.y == getHeight()) {
            	buscaTerminou = true;
                return;
            }
            setAgPos(0, r1);
        }
        
        void irPara(int x, int y) throws Exception {
            Location r1 = getAgPos(0);
            if (r1.x < x)
                r1.x++;
            else if (r1.x > x)
                r1.x--;
            if (r1.y < y)
                r1.y++;
            else if (r1.y > y)
                r1.y--;
            setAgPos(0, r1);
        }
        
        void pegarLixo() {
            // local de r1 tem lixo
            if (modelo.hasObject(LIXO, getAgPos(0))) {
                // as vezes a ação ``pegar" são funciona
                // mas nunca mais que MErr vezes
                if (random.nextBoolean() || nerr == MErr) {
                    remove(LIXO, getAgPos(0));
                    nerr = 0;
                    r1TemLixo = true;
                } else {
                    nerr++;
                }
            }
        }
        void largarLixo() {
            if (r1TemLixo) {
                r1TemLixo = false;
                add(LIXO, getAgPos(0));
            }
        }
        void queimarLixo() {
            // local de r2 tem lixo
            if (modelo.hasObject(LIXO, getAgPos(1))) {
                remove(LIXO, getAgPos(1));
            }
        }
    }
}
\end{lstlisting}

Para utilizar o artefato MarsEnv do ambiente Cartago os agentes r1 e r2 sofreram mais adaptações do que esperado inicialmente. Abaixo as principais adaptações serão explicadas e, após isso, primeiro é mostrado o código do ambiente Cartago e então são mostradas as versões adaptadas dos agentes.

A primeira adaptação decorre do fato que não existe nenhum tipo de controle centralizado padrão sobre as operações dos artefatos, como ocorre no método ``executeAction" do ambiente Jason, que centraliza o controle tanto da execução de ações como da geração de percepções. Em Cartago, cada operação equivale a uma ação, e cada uma é capaz de gerar percepções. Embora um controle de ações e percepções centralizado possa ser forjado, acredito que isso vá contra os princípios do modelo de A\&A. Então nesta primeira adaptação, cada operação para uma ação do artefato MarsEnv foi baseada no método para essa mesma ação no modelo do ambiente Jason. Após isso foi analisado quais e que tipos de percepções (persistentes ou não) cada operação deveria lançar. Para ter um log equivalente ao do ambiente anterior, cada operação chama o método ``printLog" assim que começa a executar.

A segunda adaptação é relacionada às percepções geradas pelo ambiente. No ambiente Jason as percepções são persistentes, pois todas elas são atualizadas após o comando clearPercepts(). O ambiente Cartago pode gerar eventos persistentes através das propriedades observáveis ou eventos não-persistentes emitindo sinais. Porém no Cartago não pode haver duas propriedades observáveis com um mesmo nome, o que gerou limitações para simplesmente se adaptar todos os eventos persistentes do ambiente Jason em propriedades observáveis no ambiente Cartago.

Por exemplo, no primeiro ambiente existem várias percepções na estrutura ``pos(nome,X,Y)", como o agente tem que saber constante qual é sua posição escolheu-se fazê-las com propriedades observáveis no ambiente Cartago, com a estrutura ``pos\_nome(X,Y)" para superar a limitação de não poder ter duas propriedades de mesmo nome, também foram criados atributos ``pos\_nome", por ser uma informação usada com frequência e assim evitar poluição no código. A percepção ``lixo(nome)" no ambiente original tinha tanto a função de informar que na posição do agente tinha lixo, como informar que o agente está carregando lixo. No ambiente Cartago essa percepção foi dividida em duas, para que pudesse haver duas percepções com o mesmo nome e para que o tipo de percepção esteja melhor relacionado a sua função. A primeira função se tornou o sinal ``lixo(nome)", já que o agente só precisa saber uma vez se tem lixo na posição em que ele está; a segunda função se tornou a propriedade observável ``lixo\_com\_r1(boolean)", para que o agente possa sempre saber se está ou não carregando lixo, e agir de acordo. Outra alternativa seria mapear a percepção ``lixo(nome)" para uma propriedade observável ``lixo\_nome(boolean)", o que teria deixado o código do agente adaptado mais similar ao original. Uma última alternativa seria caso houvesse um método removeObsProperty, de forma a permitir de uma maneira mais direta a existência de percepções persistentes por apenas um determinado período.

Uma outra adaptação relevante é que todas as variáveis que indicam nome de algo, como r1 e r2, tiveram que ser trocadas para as strings ``r1" e ``r2", porque essa é a forma de uma operação de um artefato enviar nomes para os agentes.

O método ``init" também teve que ser adaptado. No ambiente original o próprio método de inicialização já era capaz de lançar eventos persistentes e não-persistentes, e esses eventos eram detectados pelos agentes. Porém no caso dos artefatos, primeiro um agente o cria e só depois este agente pode ou não focá-lo, ou seja, sinais emitidos no método ``init" não podem ser detectados pelos agentes. Por causa disso, percepções que devem existir desde a criação do artefato independente das suas operações, como as de posição dos agentes, devem ser criadas como percepções persistentes, propriedades observáveis, no método ``init".

A última adaptação é fazer com que o primeiro objetivo dos agentes r1 e r2 seja o objetivo !inicializar. No caso de r1, esse objetivo chama a ação ``makeArtifact" para criar uma instância do artefato MarsEnv, então foca a instância criada e chama o objetivo inicial anterior de r1, !checar. Para r2 o objetivo !inicializar usa a ação ``lookupArtifact" para encontrar a instância criada por r1, e então a foca.
\\*

Segue abaixo a imagem abstrata do artefato MarsEnv e o código deste artefato em um ambiente Cartago.
\begin{figure}[ht]
\begin{center}
\includegraphics{figuras/figura17.png}
\caption{Representação abstrata do Artefato MarsEnv}
\end{center}
\end{figure}
\begin{lstlisting}[frame=tb]
import cartago.*;
import java.util.ArrayList;
import java.util.Random;

public class MarsEnv extends Artifact {
	
	final int GSize = 7;
	Posicao pos_r1;
	Posicao pos_r2;
	ArrayList<Posicao> pos_lixos;
	
	Random random = new Random(System.currentTimeMillis());
	public static final int MErr = 2; // max erros ao pegar o lixo
              int nerr; // número de tentativas de pegar o lixo
	
	void init() {
		// definir posição inicial dos agentes
		pos_r1 = new Posicao(0,0);
		pos_r2 = new Posicao(GSize/2, GSize/2);
		
		// definir posição inicial dos lixos
		pos_lixos = new ArrayList<Posicao>();
		pos_lixos.add(new Posicao(3,0));
		pos_lixos.add(new Posicao(GSize-1, 0));
		pos_lixos.add(new Posicao(1,2));
		pos_lixos.add(new Posicao(0, GSize-2));
		pos_lixos.add(new Posicao(GSize-1, GSize-1));
		
		// percepções iniciais
		defineObsProperty(``pos_r1",pos_r1.x, pos_r1.y);
		defineObsProperty(``pos_r2",pos_r2.x, pos_r2.y);
		defineObsProperty(``r1TemLixo",false);
		defineObsProperty(``terminou",false);
	}
	
	@OPERATION
	void prox(String slot)
	{
		printLog(``prox("+slot+``)");
		
       		 // termina de procurar na grade
        		if(pos_r1.x == 0 \&\& pos_r1.y == GSize)
        		{
          			 getObsProperty(``terminou").updateValue(true);
            			return;
       		 }
		
        		pos_r1.x++;
        		if (pos_r1.x == GSize) {
        			pos_r1.x = 0;
        			pos_r1.y++;
        		}
        
        		getObsProperty(``pos_r1").updateValues(pos_r1.x, pos_r1.y);
        
        		signal("pos(r1," + pos_r1.x + "," + pos_r1.y + ")");
        		if(temLixoEm(pos_r1))
        		{
        			signal("lixo", "r1");
        		}
    	}
	
	@OPERATION
	void ir_para(int x, int y)
	{
		printLog("ir_para("+x+","+y+")");
        		if (pos_r1.x < x)
        			pos_r1.x++;
        		else if (pos_r1.x > x)
        			pos_r1.x--;
        		if (pos_r1.y < y)
        			pos_r1.y++;
        		else if (pos_r1.y > y)
        			pos_r1.y--;
        
            		getObsProperty("pos_r1").updateValues(pos_r1.x, pos_r1.y);
	}
	
	@OPERATION
	void pegar(String lixo)
	{
		printLog("pegar("+lixo+")");
		// local de r1 tem lixo
        		if (temLixoEm(pos_r1)) {
           		 // as vezes a ação "pegar" são funciona
            		// mas nunca mais que MErr vezes
            				if (random.nextBoolean() || nerr == MErr) {
            					removerLixoEm(pos_r1);
                				nerr = 0;
               				 getObsProperty("r1TemLixo").updateValues(true);
            				} else {
                				nerr++;
            				}
        		}
	}
	
	@OPERATION
	void largar(String lixo)
	{
		printLog("largar("+lixo+")");
		if (getObsProperty("r1TemLixo").booleanValue()) {
            			getObsProperty("r1TemLixo").updateValues(false);
            			pos_lixos.add(new Posicao(pos_r1.x, pos_r1.y));
            			if(pos_r1.x == pos_r2.x \&\& pos_r1.y == pos_r2.y)
            				signal("lixo", "r2");
        		}
	}
	
	@OPERATION
	void queimar(String lixo)
	{
		printLog("queimar("+lixo+")");
		// local de r2 tem lixo
        		if (temLixoEm(pos_r2))
        			removerLixoEm(pos_r2);
	}
	
	private boolean temLixoEm(Posicao p)
	{
		for(Posicao pos: pos_lixos)
			if(pos.x == p.x \&\& pos.y == p.y)
				return true;
		return false;
	}
	
	private void removerLixoEm(Posicao p)
	{
		for(Posicao pos: pos_lixos)
			if(pos.x == p.x \&\& pos.y == p.y)
			{
				pos_lixos.remove(pos);
				break;
			}
	}
	
	private void printLog(String acao)
	{
		System.out.println(getOpUserName()+" executando: "+ acao);
	}
	
	class Posicao
	{
		int x;
		int y;
		
		//...
	}
}
\end{lstlisting}

Código do agente r1 adaptado para usar o artefato MarsEnv, em negrito estão as partes alteradas:
\begin{lstlisting}[frame=tb]
// Agente r1

/* Initial beliefs and rules */

/* Initial goals */

!inicializar. 

/* Plans */

+!inicializar
	<- makeArtifact("mars","MarsEnv",[],Id);
	   focus(Id);
	   !checar(slots).

+!checar(slots) : not lixo("r1") \& not r1TemLixo(true) \& not terminou(true)
   <- prox(slot);
      !!checar(slots).
+!checar(slots).

+lixo("r1") : not .desire(carregar_para(_,_)) \& not lixo("r1")
   <-   +lixo("r1");
          ?pos_r2(X,Y);
          !carregar_para(X,Y).
+lixo("r1").
   
+!carregar_para(A,B) : lixo("r1")
   <- // lembra para onde tem que voltar
      ?pos_r1(X,Y); 
      
      // carrega o lixo para r2
      !pegar(lixo,A,B);
      
      // volta e continua checando o mundo
      !ir_para(X, Y); 
      !!checar(slots).

+!pegar(S,X,Y) : true
   <- !assegurar_pegar(S); 
      !ir_para(X,Y);
      largar(S).

+!assegurar_pegar(_) : r1TemLixo(true) <- -lixo("r1").
+!assegurar_pegar(S) : lixo("r1")
   <- pegar(lixo);
      !assegurar_pegar(S).

+!ir_para(X,Y) : pos_r1(X,Y).
+!ir_para(X,Y) <-    ir_para(X,Y);
                                 !ir_para(X,Y).
          
+terminou(true) : .println("Conclui a busca").   
\end{lstlisting}

Código do agente r2 adaptado para usar o artefato MarsEnv, em negrito estão as partes alteradas:
\begin{lstlisting}[frame=tb]
// Agente r2

/* Initial beliefs and rules */

/* Initial goals */
!inicializar.

/* Plans */
+!inicializar <- lookupArtifact("mars",Id);
	           focus(Id).
-!inicializar <-.wait(50);
	         !inicializar.

+lixo("r2") : true <- queimar(lixo).
\end{lstlisting}

Abaixo são mostrados parte das saídas no Console Jason dos SMAs executados com ambiente Jason (acima) e ambiente Cartago (abaixo). Como pode se notar pelas saídas, ambos os SMAs tiveram o mesmo comportamento, apenas variando um pouco na quantidade de mensagens repetidas enviadas, devido as diferenças do código.

\begin{lstlisting}[frame=tb]
[MarsEnv] r1 executando: prox(slot)
[MarsEnv] r1 executando: prox(slot)
[MarsEnv] r1 executando: pegar(lixo)
[MarsEnv] r1 executando: ir_para(3,3)
[MarsEnv] r1 executando: ir_para(3,3)
[MarsEnv] r1 executando: ir_para(3,3)
[MarsEnv] r1 executando: largar(lixo)
[MarsEnv] r1 executando: ir_para(3,0)
[MarsEnv] r1 executando: ir_para(3,0)
[MarsEnv] r2 executando: queimar(lixo)
[MarsEnv] r1 executando: ir_para(3,0)
[MarsEnv] r1 executando: prox(slot)
[MarsEnv] r1 executando: prox(slot)
[MarsEnv] r1 executando: prox(slot)
[MarsEnv] r1 executando: pegar(lixo)
[MarsEnv] r1 executando: pegar(lixo)
[MarsEnv] r1 executando: pegar(lixo)
[MarsEnv] r1 executando: ir_para(3,3)
[MarsEnv] r1 executando: ir_para(3,3)
[MarsEnv] r1 executando: ir_para(3,3)
[MarsEnv] r1 executando: largar(lixo)
[MarsEnv] r1 executando: ir_para(6,0)
[MarsEnv] r1 executando: ir_para(6,0)
[MarsEnv] r2 executando: queimar(lixo)
[MarsEnv] r1 executando: ir_para(6,0)
[MarsEnv] r1 executando: prox(slot)
[MarsEnv] r1 executando: prox(slot)
[MarsEnv] r1 executando: prox(slot)
...
[MarsEnv] r1 executando: prox(slot)
[MarsEnv] r1 executando: pegar(lixo)
[MarsEnv] r1 executando: ir_para(3,3)
[MarsEnv] r1 executando: ir_para(3,3)
[MarsEnv] r1 executando: ir_para(3,3)
[MarsEnv] r1 executando: largar(lixo)
[MarsEnv] r1 executando: ir_para(6,6)
[MarsEnv] r1 executando: ir_para(6,6)
[MarsEnv] r2 executando: queimar(lixo)
[MarsEnv] r1 executando: ir_para(6,6)
[MarsEnv] r1 executando: prox(slot)
[r1] Conclui a busca
\end{lstlisting}

\begin{lstlisting}[frame=tb]
r1 executando: prox(slot)
r1 executando: prox(slot)
r1 executando: prox(slot)
r1 executando: pegar(lixo)
r1 executando: pegar(lixo)
r1 executando: ir_para(3,3)
r1 executando: ir_para(3,3)
r1 executando: ir_para(3,3)
r1 executando: largar(lixo)
r2 executando: queimar(lixo)
r1 executando: ir_para(3,0)
r1 executando: ir_para(3,0)
r1 executando: ir_para(3,0)
r1 executando: prox(slot)
r1 executando: prox(slot)
r1 executando: prox(slot)
r1 executando: pegar(lixo)
r1 executando: pegar(lixo)
r1 executando: pegar(lixo)
r1 executando: ir_para(3,3)
r1 executando: ir_para(3,3)
r1 executando: ir_para(3,3)
r1 executando: largar(lixo)
r1 executando: ir_para(6,0)
r2 executando: queimar(lixo)
r1 executando: ir_para(6,0)
r1 executando: ir_para(6,0)
r1 executando: prox(slot)
...
r1 executando: prox(slot)
r1 executando: pegar(lixo)
r1 executando: ir_para(3,3)
r1 executando: ir_para(3,3)
r1 executando: ir_para(3,3)
r1 executando: largar(lixo)
r2 executando: queimar(lixo)
r1 executando: ir_para(6,6)
r1 executando: ir_para(6,6)
r1 executando: ir_para(6,6)
r1 executando: prox(slot)
r1 executando: prox(slot)
[r1] Conclui a busca
\end{lstlisting}

Por esta comparação pode-se perceber que o código do ambiente Cartago ficou menor, e também por isso, mais fácil de compreender do que o código do ambiente Jason. Isso também ocorreu em consequência do ambiente Jason possuir uma classe principal e uma classe modelo, o que poderia deixar o código mais organizado para ambientes grandes, mas tem a consequência de deixar o código dividido em partes e mais difícil de entender.

Uma conclusão relevante é que o ideal é que um ambiente Cartago seja modelado desde o princípio para ser estruturado em artefatos, de forma descentralizada e levando em consideração a existência de percepções persistentes e não-persistentes. Pois converter um ambiente modelado em Jason para um ambiente Cartago é trabalhoso e cheio de detalhes, como pode-se perceber comparando as duas versões do ambiente e dos agentes mostrados nesta seção, isso mesmo em uma conversão para um ambiente bastante simples como o MarsEnv.

\chapter{Informações adicionais sobre o Desenvolvimento}
\section{Lista de Filtros}
\label{apendices:filtros}

No filtro para classes simples, as classes filtradas foram: dbpedia-owl: PeriodicalLiterature, dbpedia-owl: Album, dbpedia-owl: VideoGame, dbpedia-owl: TelevisionEpisode, dbpedia-owl: TelevisionShow, dbpedia-owl: Film, dbpedia-owl: Band, yago: LivingPeople, yago: Gathering107975026, yago: PuBlication106589574 e 
\\
\noindent umbel: TVShow\_SingleCW.

No filtro para classes avançadas, as classes filtradas foram: yago: Event100029378, yago: WebSite106359193, yago: Award106696483, yago: Professorship100598056,  yago: Medium106254669, yago: HotSpot108586330, yago: Contestant109613191, yago:

\noindent Trainer110722575, yago: MemoryDevice103744840, yago: Professional110480253, yago: Person100007846 e yago: Music107020895.
\\

No filtro para categorias simples, as categorias filtradas foram: Sports, Comics,  Albums, Television\_series e

\noindent College\_football\_seasons

No filtro para categorias avançadas, as categorias filtradas foram: Clubs\_and\_societies, Economies\_by\_country, Hunting,

\noindent Sports\_teams\_by\_country, Companies, Musical\_compositions,

\noindent University\_and\_college\_sports\_clubs\_by\_country, Hospitals, 

\noindent National\_Register\_of\_Historic\_Places, Deaths\_from\_disease e 

\noindent National\_Register\_of\_Historic\_Places\_by\_county.

\section{Códigos da Abordagem por Classes}
\subsection{Código do agente}
\label{apendices:agenteclasses}

\begin{lstlisting}[frame=tb]
!observe.

+!observe : true 
  <- .wait(200); 
    ?myTools(A1, A2, Id);  // discover the tools
  	println("agente criado");
    !consumeItems(Id).

+!consumeItems(Id): true
<- .wait(1000);
get_para_Classes(Item);
!processItem(Item, Id);
!!consumeItems(Id).

+!processItem(null, Id) : true
<- .my_name(Me).
//println(Me,": null").

+!processItem(Keyword, Id) : true
<-  executar_abrangente(Keyword, 30, Result1)[artifact_id(Id)];
	executar_especifico(Result1, Result2)[artifact_id(Id)];
	isEmpty(Result2, Test)[artifact_id("entrada")];
	!decidir(Result1, Result2, Test, Id).	

+!decidir(Result1, Result2, Test, Id) : Test
<- .my_name(Me); println(Me,": vazio");
	executar_getIndividuos(Result1, 20, Result3)[artifact_id(Id)];
	put_less_value(Result3);
	put(Result3).
	
+!decidir(Result1, Result2, Test, Id) : true
<- .my_name(Me); println(Me,": não vazio");
	executar_getIndividuos(Result2, 20, Result3)[artifact_id(Id)];
	put_less_value(Result3);
	put(Result3).

+?myTools(A1, A2, A3): true 
  <- lookupArtifact("entrada",A1);
  	 lookupArtifact("saida",A2);
	 .my_name(N);
	 lookupArtifact(N,A3).

-?myTools(A1, A2, A3): true 
  <- .wait(100); 
     ?myTool(A1, A2, A3).
\end{lstlisting}

\subsection{Código da busca abrangente}
\label{apendices:buscaclasses}

\begin{lstlisting}[frame=tb]
@OPERATION
    void executar_abrangente(String keywordrecebida, int limit, OpFeedbackParam<Object> result)
    {
        System.out.println("LOG: Abordagem por Classes STARTED");
        
        String keyword = NLPTool.toLowerCase(keywordrecebida);
                
        String queryString = AbordagemPorIndividuo.getPrefixes()
                + "select distinct ?Concept where {"
                + "[] a ?Concept ."
                + " ?Concept rdfs:label ?title ."
                + " ?title <bif:contains> \""+keyword+"\" ."
                + filtrarClasses(AbordagemPorIndividuo.classes_filtradas, 5)
                + "} LIMIT "+limit;
        
        QueryExecution qe = new QueryEngineHTTP("http://dbpedia.org/sparql", queryString);
                
        ArrayList<String> classes = new ArrayList<String>();
        
        try
        {
            ResultSet results = qe.execSelect();
            for (; results.hasNext();)
            {
                QuerySolution s = results.next();
                classes.add(s.getResource("Concept").toString());
            }
        }
        finally
        {
           qe.close();
        }
        
        result.set(classes);
        
        System.out.println("LOG: Abordagem por Classes ENDED: "+classes.size());
    }
\end{lstlisting}

\begin{lstlisting}[frame=tb]
private String filtrarClasses(ArrayList<String> classes, int t_max)
    {
        String option = "option(TRANSITIVE, t_distinct, T_MAX("+t_max+"))";
        String result = "";
        for(String s: classes)
            result += "filter (NOT EXISTS {?Concept rdfs:subClassOf "+s+" "+option+" }) .";
        return result; 
    }
\end{lstlisting}

\section{Códigos da Abordagem por Categorias}
\subsection{Código do agente}
\label{apendices:agentecat}

\begin{lstlisting}[frame=tb]
!observe.

+!observe : true 
  <- .wait(200); 
    ?myTools(A1, A2, Id);  // discover the tools
  	println("agente criado");
    !consumeItems(Id).

+!consumeItems(Id): true
<- .wait(1000);
get_para_Categorias(Item);
!processItem(Item, Id);
!!consumeItems(Id).

+!processItem(null, Id) : true.

+!processItem(Keyword, Id) : true
<-  executar_abrangente(Keyword, 30, Result1)[artifact_id(Id)];
	executar_especifico(Result1, Result2)[artifact_id(Id)];
	isEmpty(Result2, Test)[artifact_id("entrada")];
	!decidir(Result1, Result2, Test, Id).	

+!decidir(Result1, Result2, Test, Id) : Test
<- .my_name(Me); println(Me,": vazio");
	executar_getIndividuos(Result1, 20, Result3)[artifact_id(Id)];
	put(Result3).
	
+!decidir(Result1, Result2, Test, Id) : true
<- .my_name(Me); println(Me,": não vazio");
	executar_getIndividuos(Result2, 20, Result3)[artifact_id(Id)];
	put(Result3).
	
+?myTools(A1, A2, A3): true 
  <- lookupArtifact("entrada",A1);
  	 lookupArtifact("saida",A2);
	 .my_name(N);
	 lookupArtifact(N,A3).

-?myTools(A1, A2, A3): true 
  <- .wait(100); 
     ?myTool(A1, A2, A3).
\end{lstlisting}

\subsection{Código da busca abrangente}
\label{apendices:buscacat}


\begin{lstlisting}[frame=tb]
@OPERATION
    void executar_abrangente(String keyphrase, int limit, OpFeedbackParam<Object> res)
    {
        System.out.println("LOG: Abordagem por Categoria Abrangente STARTED");
        int t_max = 6;
        ArrayList<String> result = new ArrayList<String>();
        boolean success = false;
        while(!success)
        {
            try
            {
                result = executar_abrangente2(keyphrase, t_max, limit);
                success = true;
            }catch(Exception e)
            {
                t_max-=2;
                if(t_max == 0)
                {
                    res.set(new ArrayList<String>());
                    System.out.println("LOG: Abordagem por Categoria Abrangente ENDED: 0");
                    return;
                }
            }
        }
        res.set(result);
        System.out.println("LOG: Abordagem por Categoria Abrangente ENDED: "+result.size());
    }
\end{lstlisting}

\begin{lstlisting}[frame=tb]
public ArrayList<String> executar_abrangente2(String keywordrecebida, int t_max, int limit)
    {
        String keyword = NLPTool.toLowerCase(keywordrecebida);
        
        String queryString = AbordagemPorIndividuo.getPrefixes()
                + "select distinct ?Category where {"
                + "?s dcterms:subject ?Category ."
                + " ?Category rdfs:label ?title ."
                + " ?title <bif:contains> \""+keyword+"\" ."
                + filtrarCategorias(AbordagemPorIndividuo.categorias_filtradas, t_max)
                + "} LIMIT "+limit;
        
        QueryExecution qe = new QueryEngineHTTP("http://dbpedia.org/sparql", queryString);
                
        ArrayList<String> categorias = new ArrayList<String>();
        try
        {
            ResultSet results = qe.execSelect();
            for (; results.hasNext();)
            {
                QuerySolution s = results.next();
                categorias.add(s.getResource("Category").toString());
            }
        }
        finally
        {
           qe.close();
        }
        
        return categorias;
    }
\end{lstlisting}

\begin{lstlisting}[frame=tb]
public ArrayList<String> getAllIndividuals(String category, int limit)
    {
        String queryString = AbordagemPorIndividuo.getPrefixes()
                + "select distinct ?ind where {"
                + " ?ind dcterms:subject <"+category+"> ."
                + "} LIMIT "+limit;
        
        QueryExecution qe = new QueryEngineHTTP("http://dbpedia.org/sparql", queryString);
                
        ArrayList<String> ind = new ArrayList<String>();
        try
        {
            ResultSet results = qe.execSelect();
            for (; results.hasNext();)
            {
                QuerySolution s = results.next();
                ind.add(s.getResource("ind").toString());
            }
        }
        finally
        {
           qe.close();
        }
        return ind;
    }
\end{lstlisting}


\section{Versão Alternativa da Ferramenta utilizando comunicação entre agentes}

Foi decidido no trabalho original implementar o principal algoritmo de ranqueamento através de um artefato pois o algoritmo de ranqueamento se mostrou bastante complexo de implementar com agentes, por envolver a pontuação e ordenamento de uma grande quantidade de resultados. Porém também foi desenvolvida uma segunda versão da ferramenta, que utiliza comunicação entre agentes para fazer o ranqueamento.

Nesta versão o agente inicializador também faz o papel de agente coordenador. A ação !processItem dos agentes por abordagem foi modificada para que após executar uma busca abrangente e obter os indivíduos os agentes se comunicam com o agente inicializador enviando os resultados obtidos como uma crença. Abaixo é mostrado como essa modificação foi efetuada para o agente atuador\_por\_classes.

\begin{lstlisting}[frame=tb]
+!processItem(Keyword, Id) : true
<-  executar_abrangente(Keyword, 20, Result1)[artifact_id(Id)];
	executar_getIndividuos(Result1, 30, Result2)[artifact_id(Id)];
	.send("inicializador",tell,results2(Result2)).
\end{lstlisting}

Para cada crença atualizada o agente inicializador atualiza um contador e tenta criar o objetivo !rankResults, que após será executado quando o contador atingir três, ou seja, todos os agentes tiverem enviado seus resultados. Ao ser criada a intenção rankResults o agente faz intersecções de cada dois conjuntos de resultados e os armazenadas nas variáveis X, Y e Z, que então são agrupadas em uma única variável final através de unions. Preferiu-se fazer o ranqueamento desta forma ao invés de uma intersecção entre os três conjuntos de resultados para que haja um conjunto maior de resultados finais, já que um resultado precisa estar presente em apenas 2 das 3 abordagens para ser selecionado. O código do agente inicializador que efetua o procedimento descrito é mostrado abaixo.

\begin{lstlisting}[frame=tb]
+results2(R): true
<- .my_name(Me);
	println(Me,": got results2 ", R);
	-cont(V);
	+cont(V+1);
	!rankResults.

+!rankResults: cont(3) & results1(R1) & results2(R2) & results3(R3)
<- println("Rank:");
	.intersection(R1,R2,X);
	.intersection(R2,R3,Y);
	.intersection(R1,R3,Z);
	.union(X,Y,Parcial);
	.union(Parcial,Z,Results);
	.length(Results,L);
	!showResults(Results, L).
	
+!rankResults: true.

+!showResults(Results, L): L > 0
<- .nth(0,Results,A);
	println("1: ", A);
	.nth(1,Results,B);
	println("2: ", B);
	.nth(2,Results,C);
	println("3: ", C);
	.nth(3,Results,D);
	println("4: ", D);
	.nth(4,Results,E);
	println("5: ", E);
	put2(Results).

+!showResults(Results, L): true
<- println("Nenhum resultado encontrado.").
\end{lstlisting}


\anexo
\chapter{Artigo SBC}
\chapter{Código-fonte}
\section{Código dos Agentes}
\subsection{atuador\_por\_categorias.asl}
\begin{lstlisting}[frame=tb]
!observe.

+!observe : true 
  <- .wait(200); 
    ?myTools(A1, A2, Id);  // discover the tools
  	println("agente criado");
    !consumeItems(Id).

+!consumeItems(Id): true
<- .wait(1000);
get_para_Categorias(Item);
!processItem(Item, Id);
!!consumeItems(Id).

+!processItem(null, Id) : true
<- .my_name(Me).
//println(Me,": null").

+!processItem(Keyword, Id) : true
<-  executar_abrangente(Keyword, 30, Result1)[artifact_id(Id)];
	executar_especifico(Result1, Result2)[artifact_id(Id)];
	isEmpty(Result2, Test)[artifact_id("entrada")];
	!decidir(Result1, Result2, Test, Id).	

+!decidir(Result1, Result2, Test, Id) : Test
<- .my_name(Me); println(Me,": vazio");
	executar_getIndividuos(Result1, 20, Result3)[artifact_id(Id)];
	put(Result3).
	
+!decidir(Result1, Result2, Test, Id) : true
<- .my_name(Me); println(Me,": não vazio");
	executar_getIndividuos(Result2, 20, Result3)[artifact_id(Id)];
	put(Result3).
	
+?myTools(A1, A2, A3): true 
  <- lookupArtifact("entrada",A1);
  	 lookupArtifact("saida",A2);
	 .my_name(N);
	 lookupArtifact(N,A3).

-?myTools(A1, A2, A3): true 
  <- .wait(100); 
     ?myTool(A1, A2, A3).
\end{lstlisting}

\subsection{atuador\_por\_classes.asl}

\begin{lstlisting}[frame=tb]
!observe.

+!observe : true 
  <- .wait(200); 
    ?myTools(A1, A2, Id);  // discover the tools
  	println("agente criado");
    !consumeItems(Id).

+!consumeItems(Id): true
<- .wait(1000);
get_para_Classes(Item);
!processItem(Item, Id);
!!consumeItems(Id).

+!processItem(null, Id) : true
<- .my_name(Me).
//println(Me,": null").

+!processItem(Keyword, Id) : true
<-  executar_abrangente(Keyword, 30, Result1)[artifact_id(Id)];
	executar_especifico(Result1, Result2)[artifact_id(Id)];
	isEmpty(Result2, Test)[artifact_id("entrada")];
	!decidir(Result1, Result2, Test, Id).	

+!decidir(Result1, Result2, Test, Id) : Test
<- .my_name(Me); println(Me,": vazio");
	executar_getIndividuos(Result1, 20, Result3)[artifact_id(Id)];
	put_less_value(Result3);
	put(Result3).
	
+!decidir(Result1, Result2, Test, Id) : true
<- .my_name(Me); println(Me,": não vazio");
	executar_getIndividuos(Result2, 20, Result3)[artifact_id(Id)];
	put_less_value(Result3);
	put(Result3).

+?myTools(A1, A2, A3): true 
  <- lookupArtifact("entrada",A1);
  	 lookupArtifact("saida",A2);
	 .my_name(N);
	 lookupArtifact(N,A3).

-?myTools(A1, A2, A3): true 
  <- .wait(100); 
     ?myTool(A1, A2, A3).
\end{lstlisting}

\subsection{atuador\_por\_individuos.asl}

\begin{lstlisting}[frame=tb]
!observe.

+!observe : true 
  <- .wait(200); 
    ?myTools(A1, A2, Id);  // discover the tools
  	println("agente criado");
    !consumeItems(Id).

+!consumeItems(Id): true
<- .wait(1000);
get_para_Individuos(Item);
!processItem(Item, Id);
!!consumeItems(Id).

+!processItem(null, Id) : true
<- .my_name(Me).
//println(Me,": null").

+!processItem(Keyword, Id) : true
<-  executar_abrangente(Keyword, 50, Result)[artifact_id(Id)];
	executar_especifico(Result, Result2)[artifact_id(Id)];
	isEmpty(Result2, Test)[artifact_id("entrada")];
	!decidir(Result1, Result2, Test, Id).	

+!decidir(Result1, Result2, Test, Id) : Test
<- .my_name(Me); println(Me,": vazio");
	put_more_value(Result2);
	put(Result2).
	
+!decidir(Result1, Result2, Test, Id) : true
<- .my_name(Me); println(Me,": não vazio");
	put_more_value(Result2);
	put(Result2).

+?myTools(A1, A2, A3): true 
  <- lookupArtifact("entrada",A1);
  	 lookupArtifact("saida",A2);
	 .my_name(N);
	 lookupArtifact(N,A3).

-?myTools(A1, A2, A3): true 
  <- .wait(100); 
     ?myTool(A1, A2, A3).
\end{lstlisting}

\subsection{inicializador.asl}

\begin{lstlisting}[frame=tb]
!create_and_use.

+!create_and_use : true
  <- !setupTools;
  	println("artefatos criados").

// create the tools
+!setupTools: true 
  <- makeArtifact("entrada","artifacts.ArtefatoEntrada",[],A1);
  	 makeArtifact("saida","artifacts.ArtefatoSaida",[],A2);
	 
	 //makeArtifact("atuador_por_individuos","artifacts.AbordagemPorIndividuo",[],A3);
	 //makeArtifact("atuador_por_classes","artifacts.AbordagemPorClasses",[],A4);
	 //makeArtifact("atuador_por_categorias","artifacts.AbordagemPorCategoria",[],A5)
	 
	 makeArtifact("atuador_por_individuos1","artifacts.AbordagemPorIndividuo",[],A3);
	 makeArtifact("atuador_por_individuos2","artifacts.AbordagemPorIndividuo",[],A6);
	 makeArtifact("atuador_por_individuos3","artifacts.AbordagemPorIndividuo",[],A9);
	 makeArtifact("atuador_por_classes1","artifacts.AbordagemPorClasses",[],A4);
	 makeArtifact("atuador_por_classes2","artifacts.AbordagemPorClasses",[],A7);
	 makeArtifact("atuador_por_classes3","artifacts.AbordagemPorClasses",[],A10);
	 makeArtifact("atuador_por_categorias1","artifacts.AbordagemPorCategoria",[],A5);
	 makeArtifact("atuador_por_categorias2","artifacts.AbordagemPorCategoria",[],A8);
	 makeArtifact("atuador_por_categorias3","artifacts.AbordagemPorCategoria",[],A11).

\end{lstlisting}

\section{Código dos Artefatos}

\subsection{AbordagemPorCategoria.java}

\begin{lstlisting}[frame=tb]
package artifacts;

import cartago.*;
import com.hp.hpl.jena.query.QueryExecution;
import com.hp.hpl.jena.query.QuerySolution;
import com.hp.hpl.jena.query.ResultSet;
import com.hp.hpl.jena.sparql.engine.http.QueryEngineHTTP;
import java.util.ArrayList;
import java.util.Arrays;
import util.NLPTool;

public class AbordagemPorCategoria extends Artifact
{
    void init()
    {
        
    }
    
    @OPERATION
    void executar_abrangente(String keyphrase, int limit, OpFeedbackParam<Object> res)
    {
        System.out.println("LOG: Abordagem por Categoria Abrangente STARTED");
        int t_max = 6;
        ArrayList<String> result = new ArrayList<String>();
        boolean success = false;
        while(!success)
        {
            try
            {
                result = executar_abrangente2(keyphrase, t_max, limit);
                success = true;
            }catch(Exception e)
            {
                t_max-=2;
                if(t_max == 0)
                {
                    res.set(new ArrayList<String>());
                    System.out.println("LOG: Abordagem por Categoria Abrangente ENDED: 0");
                    return;
                }
            }
        }
        res.set(result);
        System.out.println("LOG: Abordagem por Categoria Abrangente ENDED: "+result.size());
    }
    
    @OPERATION
    void executar_especifico(ArrayList<String> categorias, OpFeedbackParam<Object> res)
    {
        System.out.println("LOG: Abordagem por Categoria Especifico STARTED");
        int t_max = 6;
        ArrayList<String> result = new ArrayList<String>();
        boolean success = false;
        while(!success)
        {
            try
            {
                result = executar_especifico2(categorias, t_max);
                success = true;
            }catch(Exception e)
            {
                t_max-=2;
                if(t_max == 0)
                {
                    res.set(new ArrayList<String>());
                    System.out.println("LOG: Abordagem por Categoria Especifico ENDED: 0");
                    return;
                }
            }
        }
        res.set(result);
        System.out.println("LOG: Abordagem por Categoria Especifico ENDED: "+result.size());
    }
    
    public ArrayList<String> executar_abrangente2(String keyphrase, int t_max, int limit)
    {
        keyphrase = NLPTool.toLowerCase(keyphrase);
        ArrayList<String> keywords = NLPTool.separateWords(keyphrase);
        String keyword = keywords.remove(0);
        
        String queryString = AbordagemPorIndividuo.getPrefixes()
                + "select distinct ?Category where {"
                + "?s dcterms:subject ?Category ."
                + " ?Category rdfs:label ?title ."
                + " ?title <bif:contains> \""+keyword+"\" ."
                + filtrarCategorias(AbordagemPorIndividuo.categorias_filtradas, t_max)
                + filtrarKeyphrase(keywords)
                + "} LIMIT "+limit;
        
        QueryExecution qe = new QueryEngineHTTP("http://dbpedia.org/sparql", queryString);
                
        ArrayList<String> categorias = new ArrayList<String>();
        try
        {
            ResultSet results = qe.execSelect();
            for (; results.hasNext();)
            {
                QuerySolution s = results.next();
                categorias.add(s.getResource("Category").toString());
            }
        }
        finally
        {
           qe.close();
        }
        
        return categorias;
    }
    
    @OPERATION
    ArrayList<String> executar_especifico2(ArrayList<String> categorias, int t_max)
    {
        System.out.println("LOG: Categorias, tentativa: "+t_max+" STARTED");
        
        ArrayList<String> resultado = new ArrayList<String>();
        
        int cont = 1;
        for(String categoria: categorias)
        {
            //System.out.println("LOG: "+cont+" "+categoria);
            cont++;
            String queryString = AbordagemPorIndividuo.getPrefixes()
                + "SELECT distinct ?Category "
                + "WHERE {"
                
                + "{?s dcterms:subject ?Category FILTER (?Category = <"+categoria+">) .}"
                
                + filtrarCategorias(AbordagemPorIndividuo.categorias_filtradas_avancado, t_max)
                + "}"
                + "LIMIT 5";
        
            QueryExecution qe = new QueryEngineHTTP("http://dbpedia.org/sparql", queryString);

            ArrayList<String> parcial = new ArrayList<String>();
            try
            {
                ResultSet results = qe.execSelect();
                for (; results.hasNext();)
                {
                    QuerySolution s = results.next();
                    parcial.add(s.getResource("Category").toString());
                }
            }
            finally
            {
               qe.close();
            }
            //System.out.println("parcial: "+parcial);
            resultado.addAll(parcial);
        }
        System.out.println("categorias: "+resultado);

        System.out.println("LOG: Categorias, tentativa: "+t_max+" ENDED");
        
        return resultado;
    }
    
    @OPERATION
    void executar_getIndividuos(ArrayList<String> categorias, int limit_ind, OpFeedbackParam<Object> result)
    {
        System.out.println("LOG: Abordagem por Categorias - getIndividuos STARTED");
        
        ArrayList<String> individuos = new ArrayList<String>();
        for(String classe: categorias)
            individuos.addAll(getAllIndividuals(classe, limit_ind));
        
        System.out.println("individuos-categorias: "+individuos);
        
        result.set(individuos);
        
        System.out.println("LOG: Abordagem por Categorias - getIndividuos ENDED: "+individuos.size());
    }
    
    public ArrayList<String> getAllIndividuals(String category, int limit)
    {
        String queryString = AbordagemPorIndividuo.getPrefixes()
                + "select distinct ?ind where {"
                + " ?ind dcterms:subject <"+category+"> ."
                + "} LIMIT "+limit;
        
        QueryExecution qe = new QueryEngineHTTP("http://dbpedia.org/sparql", queryString);
                
        ArrayList<String> ind = new ArrayList<String>();
        try
        {
            ResultSet results = qe.execSelect();
            for (; results.hasNext();)
            {
                QuerySolution s = results.next();
                ind.add(s.getResource("ind").toString());
            }
        }
        finally
        {
           qe.close();
        }
        return ind;
    }
    
    private String filtrarKeyphrase(ArrayList<String> keywords)
    {
        //String filters_keyphrase = "";
        //for(int i = 0; i < keywords.size(); i++)
        //    filters_keyphrase += "FILTER (CONTAINS(?title, \""+keywords.get(i) +"\")) .";
        //return filters_keyphrase;
        return "";
    }
    
    private String filtrarCategorias(ArrayList<String> categorias, int t_max)
    {
        String option = "option(TRANSITIVE, T_DISTINCT, t_max("+t_max+"), T_NO_CYCLES, t_shortest_only)";
        String result = "";
        for(String s: categorias)
            result += "filter (NOT EXISTS {?Category skos:broader dbpedia_category:"+s+" "+option+" }) .";
        return result;  
    }
}

\end{lstlisting}

\subsection{AbordagemPorClasses.java}

\begin{lstlisting}[frame=tb]
package artifacts;

import cartago.*;
import com.hp.hpl.jena.query.QueryExecution;
import com.hp.hpl.jena.query.QuerySolution;
import com.hp.hpl.jena.query.ResultSet;
import com.hp.hpl.jena.sparql.engine.http.QueryEngineHTTP;
import java.util.ArrayList;
import java.util.Arrays;
import util.NLPTool;

public class AbordagemPorClasses extends Artifact
{
    void init()
    {
        
    }
    
    @OPERATION
    void executar_abrangente(String keyphrase, int limit, OpFeedbackParam<Object> result)
    {
        System.out.println("LOG: Abordagem por Classes STARTED");
        
        keyphrase = NLPTool.toLowerCase(keyphrase);
        ArrayList<String> keywords = NLPTool.separateWords(keyphrase);
        String keyword = keywords.remove(0);
        
        String queryString = AbordagemPorIndividuo.getPrefixes()
                + "select distinct ?Concept where {"
                + "[] a ?Concept ."
                + " ?Concept rdfs:label ?title ."
                + " ?title <bif:contains> \""+keyword+"\" ."
                + filtrarClasses(AbordagemPorIndividuo.classes_filtradas, 5)
                + filtrarKeyphrase(keywords)
                + "} LIMIT "+limit;
        
        QueryExecution qe = new QueryEngineHTTP("http://dbpedia.org/sparql", queryString);
                
        ArrayList<String> classes = new ArrayList<String>();
        
        try
        {
            ResultSet results = qe.execSelect();
            for (; results.hasNext();)
            {
                QuerySolution s = results.next();
                classes.add(s.getResource("Concept").toString());
            }
        }
        finally
        {
           qe.close();
        }
        
        result.set(classes);
        
        System.out.println("LOG: Abordagem por Classes ENDED: "+classes.size());
    }
    
    @OPERATION
    void executar_especifico(ArrayList<String> classes, OpFeedbackParam<Object> result)
    {
        System.out.println("LOG: Abordagem por Classes Avancado STARTED");
        
        ArrayList<String> resultado = new ArrayList<String>();
        
        int cont = 1;
        for(String classe: classes)
        {
            //System.out.println("LOG: "+cont+" "+classe);
            cont++;
            String queryString = AbordagemPorIndividuo.getPrefixes()
                + "SELECT distinct ?Concept "
                + "WHERE {"
                
                + "{?object ?p ?Concept FILTER (?Concept = <"+classe+">) .}"
                
                + filtrarClasses(AbordagemPorIndividuo.classes_filtradas_avancado, 5)
                + "}"
                + "LIMIT 5";
        
            QueryExecution qe = new QueryEngineHTTP("http://dbpedia.org/sparql", queryString);

            ArrayList<String> parcial = new ArrayList<String>();
            try
            {
                ResultSet results = qe.execSelect();
                for (; results.hasNext();)
                {
                    QuerySolution s = results.next();
                    parcial.add(s.getResource("Concept").toString());
                }
            }
            finally
            {
               qe.close();
            }
            //System.out.println("parcial: "+parcial);
            resultado.addAll(parcial);
        }
        System.out.println("classes: "+resultado);

        result.set(resultado);
        
        System.out.println("LOG: Abordagem por Classes Avancado ENDED: "+resultado.size());
    }
    
    @OPERATION
    void executar_getIndividuos(ArrayList<String> classes, int limit_subclasses, OpFeedbackParam<Object> result)
    {
        System.out.println("LOG: Abordagem por Classes Avancado - getIndividuos STARTED");
        
        ArrayList<String> individuos = new ArrayList<String>();
        for(String classe: classes)
            individuos.addAll(getAllSubClasses(classe, limit_subclasses));
        
        System.out.println("individuos-classes: "+individuos);
        
        result.set(individuos);
        
        System.out.println("LOG: Abordagem por Classes Avancado - getIndividuos ENDED: "+individuos.size());
    }
    
    public ArrayList<String> getAllSubClasses(String classe, int limit)
    {
        String queryString = AbordagemPorIndividuo.getPrefixes()
                + "select distinct ?subclass where {"
                + " ?subclass a <"+classe+"> option(TRANSITIVE, t_distinct, T_MAX(4))."
                + "} LIMIT "+limit;
        
        QueryExecution qe = new QueryEngineHTTP("http://dbpedia.org/sparql", queryString);
                
        ArrayList<String> subclasses = new ArrayList<String>();
        try
        {
            ResultSet results = qe.execSelect();
            for (; results.hasNext();)
            {
                QuerySolution s = results.next();
                subclasses.add(s.getResource("subclass").toString());
            }
        }
        finally
        {
           qe.close();
        }
        return subclasses;
    }
    
    private String filtrarClasses(ArrayList<String> classes, int t_max)
    {
        String option = "option(TRANSITIVE, t_distinct, T_MAX("+t_max+"))";
        String result = "";
        for(String s: classes)
            result += "filter (NOT EXISTS {?Concept rdfs:subClassOf "+s+" "+option+" }) .";
        return result; 
    }
    
    private String filtrarKeyphrase(ArrayList<String> keywords)
    {
        //String filters_keyphrase = "";
        //for(int i = 0; i < keywords.size(); i++)
        //    filters_keyphrase += "FILTER (CONTAINS(?title, \""+keywords.get(i) +"\")) .";
        //return filters_keyphrase;
        return "";
    }
}

\end{lstlisting}

\subsection{AbordagemPorIndividuo.java}

\begin{lstlisting}[frame=tb]
package artifacts;

import cartago.*;
import com.hp.hpl.jena.query.QueryExecution;
import com.hp.hpl.jena.query.QuerySolution;
import com.hp.hpl.jena.query.ResultSet;
import com.hp.hpl.jena.sparql.engine.http.QueryEngineHTTP;
import java.util.ArrayList;
import java.util.Arrays;
import util.NLPTool;

public class AbordagemPorIndividuo extends Artifact
{
    void init()
    {
        
    }
    
    @OPERATION
    void executar_abrangente(String keyphrase, int limit, OpFeedbackParam<Object> result)
    {
        System.out.println("LOG: Abordagem por Individuos STARTED");
        keyphrase = NLPTool.toLowerCase(keyphrase);
        ArrayList<String> keywords = NLPTool.separateWords(keyphrase);
        String keyword = keywords.remove(0);
        
        String queryString = getPrefixes()
                + "SELECT distinct ?object "
                + "WHERE {"
                
                + "{?object db-prop:title ?title . ?title <bif:contains> \""+keyword+"\" . "+filtrarKeyphrase(keywords, "title")+"}"
                + " UNION "
                + "{?object  db-prop:name ?name. ?name <bif:contains> \""+keyword+"\" . "+filtrarKeyphrase(keywords, "name")+"}"
                //+ " UNION "
                //+ "{?object  foaf:name ?label. ?label <bif:contains> \""+keyword+"\" . "+filtrarKeyphrase(keywords, "label")+"}"
                
                + filtrarClasses(classes_filtradas)
                + filtrarClasses(classes_filtradas_avancado)
                //+ filtrarCategorias()
                + "}"
                + "LIMIT "+limit;
        
        QueryExecution qe = new QueryEngineHTTP("http://dbpedia.org/sparql", queryString);

        ArrayList<String> individuos = new ArrayList<String>();
        try
        {
            ResultSet results = qe.execSelect();
            for (; results.hasNext();)
            {
                QuerySolution s = results.next();
                individuos.add(s.getResource("object").toString());
            }
        }
        finally
        {
           qe.close();
        }
        
        result.set(individuos);
        System.out.println("LOG: Abordagem por Individuos ENDED: "+individuos.size());
    }
    
    @OPERATION
    void executar_especifico(ArrayList<String> individuos, OpFeedbackParam<Object> result)
    {
        System.out.println("LOG: Abordagem por Individuos Avancado STARTED");
        
        ArrayList<String> resultado = new ArrayList<String>();
        
        int cont = 1;
        for(String individuo: individuos)
        {
            //System.out.println("LOG: "+cont+" "+individuo);
            cont++;
            String queryString = getPrefixes()
                + "SELECT distinct ?object "
                + "WHERE {"
                
                + "{?object ?p ?o FILTER (?object = <"+individuo+">) .}"
                
                + filtrarCategorias(categorias_filtradas, 4)
                + filtrarCategorias(categorias_filtradas_avancado, 3)
                + "}"
                + "LIMIT 5";
        
            QueryExecution qe = new QueryEngineHTTP("http://dbpedia.org/sparql", queryString);

            ArrayList<String> parcial = new ArrayList<String>();
            try
            {
                ResultSet results = qe.execSelect();
                for (; results.hasNext();)
                {
                    QuerySolution s = results.next();
                    parcial.add(s.getResource("object").toString());
                }
            }
            finally
            {
               qe.close();
            }
            //System.out.println("parcial: "+parcial);
            resultado.addAll(parcial);
        }
        System.out.println("individuos: "+resultado);
        result.set(resultado);
        System.out.println("LOG: Abordagem por Individuos Avancado ENDED: "+resultado.size());
    }
    
    private String filtrarKeyphrase(ArrayList<String> keywords, String campo)
    {
        //String filters_keyphrase = "";
        //for(int i = 0; i < keywords.size(); i++)
        //    filters_keyphrase += "FILTER (CONTAINS(?"+campo+", \""+keywords.get(i) +"\")) .";
        //return filters_keyphrase;
        return "";
    }
    
    public static String getPrefixes()
    {
        String s = "PREFIX db-prop: <http://dbpedia.org/property/>"
                + "PREFIX dbpedia-owl:<http://dbpedia.org/ontology/>"
                + "PREFIX rdf:<http://www.w3.org/1999/02/22-rdf-syntax-ns#>"
                + "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>"
                + "PREFIX dbpedia_category: <http://dbpedia.org/resource/Category:> "
                + "PREFIX dcterms: <http://purl.org/dc/terms/> "
                + "PREFIX foaf: <http://xmlns.com/foaf/0.1/> "
                + "PREFIX yago:<http://dbpedia.org/class/yago/> "
                + "PREFIX skos: <http://www.w3.org/2004/02/skos/core#> ";
        return s;
    }
    
    public static ArrayList<String> classes_filtradas =
            new ArrayList(Arrays.asList(new String[]{"dbpedia-owl:PeriodicalLiterature", "dbpedia-owl:Album", 
            "dbpedia-owl:VideoGame", "dbpedia-owl:TelevisionEpisode", "dbpedia-owl:TelevisionShow",
            "dbpedia-owl:Film", "dbpedia-owl:Band", "<http://umbel.org/umbel/rc/TVShow_SingleCW>", "yago:LivingPeople",
            "yago:PuBlication106589574", "yago:Gathering107975026"}));
    public static ArrayList<String> classes_filtradas_avancado =
            new ArrayList(Arrays.asList(new String[]{ "yago:Event100029378",
            "yago:WebSite106359193", "yago:Award106696483", "yago:Professorship100598056",
            "yago:Medium106254669", "yago:HotSpot108586330", "yago:Contestant109613191",
            "yago:Trainer110722575", "yago:MemoryDevice103744840", "yago:Professional110480253", "yago:Person100007846",
            "yago:Music107020895"}));
    private String filtrarClasses(ArrayList<String> classes)
    {
        String result = "";
        for(String s: classes)
            result += "filter (NOT EXISTS {?object a "+s+" }) .";
        return result; 
    }
    
    public static ArrayList<String> categorias_filtradas =
            new ArrayList(Arrays.asList(new String[]{"Sports", "Comics",  "Albums", "Television_series", "College_football_seasons"}));
    public static ArrayList<String> categorias_filtradas_avancado =
            new ArrayList(Arrays.asList(new String[]{"Clubs_and_societies", "Economies_by_country", "Companies",
                "Sports_teams_by_country", "University_and_college_sports_clubs_by_country",
            "National_Register_of_Historic_Places_by_county", "National_Register_of_Historic_Places", "Hospitals",
            "Musical_compositions", "Hunting", "Deaths_from_disease"}));
    private String filtrarCategorias(ArrayList<String> categorias, int t_max)
    {
        String option = "option(TRANSITIVE , T_DISTINCT, t_max("+t_max+"))";
        String result = "";
        for(String s: categorias)
            result += "filter (NOT EXISTS {?object dcterms:subject ?Category . ?Category skos:broader dbpedia_category:"+s+" "+option+" }) .";
        return result;  
    }
}

\end{lstlisting}

\subsection{ArtefatoEntrada.java}

\begin{lstlisting}[frame=tb]
package artifacts;

import cartago.*;
import java.util.ArrayList;
import user_interface.Main;

public class ArtefatoEntrada extends Artifact
{
    private ArrayList<String> items1 = new ArrayList<String>();
    private ArrayList<String> items2 = new ArrayList<String>();
    private ArrayList<String> items3 = new ArrayList<String>();
    
    void init()
    {
        items1 = new ArrayList<String>();
        items2 = new ArrayList<String>();
        items3 = new ArrayList<String>();
        
        String args[] = new String[2];
        Main.main(args);
        Main.control.setArtefatoEntrada(this);
    }
    
    @OPERATION
    void get_para_Individuos(OpFeedbackParam<Object> res){
        if(items1.isEmpty())
        {
            res.set(null);
            return;
        }
        Object item = items1.remove(0);
        res.set(item);
    }
    
    @OPERATION
    void get_para_Classes(OpFeedbackParam<Object> res){
        if(items2.isEmpty())
        {
            res.set(null);
            return;
        }
        Object item = items2.remove(0);
        res.set(item);
    }
    
    @OPERATION
    void get_para_Categorias(OpFeedbackParam<Object> res){
        if(items3.isEmpty())
        {
            res.set(null);
            return;
        }
        Object item = items3.remove(0);
        res.set(item);
    }
    
    @OPERATION
    void isEmpty(ArrayList<String> array, OpFeedbackParam<Boolean> res){
        if(array.isEmpty())
        {
            res.set(true);
            return;
        }
        res.set(false);
    }
    
    void fornecerInformacoes(ArrayList<String> array_keywords)
    {
        for(String s: array_keywords)
        {
            items1.add(s);
            items2.add(s);
            items3.add(s);
        }
    }
}


\end{lstlisting}

\subsection{ArtefatoSaida.java}

\begin{lstlisting}[frame=tb]
package artifacts;

import cartago.*;
import com.hp.hpl.jena.query.QueryExecution;
import com.hp.hpl.jena.query.QuerySolution;
import com.hp.hpl.jena.query.ResultSet;
import com.hp.hpl.jena.sparql.engine.http.QueryEngineHTTP;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import user_interface.Main;
import util.NLPTool;
import util.Rank;
import util.TipoDeSugestao;

public class ArtefatoSaida extends Artifact
{
    private ArrayList<String> items;
    private ArrayList<String> items_less_value;
    private ArrayList<String> items_more_value;
    private boolean pronto = false;
    private int cont = 0;
    private List<String> resultados_por_quant;
    
    void init()
    {
        items = new ArrayList<String>();
        items_less_value = new ArrayList<String>();
        items_more_value = new ArrayList<String>();
        resultados_por_quant = new ArrayList<String>();

        Main.control.setArtefatoSaida(this);
    }
    
    @OPERATION
    void put(Object obj)
    {
        ArrayList<String> array = (ArrayList<String>)obj;
        items.addAll(array);

        cont++;
        int quantAgentsPorTipo = 3;
        if(cont ==  Controladora.quantKeywords*quantAgentsPorTipo)
        {
            resultados_por_quant = Rank.rankByQuant(20, items, items_less_value, items_more_value);
            System.out.println("rankeado: "+resultados_por_quant);
            pronto = true;
        }
    }
    
    @OPERATION
    void put_less_value(Object obj)
    {
        ArrayList<String> array = (ArrayList<String>)obj;
        items_less_value.addAll(array);
    }
    
    @OPERATION
    void put_more_value(Object obj)
    {
        ArrayList<String> array = (ArrayList<String>)obj;
        items_more_value.addAll(array);
    }
    
    public boolean isReady()
    {
        return pronto;
    }
    
    public List<String> getItemsDevolvidos(TipoDeSugestao tipo)
    {
        String temp;
        String result;
        List<String> list = new ArrayList<String>();
        if(tipo == TipoDeSugestao.SUGESTAO_TITLE)
        {
            for(String s: resultados_por_quant)
            {
                result = extrairTitleAndKeyword(s);
                if(!result.equals(""))
                {
                    temp = s+" : "+result;
                    list.add(temp);
                }
            }
            return list;
        }
        if(tipo == TipoDeSugestao.SUGESTAO_DESCRIPTION)
        {
            for(String s: resultados_por_quant)
            {
                result = extrairDescription(s);
                if(!result.equals(""))
                {
                    temp = s+" : "+result;
                    list.add(temp);
                }
            }
            return list;
        }
        if(tipo == TipoDeSugestao.SUGESTAO_KEYWORDS)
        {
            for(String s: resultados_por_quant)
            {
                result = extrairTitleAndKeyword(s);
                if(!result.equals(""))
                {
                    temp = s+" : "+result;
                    list.add(temp);
                }
            }
            return list;
        }
        return resultados_por_quant;
    }
    
    public void resetar()
    {
        pronto = false;
        items.clear();
        resultados_por_quant.clear();
        cont = 0;
    }
    
    private static String extrairDescription(String individuo)
    {
        //System.out.println("LOG: Description STARTED");
        ArrayList<String> individuos;
        individuos = extrairDescription_parcial(individuo, "dbpedia-owl:abstract");
        
        if(individuos.isEmpty())
        {
            individuos = extrairDescription_parcial(individuo, "rdfs:comment");
        }
       
        if(individuos.isEmpty())
        {
            return "";
        }
        //System.out.println("LOG: Description ENDED");
        return individuos.get(0);
    }
    
    private static ArrayList<String> extrairDescription_parcial(String individuo, String prop)
    {
        String queryString = AbordagemPorIndividuo.getPrefixes()
                + "SELECT distinct ?title "
                + "WHERE "
                + "{<"+individuo+"> "+prop+" ?title . FILTER ( lang(?title) = \"en\") .}"
                + "LIMIT 5";
        
        QueryExecution qe = new QueryEngineHTTP("http://dbpedia.org/sparql", queryString);
                
        ArrayList<String> individuos = new ArrayList<String>();
        try
        {
            ResultSet results = qe.execSelect();
            for (; results.hasNext();)
            {
                QuerySolution s = results.next();
                individuos.add(s.getLiteral("title").getString().toString());
            }
        }
        finally
        {
           qe.close();
        }
        
        return individuos;    
    }
    
    private static String extrairTitleAndKeyword(String individuo)
    {
        //System.out.println("LOG: Title e Keyword STARTED");
        ArrayList<String> individuos;
        individuos = extrairTitleAndKeyword_parcial(individuo, "db-prop:title");
        
        if(individuos.isEmpty())
        {
            individuos = extrairTitleAndKeyword_parcial(individuo, "db-prop:name");
        }
        
        if(individuos.isEmpty())
        {
            individuos = extrairTitleAndKeyword_parcial(individuo, "foaf:name");
        }
        
        if(individuos.isEmpty())
        {
            individuos = extrairTitleAndKeyword_parcial(individuo, "rdfs:label");
        }
        
        if(individuos.isEmpty())
        {
            return "";
        }
        //System.out.println("LOG: Title e Keyword ENDED");
        return individuos.get(0);
    }
    
    private static ArrayList<String> extrairTitleAndKeyword_parcial(String individuo, String prop)
    {
        String queryString = AbordagemPorIndividuo.getPrefixes()
                + "SELECT distinct ?title "
                + "WHERE "
                + "{ <"+individuo+"> "+prop+" ?title . FILTER ( lang(?title) = \"en\") .}"
                + "LIMIT 5";
        
        QueryExecution qe = new QueryEngineHTTP("http://dbpedia.org/sparql", queryString);
                
        ArrayList<String> individuos = new ArrayList<String>();
        try
        {
            ResultSet results = qe.execSelect();
            for (; results.hasNext();)
            {
                QuerySolution s = results.next();
                individuos.add(s.getLiteral("title").getString().toString());
            }
        }
        finally
        {
           qe.close();
        }
        
        return individuos;    
    }
}


\end{lstlisting}

\section{Código Java}

\subsection{Controladora.java}

\begin{lstlisting}[frame=tb]
package artifacts;

import java.util.ArrayList;
import javax.swing.*;
import user_interface.categorias.PacoteComCampos;
import util.TipoDeSugestao;
import java.util.List;
import util.NLPTool;

public class Controladora
{
    ArtefatoEntrada artefatoEntrada;
    ArtefatoSaida artefatoSaida;
    public static int quantKeywords;
    
    public void setArtefatoEntrada(ArtefatoEntrada artefato)
    {
        artefatoEntrada = artefato;
    }
    
    public void setArtefatoSaida(ArtefatoSaida artefato)
    {
        artefatoSaida = artefato;
    }
    
    public void obterSugestoes(JTextArea text, ArrayList<PacoteComCampos> valores, TipoDeSugestao tipo)
    {
        ArrayList<String> keywords = new ArrayList<String>();
        for(PacoteComCampos p: valores)
            keywords.addAll(p.processarKeywords());

        System.out.println("keywords: "+keywords);

        quantKeywords = keywords.size();
        artefatoSaida.resetar();
        artefatoEntrada.fornecerInformacoes(keywords);
        TesteThread myRunnable = new TesteThread(text, tipo);
        Thread t = new Thread(myRunnable);
        t.start();
    }
    
    class TesteThread implements Runnable
    {
        private JTextArea field;
        private TipoDeSugestao tipo;

        public TesteThread(JTextArea field, TipoDeSugestao tipo) {
            this.field = field;
            this.tipo = tipo;
        }
        
        public void run()
        {
            try{
                while(!artefatoSaida.isReady()){
                    Thread.yield();
                }
            }catch(Exception e){}
            List<String> items = artefatoSaida.getItemsDevolvidos(tipo);
            String t = "";
            for(String s: items)
                t+=s+"\n";
            field.setText(t);
        }
    }
}

\end{lstlisting}

\subsection{NLPTool.java}

\begin{lstlisting}[frame=tb]
package util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Set;
import java.util.HashSet;
import java.io.IOException;
import org.apache.lucene.util.*;
import org.apache.lucene.analysis.*;
import java.io.StringReader;
import org.apache.lucene.analysis.standard.ClassicTokenizer;
import org.apache.lucene.analysis.standard.StandardTokenizer;
import org.apache.lucene.analysis.tokenattributes.*;
import org.apache.lucene.analysis.en.EnglishAnalyzer;

public class NLPTool
{
    public static String toLowerCase(String s)
    {
        return s.toLowerCase();
    }
    
    public static ArrayList<String> toLowerCase(ArrayList<String> array)
    {
        ArrayList<String> result = new ArrayList<String>();
        for(int i = 0; i < array.size(); i++)
        {
            result.add(array.get(i).toLowerCase());
        }
        return result;
    }
    
    public static ArrayList<String> separateWords(String sentence)
    {
        String[] t = sentence.split(" ");
        return new ArrayList(Arrays.asList(t));
    }
    
    public static void removeEmptyStrings(ArrayList<String> words)
    {
        for(int i=0; i < words.size(); i++)
            if(words.get(i).trim().isEmpty())
            {
                words.remove(i);
                i--;
            }
    }
    
    public static ArrayList<String> separateStringsByDotComma(ArrayList<String> words)
    {
        String[] keywords;
        ArrayList<String> temp = new ArrayList<String>();
        ArrayList<String> temp2 = new ArrayList<String>();
        for(int i=0; i < words.size(); i++)
        {
            keywords = words.get(i).split(";+");
            temp.addAll(Arrays.asList(keywords));
        }
        
        for(String s: temp)
        {
            temp2.add(s.trim());
        }
        
        removeEmptyStrings(temp2);
        
        return temp2;
    }
    
    public static ArrayList<String> stopWordsRemoval(String input)
    {
        // tokenize the input string
        TokenStream tokenStream = new ClassicTokenizer(Version.LUCENE_35, new StringReader(input));
        // remove stop words
        tokenStream = new StopFilter(Version.LUCENE_35, tokenStream, EnglishAnalyzer.getDefaultStopSet());

        // retrieve the remaining tokens
        Set<String> tokens = new HashSet<String>();
        CharTermAttribute token = tokenStream.getAttribute(CharTermAttribute.class);
        try {
            while (tokenStream.incrementToken()) {
                tokens.add(token.toString());
            }
        } catch (IOException e) {
            System.out.println(e);
        }
        
        ArrayList<String> array = new ArrayList<String>();
        for(String s: tokens)
        {
            if(!s.toLowerCase().equals("my") && !s.toLowerCase().equals("has") && !s.toLowerCase().equals("was")
                    && !s.toLowerCase().equals("does") && !s.toLowerCase().equals("goes") && !s.toLowerCase().equals("dies")
                    && !s.toLowerCase().equals("yes") && !s.toLowerCase().equals("gets") && !s.toLowerCase().equals("its")
                    && !s.toLowerCase().equals("he") && !s.toLowerCase().equals("she") && !s.toLowerCase().equals("it")
                    && !s.toLowerCase().equals("we") && !s.toLowerCase().equals("they") && !s.toLowerCase().equals("you"))
                array.add(stripEnglishPlural(s));
        }
        
        return array;
    }

        
    private static String stripEnglishPlural(String word)
    { 
        if ( word.endsWith("sses") || 
            word.endsWith("xes") || 
            word.endsWith("hes") )
        { 
            // remove 'es' 
            return word.substring(0,word.length()-2); 
        } 
        else if ( word.endsWith("ies") )
        { 
            // remove 'ies', replace with 'y' 
            return word.substring(0,word.length()-3)+'y'; 
        } 
        else if ( word.endsWith("s") && 
        !word.endsWith("ss") && 
        !word.endsWith("is") && 
        !word.endsWith("us") && 
        !word.endsWith("pos") ) { 
        // remove 's' 
            return word.substring(0,word.length()-1); 
        } 
        return word; 
    } 
}

\end{lstlisting}

\subsection{Rank.java}

\begin{lstlisting}[frame=tb]
package util;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;

public class Rank
{
    /*public static List<String> rankBySimilarity(int quant, ArrayList<String> keywords,  ArrayList<String> individuos) // INCOMPLETO
    {
        
    }*/
    
    public static List<String> rankByQuant(int quant, ArrayList<String> individuos)
    {
        if(individuos.isEmpty())
            return new ArrayList<String>();
        Collections.sort(individuos);
        Hashtable<String, Double> ranked = new Hashtable<String, Double>();
        double points;
        for(int i = 0; i < individuos.size(); i++)
        {
            ranked.put(individuos.get(i), 0.0);
        }
        for(int i = 0; i < individuos.size(); i++)
        {
            points = 1;
            ranked.put(individuos.get(i), ranked.get(individuos.get(i)) + points);
        }
        
        ArrayList<String> s_ranked = sortValue(ranked, false);
        if(quant > s_ranked.size())
            quant = s_ranked.size();
        return s_ranked.subList(0, quant);
    }
    
    public static List<String> rankByQuant(int quant, ArrayList<String> individuos, ArrayList<String> less_value, ArrayList<String> more_value)
    {
        if(individuos.isEmpty())
            return new ArrayList<String>();
        Collections.sort(individuos);
        Hashtable<String, Double> ranked = new Hashtable<String, Double>();
        double points;
        for(int i = 0; i < individuos.size(); i++)
        {
            ranked.put(individuos.get(i), 0.0);
        }
        for(int i = 0; i < individuos.size(); i++)
        {
            points = 1;
            if(less_value.contains(individuos.get(i)))
            {
                points = 0.8;
                less_value.remove(individuos.get(i));
                //System.out.println("LESS points: "+individuos.get(i));
            }else if(more_value.contains(individuos.get(i)))
            {
                points = 1.3;
                more_value.remove(individuos.get(i));
                //System.out.println("MORE points: "+individuos.get(i));
            }
            //else
            //{
            //    System.out.println("REGULAR points: "+individuos.get(i));
            //}
            ranked.put(individuos.get(i), ranked.get(individuos.get(i)) + points);
        }
        
        ArrayList<String> s_ranked = sortValue(ranked, false);
        if(quant > s_ranked.size())
            quant = s_ranked.size();
        return s_ranked.subList(0, quant);
    }

     private static ArrayList<String> sortValue(Hashtable<String, Double> t, boolean output){

       //Transfer as List and sort it
       ArrayList<Map.Entry<String, Double>> l = new ArrayList(t.entrySet());
       Collections.sort(l, new Comparator<Map.Entry<String, Double>>(){

         public int compare(Map.Entry<String, Double> o1, Map.Entry<String, Double> o2) {
            return -o1.getValue().compareTo(o2.getValue());
        }});

       ArrayList<String> s = new ArrayList<String>();
       for(Map.Entry<String, Double> entry: l)
       {
           if(!output)
               s.add(entry.getKey().toString());
           else
               s.add(entry.toString());
       }
       return s;
    }
}

\end{lstlisting}

\subsection{enums}

\begin{lstlisting}[frame=tb]
package util;

public enum TipoDeCategoria {
    GeneralParaOBAA, LifeCycleFull, RightsFull
}


package util;

public enum TipoDeSugestao {
    SUGESTAO_TITLE, SUGESTAO_DESCRIPTION, SUGESTAO_KEYWORDS
}

\end{lstlisting}

\section{Código da GUI}

\subsection{Main.java}

\begin{lstlisting}[frame=tb]
package user_interface;

import artifacts.Controladora;

public class Main
{
    public static Controladora control = new Controladora();
    
    public static void main(String args[])
    {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new MainFrame().setVisible(true);
            }
        });
    }
}

\end{lstlisting}

\subsection{MainFrame.java}

\begin{lstlisting}[frame=tb]
package user_interface;

import java.awt.Color;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.JOptionPane;

public class MainFrame extends javax.swing.JFrame {

    final static String ADEQUACAO_PROFILE_PANEL = "Card with Perfil AdequaÃ§Ã£o";
    final static String MINIMUM_OBAA_PROFILE_PANEL = "Card with OBAA MÃ­nimo Profile";
    final static String IDEAL_OBAA_PROFILE_PANEL = "Card with OBAA Ideal Profile";
    
    ProfileAdequacao profileAdequacao = new ProfileAdequacao();
    ProfileOBAAMinimo profileOBAAMin = new ProfileOBAAMinimo();
    ProfileOBAAIdeal profileOBAAIdeal = new ProfileOBAAIdeal();
    
    public MainFrame() {
        initComponents();
        buttonGroupProfiles.add(jRadioButtonMenuItemProfileAdequacao);
        buttonGroupProfiles.add(jRadioButtonMenuItemProfileOBAAMinimo);
        buttonGroupProfiles.add(jRadioButtonMenuItemProfileOBAAIdeal);
        jRadioButtonMenuItemProfileOBAAMinimo.setEnabled(true);
        jPanelCards.setLayout(new CardLayout());
        jPanelCards.add(profileAdequacao, ADEQUACAO_PROFILE_PANEL);
        jPanelCards.add(profileOBAAMin, MINIMUM_OBAA_PROFILE_PANEL);
        jPanelCards.add(profileOBAAIdeal, IDEAL_OBAA_PROFILE_PANEL);
        jLabelProfileName.setText("Perfil CompatÃ­vel MÃ­nimo com OBAA (PM-OBAA-CORE)");
        CardLayout cl = (CardLayout)(jPanelCards.getLayout());
        cl.show(jPanelCards, MINIMUM_OBAA_PROFILE_PANEL);
    }
 
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroupProfiles = new javax.swing.ButtonGroup();
        jLabel1 = new javax.swing.JLabel();
        jPanelCards = new javax.swing.JPanel();
        jLabelProfileName = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenuItemNewFile = new javax.swing.JMenuItem();
        jMenuItemOpenFile = new javax.swing.JMenuItem();
        jMenuItemSaveFile = new javax.swing.JMenuItem();
        jMenuItemSaveFileAs = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        jMenuItemGenerateXMLFile = new javax.swing.JMenuItem();
        jSeparator2 = new javax.swing.JPopupMenu.Separator();
        jMenuItemExit = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        jRadioButtonMenuItemProfileAdequacao = new javax.swing.JRadioButtonMenuItem();
        jRadioButtonMenuItemProfileOBAAMinimo = new javax.swing.JRadioButtonMenuItem();
        jRadioButtonMenuItemProfileOBAAIdeal = new javax.swing.JRadioButtonMenuItem();
        jMenu3 = new javax.swing.JMenu();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Ferramenta de Autoria de Metadados de Objetos de Aprendizagem");

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel1.setText("Current Metadata Profile:");

        javax.swing.GroupLayout jPanelCardsLayout = new javax.swing.GroupLayout(jPanelCards);
        jPanelCards.setLayout(jPanelCardsLayout);
        jPanelCardsLayout.setHorizontalGroup(
            jPanelCardsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1125, Short.MAX_VALUE)
        );
        jPanelCardsLayout.setVerticalGroup(
            jPanelCardsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 653, Short.MAX_VALUE)
        );

        jLabelProfileName.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        jLabelProfileName.setText("profile_name");

        jMenu1.setText("File");

        jMenuItemNewFile.setText("New File");
        jMenu1.add(jMenuItemNewFile);

        jMenuItemOpenFile.setText("Open FIle");
        jMenu1.add(jMenuItemOpenFile);

        jMenuItemSaveFile.setText("Save File");
        jMenu1.add(jMenuItemSaveFile);

        jMenuItemSaveFileAs.setText("Save File As");
        jMenu1.add(jMenuItemSaveFileAs);
        jMenu1.add(jSeparator1);

        jMenuItemGenerateXMLFile.setText("Generate XML File");
        jMenu1.add(jMenuItemGenerateXMLFile);
        jMenu1.add(jSeparator2);

        jMenuItemExit.setText("Exit");
        jMenuItemExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemExitActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItemExit);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Profiles");

        jRadioButtonMenuItemProfileAdequacao.setText("Perfil AdequaÃ§Ã£o");
        jRadioButtonMenuItemProfileAdequacao.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonMenuItemProfileAdequacaoActionPerformed(evt);
            }
        });
        jMenu2.add(jRadioButtonMenuItemProfileAdequacao);

        jRadioButtonMenuItemProfileOBAAMinimo.setSelected(true);
        jRadioButtonMenuItemProfileOBAAMinimo.setText("OBAA MÃ­nimo");
        jRadioButtonMenuItemProfileOBAAMinimo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonMenuItemProfileOBAAMinimoActionPerformed(evt);
            }
        });
        jMenu2.add(jRadioButtonMenuItemProfileOBAAMinimo);

        jRadioButtonMenuItemProfileOBAAIdeal.setText("OBAA Ideal");
        jRadioButtonMenuItemProfileOBAAIdeal.setToolTipText("");
        jRadioButtonMenuItemProfileOBAAIdeal.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonMenuItemProfileOBAAIdealActionPerformed(evt);
            }
        });
        jMenu2.add(jRadioButtonMenuItemProfileOBAAIdeal);

        jMenuBar1.add(jMenu2);

        jMenu3.setText("About");
        jMenuBar1.add(jMenu3);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanelCards, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabelProfileName)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabelProfileName))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanelCards, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(49, Short.MAX_VALUE))
        );

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-1167)/2, (screenSize.height-815)/2, 1167, 815);
    }// </editor-fold>//GEN-END:initComponents

    private void jRadioButtonMenuItemProfileAdequacaoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonMenuItemProfileAdequacaoActionPerformed
        CardLayout cl = (CardLayout)(jPanelCards.getLayout());
        cl.show(jPanelCards, ADEQUACAO_PROFILE_PANEL);
        jLabelProfileName.setText("Perfil AdequaÃ§Ã£o (PM-ADEQ-BASE)");
    }//GEN-LAST:event_jRadioButtonMenuItemProfileAdequacaoActionPerformed

    private void jRadioButtonMenuItemProfileOBAAMinimoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonMenuItemProfileOBAAMinimoActionPerformed
        CardLayout cl = (CardLayout)(jPanelCards.getLayout());
        cl.show(jPanelCards, MINIMUM_OBAA_PROFILE_PANEL);
        jLabelProfileName.setText("Perfil CompatÃ­vel MÃ­nimo com OBAA (PM-OBAA-CORE)");
    }//GEN-LAST:event_jRadioButtonMenuItemProfileOBAAMinimoActionPerformed

    private void jMenuItemExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemExitActionPerformed
        System.exit(0);
    }//GEN-LAST:event_jMenuItemExitActionPerformed

    private void jRadioButtonMenuItemProfileOBAAIdealActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonMenuItemProfileOBAAIdealActionPerformed
        CardLayout cl = (CardLayout)(jPanelCards.getLayout());
        cl.show(jPanelCards, IDEAL_OBAA_PROFILE_PANEL);
        jLabelProfileName.setText("Perfil CompatÃ­vel Ideal com OBAA (PM-OBAA-FULL)");
    }//GEN-LAST:event_jRadioButtonMenuItemProfileOBAAIdealActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroupProfiles;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabelProfileName;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenu jMenu3;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItemExit;
    private javax.swing.JMenuItem jMenuItemGenerateXMLFile;
    private javax.swing.JMenuItem jMenuItemNewFile;
    private javax.swing.JMenuItem jMenuItemOpenFile;
    private javax.swing.JMenuItem jMenuItemSaveFile;
    private javax.swing.JMenuItem jMenuItemSaveFileAs;
    private javax.swing.JPanel jPanelCards;
    private javax.swing.JRadioButtonMenuItem jRadioButtonMenuItemProfileAdequacao;
    private javax.swing.JRadioButtonMenuItem jRadioButtonMenuItemProfileOBAAIdeal;
    private javax.swing.JRadioButtonMenuItem jRadioButtonMenuItemProfileOBAAMinimo;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    private javax.swing.JPopupMenu.Separator jSeparator2;
    // End of variables declaration//GEN-END:variables
}

\end{lstlisting}

\subsection{Profile.java}

\begin{lstlisting}[frame=tb]
package user_interface;

import util.TipoDeSugestao;

public interface Profile {
    public void gerarSugestoes(TipoDeSugestao tipo);
}

\end{lstlisting}

\subsection{ProfileAdequacao.java}

\begin{lstlisting}[frame=tb]
package user_interface;
import java.awt.Color;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import util.TipoDeSugestao;

public class ProfileAdequacao extends javax.swing.JPanel implements Profile
{

    public ProfileAdequacao() {
        initComponents();
        jTableIdentifier.getColumnModel().getColumn(0).setMinWidth(270);
        jTableIdentifier.getColumnModel().getColumn(0).setMaxWidth(270);
        jTableIdentifier.setShowGrid(true);
        jTableIdentifier.setGridColor(new Color(0,0,153));
        jTableIdentifier.setTableHeader(null);
    }
    
    @Override
    public void gerarSugestoes(TipoDeSugestao tipo){}
    
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTabbedPane = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jTextField1 = new javax.swing.JTextField();
        jTextFieldGeneralIdentifierAgents = new javax.swing.JTextField();
        jLabel11 = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        jLabel14 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTableIdentifier = new javax.swing.JTable();
        jButtonTableIdentifierAdd = new javax.swing.JButton();
        jButtonTableIdentifierDel = new javax.swing.JButton();
        jLabel15 = new javax.swing.JLabel();
        jPanel2 = new javax.swing.JPanel();
        jLabel9 = new javax.swing.JLabel();
        jTextFieldTechLocation = new javax.swing.JTextField();
        jLabel10 = new javax.swing.JLabel();
        jPanel3 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel5 = new javax.swing.JLabel();
        jSeparator1 = new javax.swing.JSeparator();
        jLabel6 = new javax.swing.JLabel();
        jLabel17 = new javax.swing.JLabel();
        jLabel16 = new javax.swing.JLabel();
        jLabel18 = new javax.swing.JLabel();
        jSeparator2 = new javax.swing.JSeparator();
        jLabel19 = new javax.swing.JLabel();
        jLabel20 = new javax.swing.JLabel();

        setPreferredSize(new java.awt.Dimension(1148, 744));

        jPanel1.setToolTipText("");
        jPanel1.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N

        jLabel7.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel7.setText("1. Identifier:");

        jLabel8.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel8.setToolTipText("<html>A globally unique label that identifies this learning object.</html>");

        jTextFieldGeneralIdentifierAgents.setEditable(false);
        jTextFieldGeneralIdentifierAgents.setBackground(new java.awt.Color(204, 204, 204));
        jTextFieldGeneralIdentifierAgents.setText("sem sugestoes");

        jLabel11.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel11.setText("1.1. Catalog");

        jLabel12.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel12.setText("1.2. Entry");

        jLabel13.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel13.setToolTipText("<html>The name or designator of the identification or cataloging\nscheme for this entry. A namespace scheme.<br><br>\ne.g: \"ISBN\", \"ARIADNE\", \"URI\"</html>");

        jLabel14.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel14.setToolTipText("<html>\nThe value of the identifier within the identification<br>\nor cataloging scheme that designates or identifies<br>\nthis learning object. A namespace specific string.<br>\n<br>\ne.g: \"2-7342-0318\", \"LEAO875\",<br>\n\"http://www.ieee.org/documents/1234\"\n</html>");

        jTableIdentifier.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 153)));
        jTableIdentifier.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jTableIdentifier.setModel(new javax.swing.table.DefaultTableModel(1,2));
        jTableIdentifier.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_LAST_COLUMN);
        jTableIdentifier.setRowHeight(24);
        jTableIdentifier.setSelectionBackground(new java.awt.Color(199, 230, 251));
        jTableIdentifier.setSelectionForeground(new java.awt.Color(0, 0, 0));
        jTableIdentifier.getTableHeader().setReorderingAllowed(false);
        jScrollPane2.setViewportView(jTableIdentifier);
        jTableIdentifier.getColumnModel().getColumn(0).setResizable(false);
        jTableIdentifier.getColumnModel().getColumn(1).setResizable(false);

        jButtonTableIdentifierAdd.setText("+");
        jButtonTableIdentifierAdd.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonTableIdentifierAddActionPerformed(evt);
            }
        });

        jButtonTableIdentifierDel.setText("-");
        jButtonTableIdentifierDel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonTableIdentifierDelActionPerformed(evt);
            }
        });

        jLabel15.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel15.setText("Exemplo:");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel7)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel8))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 715, Short.MAX_VALUE)
                                    .addGroup(jPanel1Layout.createSequentialGroup()
                                        .addComponent(jLabel11)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jLabel13)
                                        .addGap(168, 168, 168)
                                        .addComponent(jLabel12)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jLabel14)
                                        .addGap(310, 310, 310)))))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jButtonTableIdentifierAdd, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jButtonTableIdentifierDel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap(358, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 257, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextFieldGeneralIdentifierAgents, javax.swing.GroupLayout.PREFERRED_SIZE, 257, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel15)
                        .addGap(0, 0, Short.MAX_VALUE))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(jLabel7))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel8)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(jLabel11)
                        .addComponent(jLabel13))
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(jLabel12)
                        .addComponent(jLabel14)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 75, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jButtonTableIdentifierAdd)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonTableIdentifierDel)))
                .addGap(259, 259, 259)
                .addComponent(jLabel15)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jTextFieldGeneralIdentifierAgents, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(268, Short.MAX_VALUE))
        );

        jTabbedPane.addTab("<html><b>1. General</b></html>", jPanel1);

        jPanel2.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N

        jLabel9.setFont(new java.awt.Font("Tahoma", 2, 14)); // NOI18N
        jLabel9.setText("3. Location:");

        jLabel10.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel10.setToolTipText("<html>LocalizaÃ§Ã£o fÃ­sica do objeto e seus conteÃºdos (ex.: URL, URI).<br><br>\nCaso haja mais de uma localizaÃ§Ã£o separe os valores com ;</html>");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel9)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel10)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextFieldTechLocation, javax.swing.GroupLayout.PREFERRED_SIZE, 544, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(485, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel10)
                    .addComponent(jTextFieldTechLocation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel9))
                .addContainerGap(679, Short.MAX_VALUE))
        );

        jTabbedPane.addTab("<html><i>4. Technical</i></html>", jPanel2);

        jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        jLabel1.setText("Legenda:");

        jLabel2.setFont(new java.awt.Font("Tahoma", 2, 13)); // NOI18N
        jLabel2.setText("- campo opcional");

        jLabel3.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jLabel3.setText("- campo obrigatorio");

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel4.setText("Perfil AdequaÃ§Ã£o (PM-ADEQ-BASE)");

        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        jTextArea1.setEditable(false);
        jTextArea1.setColumns(20);
        jTextArea1.setLineWrap(true);
        jTextArea1.setRows(5);
        jTextArea1.setText("Este perfil consiste em uma quantidade mi­nima de informacoes que podem ser registradas a respeito de um determinado objeto. O uso pretendido deste perfil e apenas para situacoes onde nada mais se conhece a respeito de um dado objeto alem de seu identificador unico e sua localizacao (URL) em um dado repositorio. Essas situacoes podem ocorrer, por exemplo, no caso do armazenamento (possivelmente temporario) de objetos legados que ainda nao foram analisados.");
        jTextArea1.setWrapStyleWord(true);
        jScrollPane1.setViewportView(jTextArea1);

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jLabel5.setText("Referencia:");

        jLabel6.setText("Relatorio Tecnico RT-OBAA-01");

        jLabel17.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel17.setText("1. General");

        jLabel16.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel16.setToolTipText("<html>This category groups the general information<br>\nthat describes this learning object as a whole.</html>");

        jLabel18.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel18.setText("Categorias:");

        jLabel19.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel19.setText("4. Technical");

        jLabel20.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel20.setToolTipText("<html>This category describes the technical<br>\nrequirements and characteristics of this<br>\nlearning object.</html>");

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jLabel1)
                        .addComponent(jLabel3)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 626, Short.MAX_VALUE)
                        .addComponent(jLabel4)
                        .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 379, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGroup(jPanel3Layout.createSequentialGroup()
                            .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addGroup(jPanel3Layout.createSequentialGroup()
                                    .addComponent(jLabel17)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jLabel16))
                                .addComponent(jLabel5))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jLabel6))
                        .addComponent(jLabel18)
                        .addComponent(jSeparator2))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jLabel19)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel20)))
                .addContainerGap(505, Short.MAX_VALUE))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2)
                .addGap(72, 72, 72)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 243, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(jLabel6))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel18)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel17)
                    .addComponent(jLabel16))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel19)
                    .addComponent(jLabel20))
                .addContainerGap(124, Short.MAX_VALUE))
        );

        jTabbedPane.addTab("?", jPanel3);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTabbedPane, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 1148, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTabbedPane, javax.swing.GroupLayout.Alignment.TRAILING)
        );

        jTabbedPane.getAccessibleContext().setAccessibleName("<html><b>?</b></html>");
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonTableIdentifierAddActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonTableIdentifierAddActionPerformed
        if(jTableIdentifier.getRowCount() == 10)
        {
            JOptionPane.showMessageDialog(this, "VocÃª nÃ£o pode ter mais de 10 linhas na tabela!", "Aviso", JOptionPane.WARNING_MESSAGE);
            return;
        }
        DefaultTableModel model = (DefaultTableModel)jTableIdentifier.getModel();
        model.addRow(new String[2]);
    }//GEN-LAST:event_jButtonTableIdentifierAddActionPerformed

    private void jButtonTableIdentifierDelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonTableIdentifierDelActionPerformed
        if(jTableIdentifier.getRowCount() == 1)
        {
            JOptionPane.showMessageDialog(this, "VocÃª nÃ£o pode ter deletar a Ãºltima linha de uma tabela!", "Aviso", JOptionPane.WARNING_MESSAGE);
            return;
        }
        if(jTableIdentifier.getSelectedRow() == -1)
        {
            JOptionPane.showMessageDialog(this, "VocÃª precisa selecionar a linha que deseja deletar!", "Aviso", JOptionPane.WARNING_MESSAGE);
            return;
        } 
        
        DefaultTableModel model = (DefaultTableModel)jTableIdentifier.getModel();
        model.removeRow(jTableIdentifier.getSelectedRow());
    }//GEN-LAST:event_jButtonTableIdentifierDelActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonTableIdentifierAdd;
    private javax.swing.JButton jButtonTableIdentifierDel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel19;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel20;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JTabbedPane jTabbedPane;
    private javax.swing.JTable jTableIdentifier;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextFieldGeneralIdentifierAgents;
    private javax.swing.JTextField jTextFieldTechLocation;
    // End of variables declaration//GEN-END:variables
}
\end{lstlisting}

\subsection{ProfileOBAAIdeal.java}

\begin{lstlisting}[frame=tb]
package user_interface;

import java.awt.GridLayout;
import user_interface.categorias.JPanelGeneralParaOBAA;
import user_interface.categorias.JPanelLifeCycleFull;
import user_interface.categorias.JPanelRightsFull;
import util.TipoDeSugestao;

public class ProfileOBAAIdeal extends javax.swing.JPanel implements Profile{

    public ProfileOBAAIdeal() {
        initComponents();
        jPanelLifeCycle.setLayout(new GridLayout());
        jPanelLifeCycle.add(new JPanelLifeCycleFull(this));
        jPanelGeneral.setLayout(new GridLayout());
        jPanelGeneral.add(new JPanelGeneralParaOBAA(this));
        jPanelRights.setLayout(new GridLayout());
        jPanelRights.add(new JPanelRightsFull(this));
    }

    public void gerarSugestoes(TipoDeSugestao tipo)
    {
        // INCOMPLETO
    }
    
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTabbedPane = new javax.swing.JTabbedPane();
        jPanelGeneral = new javax.swing.JPanel();
        jPanelLifeCycle = new javax.swing.JPanel();
        jPanel8 = new javax.swing.JPanel();
        jPanel3 = new javax.swing.JPanel();
        jPanel4 = new javax.swing.JPanel();
        jPanelRights = new javax.swing.JPanel();
        jPanel6 = new javax.swing.JPanel();
        jPanel7 = new javax.swing.JPanel();
        jPanel9 = new javax.swing.JPanel();
        jPanel10 = new javax.swing.JPanel();
        jPanel12 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel5 = new javax.swing.JLabel();
        jSeparator1 = new javax.swing.JSeparator();
        jLabel6 = new javax.swing.JLabel();
        jPanel11 = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jLabel11 = new javax.swing.JLabel();
        jSeparator2 = new javax.swing.JSeparator();
        jLabel12 = new javax.swing.JLabel();
        jSeparator3 = new javax.swing.JSeparator();
        jLabel18 = new javax.swing.JLabel();
        jLabel17 = new javax.swing.JLabel();
        jLabel19 = new javax.swing.JLabel();
        jLabel16 = new javax.swing.JLabel();
        jLabel20 = new javax.swing.JLabel();
        jLabel21 = new javax.swing.JLabel();
        jLabel22 = new javax.swing.JLabel();
        jSeparator4 = new javax.swing.JSeparator();
        jLabel25 = new javax.swing.JLabel();
        jLabel26 = new javax.swing.JLabel();
        jLabel27 = new javax.swing.JLabel();
        jLabel28 = new javax.swing.JLabel();
        jLabel29 = new javax.swing.JLabel();
        jLabel30 = new javax.swing.JLabel();
        jLabel31 = new javax.swing.JLabel();
        jLabel32 = new javax.swing.JLabel();
        jLabel33 = new javax.swing.JLabel();
        jLabel34 = new javax.swing.JLabel();
        jLabel35 = new javax.swing.JLabel();
        jLabel36 = new javax.swing.JLabel();
        jLabel37 = new javax.swing.JLabel();
        jLabel38 = new javax.swing.JLabel();
        jSeparator5 = new javax.swing.JSeparator();

        javax.swing.GroupLayout jPanelGeneralLayout = new javax.swing.GroupLayout(jPanelGeneral);
        jPanelGeneral.setLayout(jPanelGeneralLayout);
        jPanelGeneralLayout.setHorizontalGroup(
            jPanelGeneralLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1167, Short.MAX_VALUE)
        );
        jPanelGeneralLayout.setVerticalGroup(
            jPanelGeneralLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 740, Short.MAX_VALUE)
        );

        jTabbedPane.addTab("<html><b>1. General</b></html>", jPanelGeneral);

        javax.swing.GroupLayout jPanelLifeCycleLayout = new javax.swing.GroupLayout(jPanelLifeCycle);
        jPanelLifeCycle.setLayout(jPanelLifeCycleLayout);
        jPanelLifeCycleLayout.setHorizontalGroup(
            jPanelLifeCycleLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1167, Short.MAX_VALUE)
        );
        jPanelLifeCycleLayout.setVerticalGroup(
            jPanelLifeCycleLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 740, Short.MAX_VALUE)
        );

        jTabbedPane.addTab("<html><b>2. LifeCycle</b></html>", jPanelLifeCycle);

        javax.swing.GroupLayout jPanel8Layout = new javax.swing.GroupLayout(jPanel8);
        jPanel8.setLayout(jPanel8Layout);
        jPanel8Layout.setHorizontalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1167, Short.MAX_VALUE)
        );
        jPanel8Layout.setVerticalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 740, Short.MAX_VALUE)
        );

        jTabbedPane.addTab("<html><i>3. Meta-Metadata</i></html>", jPanel8);

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1167, Short.MAX_VALUE)
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 740, Short.MAX_VALUE)
        );

        jTabbedPane.addTab("<html><b>4. Technical</b></html>", jPanel3);

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1167, Short.MAX_VALUE)
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 740, Short.MAX_VALUE)
        );

        jTabbedPane.addTab("<html><b>5. Educational</b></html>", jPanel4);

        javax.swing.GroupLayout jPanelRightsLayout = new javax.swing.GroupLayout(jPanelRights);
        jPanelRights.setLayout(jPanelRightsLayout);
        jPanelRightsLayout.setHorizontalGroup(
            jPanelRightsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1167, Short.MAX_VALUE)
        );
        jPanelRightsLayout.setVerticalGroup(
            jPanelRightsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 740, Short.MAX_VALUE)
        );

        jTabbedPane.addTab("<html><i>6. Rights</i></html>", jPanelRights);

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1167, Short.MAX_VALUE)
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 740, Short.MAX_VALUE)
        );

        jTabbedPane.addTab("<html><i>7. Relation</i></html>", jPanel6);

        javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);
        jPanel7.setLayout(jPanel7Layout);
        jPanel7Layout.setHorizontalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1167, Short.MAX_VALUE)
        );
        jPanel7Layout.setVerticalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 740, Short.MAX_VALUE)
        );

        jTabbedPane.addTab("<html><i>8. Annotation</i></html>", jPanel7);

        javax.swing.GroupLayout jPanel9Layout = new javax.swing.GroupLayout(jPanel9);
        jPanel9.setLayout(jPanel9Layout);
        jPanel9Layout.setHorizontalGroup(
            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1167, Short.MAX_VALUE)
        );
        jPanel9Layout.setVerticalGroup(
            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 740, Short.MAX_VALUE)
        );

        jTabbedPane.addTab("<html><b>10. Acessibility</b></html>", jPanel9);

        javax.swing.GroupLayout jPanel10Layout = new javax.swing.GroupLayout(jPanel10);
        jPanel10.setLayout(jPanel10Layout);
        jPanel10Layout.setHorizontalGroup(
            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1167, Short.MAX_VALUE)
        );
        jPanel10Layout.setVerticalGroup(
            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 740, Short.MAX_VALUE)
        );

        jTabbedPane.addTab("<html><i>11. Segmentation</i></html>", jPanel10);

        jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        jLabel1.setText("Legenda:");

        jLabel2.setFont(new java.awt.Font("Tahoma", 2, 13)); // NOI18N
        jLabel2.setText("- campo opcional");

        jLabel3.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jLabel3.setText("- campo obrigatorio");

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel4.setText("Perfil Compati­vel Ideal com OBAA (PM-OBAA-FULL)");

        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        jTextArea1.setEditable(false);
        jTextArea1.setColumns(20);
        jTextArea1.setLineWrap(true);
        jTextArea1.setRows(5);
        jTextArea1.setText("O Perfil PM-OBAA-FULL consiste na quantidade ideal de informacoes que devem ser registradas sobre um objeto para que o OA contemple as diversas aplicacoes para TV Digital, dispositivos moveis e Web, garantindo conversoes de conteudo e interoperabilidade.");
        jTextArea1.setWrapStyleWord(true);
        jScrollPane1.setViewportView(jTextArea1);

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jLabel5.setText("Referencia:");

        jLabel6.setText("Relatorio Tecnico RT-OBAA-01");

        jLabel7.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        jLabel7.setText("Legenda:");

        jLabel8.setFont(new java.awt.Font("Tahoma", 2, 13)); // NOI18N
        jLabel8.setText("- campo opcional");

        jLabel9.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jLabel9.setText("- campo obrigatorio");

        jLabel10.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel10.setText("Perfil Compati­vel Mi­nimo com OBAA (PM-OBAA-CORE)");

        jScrollPane2.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        jTextArea2.setEditable(false);
        jTextArea2.setColumns(20);
        jTextArea2.setLineWrap(true);
        jTextArea2.setRows(5);
        jTextArea2.setText("O perfil PM-OBAA-CORE consiste no conjunto de metadados mi­nimos considerados essenciais para todo objeto de aprendizagem descrito conforme o padrao OBAA. A utilizacao desse conjunto visa integracao com os OAs legados, com reduzido esforco humano.");
        jTextArea2.setWrapStyleWord(true);
        jScrollPane2.setViewportView(jTextArea2);

        jLabel11.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jLabel11.setText("Referencia:");

        jLabel12.setText("Relatorio Tecnico RT-OBAA-01");

        jLabel18.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel18.setText("Categorias:");

        jLabel17.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel17.setText("1. General");

        jLabel19.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel19.setText("2. LifeCycle");

        jLabel16.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel16.setToolTipText("<html>This category groups the general information<br>\nthat describes this learning object as a whole.</html>");

        jLabel20.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel20.setToolTipText("<html>This category describes the history and<br>\ncurrent state of this learning object and those<br>\nentities that have affected this learning object<br>\nduring its evolution.</html>");

        jLabel21.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel21.setText("4. Technical");

        jLabel22.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel22.setToolTipText("<html>This category describes the technical<br>\nrequirements and characteristics of this<br>\nlearning object.</html>");

        jSeparator4.setOrientation(javax.swing.SwingConstants.VERTICAL);

        jLabel25.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel25.setText("5. Educational");

        jLabel26.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel26.setToolTipText("<html>This category describes the key educational<br>\nor pedagogic characteristics of this learning<br>\nobject.</html>");

        jLabel27.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel27.setText("6. Rights");

        jLabel28.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel28.setToolTipText("<html>This category describes the intellectual<br>\nproperty rights and conditions of use for this<br>\nlearning object.</html>");

        jLabel29.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel29.setText("7. Relation");

        jLabel30.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel30.setToolTipText("<html>This category defines the relationship<br>\nbetween this learning object and other<br>\nlearning objects, if any.<br><br>\nTo define multiple relationships, there may<br>\nbe multiple instances of this category. If there<br>\nis more than one target learning object, then<br>\neach target shall have a new relationship<br>\ninstance.</html>");

        jLabel31.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel31.setText("8. Annotation");

        jLabel32.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel32.setToolTipText("<html>This category provides comments on the<br>\neducational use of this learning object, and<br>\ninformation on when and by whom the<br>\ncomments were created.<br><br>\nThis category enables educators to share their<br>\nassessments of learning objects, suggestions<br>\nfor use, etc.</html>");

        jLabel33.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel33.setText("3. Meta-Metadata");

        jLabel34.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel34.setToolTipText("<html>This category describes this metadata record<br>\nitself (rather than the learning object that this<br>\nrecord describes).<br><br>\nThis category describes how the metadata<br>\ninstance can be identified, who created this<br>\nmetadata instance, how, when, and with what<br>\nreferences.</html>");

        jLabel35.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel35.setText("10. Acessibility");

        jLabel36.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel36.setText("11. Segmentation");

        jLabel37.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel37.setToolTipText("<html>Grupo de metadados com informacoes de<br>\nsegmentacao dos conteudos do objeto.</html>");

        jLabel38.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel38.setToolTipText("<html>Grupo de metadados com informacoes<br>\nde acessibilidade do objeto.</html>");

        jSeparator5.setOrientation(javax.swing.SwingConstants.VERTICAL);

        javax.swing.GroupLayout jPanel11Layout = new javax.swing.GroupLayout(jPanel11);
        jPanel11.setLayout(jPanel11Layout);
        jPanel11Layout.setHorizontalGroup(
            jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel11Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel7)
                    .addComponent(jLabel9)
                    .addComponent(jLabel8, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel10)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 626, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel11Layout.createSequentialGroup()
                        .addComponent(jLabel11)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel12))
                    .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 379, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel11Layout.createSequentialGroup()
                        .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel18)
                            .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, 275, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(jPanel11Layout.createSequentialGroup()
                                .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(jPanel11Layout.createSequentialGroup()
                                        .addComponent(jLabel17)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(jLabel16)
                                        .addGap(65, 65, 65))
                                    .addGroup(jPanel11Layout.createSequentialGroup()
                                        .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addGroup(jPanel11Layout.createSequentialGroup()
                                                .addComponent(jLabel19)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(jLabel20))
                                            .addGroup(jPanel11Layout.createSequentialGroup()
                                                .addComponent(jLabel21)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(jLabel22))
                                            .addGroup(jPanel11Layout.createSequentialGroup()
                                                .addComponent(jLabel33)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(jLabel34)))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                                .addComponent(jSeparator4, javax.swing.GroupLayout.PREFERRED_SIZE, 16, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(jPanel11Layout.createSequentialGroup()
                                        .addComponent(jLabel25)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jLabel26))
                                    .addGroup(jPanel11Layout.createSequentialGroup()
                                        .addComponent(jLabel27)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jLabel28))
                                    .addGroup(jPanel11Layout.createSequentialGroup()
                                        .addComponent(jLabel29)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jLabel30))
                                    .addGroup(jPanel11Layout.createSequentialGroup()
                                        .addComponent(jLabel31)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jLabel32)))
                                .addGap(11, 11, 11)))
                        .addGap(18, 18, 18)
                        .addComponent(jSeparator5, javax.swing.GroupLayout.PREFERRED_SIZE, 16, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel11Layout.createSequentialGroup()
                                .addComponent(jLabel35)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel38))
                            .addGroup(jPanel11Layout.createSequentialGroup()
                                .addComponent(jLabel36)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel37)))))
                .addContainerGap(505, Short.MAX_VALUE))
        );
        jPanel11Layout.setVerticalGroup(
            jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel11Layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addComponent(jLabel7)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel9)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel8)
                .addGap(72, 72, 72)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jLabel10)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 243, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel11)
                    .addComponent(jLabel12))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel18)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jSeparator4)
                        .addGroup(jPanel11Layout.createSequentialGroup()
                            .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel25)
                                .addComponent(jLabel26))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel27)
                                .addComponent(jLabel28))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel29)
                                .addComponent(jLabel30))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel31)
                                .addComponent(jLabel32)))
                        .addGroup(jPanel11Layout.createSequentialGroup()
                            .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel17)
                                .addComponent(jLabel16))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel19)
                                .addComponent(jLabel20))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel33)
                                .addComponent(jLabel34))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel21)
                                .addComponent(jLabel22))))
                    .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jSeparator5)
                        .addGroup(jPanel11Layout.createSequentialGroup()
                            .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel35)
                                .addComponent(jLabel38))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addGroup(jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jLabel36)
                                .addComponent(jLabel37))
                            .addGap(48, 48, 48))))
                .addContainerGap(76, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout jPanel12Layout = new javax.swing.GroupLayout(jPanel12);
        jPanel12.setLayout(jPanel12Layout);
        jPanel12Layout.setHorizontalGroup(
            jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel12Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1)
                    .addComponent(jLabel3)
                    .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 626, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel12Layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel6))
                    .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 379, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(529, Short.MAX_VALUE))
            .addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel12Layout.createSequentialGroup()
                    .addContainerGap()
                    .addComponent(jPanel11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
        );
        jPanel12Layout.setVerticalGroup(
            jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel12Layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2)
                .addGap(72, 72, 72)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 243, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(jLabel6))
                .addContainerGap(250, Short.MAX_VALUE))
            .addGroup(jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel12Layout.createSequentialGroup()
                    .addContainerGap()
                    .addComponent(jPanel11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
        );

        jTabbedPane.addTab("?", jPanel12);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTabbedPane, javax.swing.GroupLayout.Alignment.TRAILING)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTabbedPane, javax.swing.GroupLayout.Alignment.TRAILING)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel19;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel20;
    private javax.swing.JLabel jLabel21;
    private javax.swing.JLabel jLabel22;
    private javax.swing.JLabel jLabel25;
    private javax.swing.JLabel jLabel26;
    private javax.swing.JLabel jLabel27;
    private javax.swing.JLabel jLabel28;
    private javax.swing.JLabel jLabel29;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel30;
    private javax.swing.JLabel jLabel31;
    private javax.swing.JLabel jLabel32;
    private javax.swing.JLabel jLabel33;
    private javax.swing.JLabel jLabel34;
    private javax.swing.JLabel jLabel35;
    private javax.swing.JLabel jLabel36;
    private javax.swing.JLabel jLabel37;
    private javax.swing.JLabel jLabel38;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel10;
    private javax.swing.JPanel jPanel11;
    private javax.swing.JPanel jPanel12;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JPanel jPanel8;
    private javax.swing.JPanel jPanel9;
    private javax.swing.JPanel jPanelGeneral;
    private javax.swing.JPanel jPanelLifeCycle;
    private javax.swing.JPanel jPanelRights;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JSeparator jSeparator4;
    private javax.swing.JSeparator jSeparator5;
    private javax.swing.JTabbedPane jTabbedPane;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    // End of variables declaration//GEN-END:variables
}

\end{lstlisting}

\subsection{ProfileOBAAMinimo.java}

\begin{lstlisting}[frame=tb]
package user_interface;

import java.awt.*;
import java.util.ArrayList;
import user_interface.categorias.Categoria;
import user_interface.categorias.JPanelGeneralParaOBAA;
import user_interface.categorias.JPanelLifeCycleFull;
import user_interface.categorias.JPanelRightsFull;
import user_interface.categorias.PacoteComCampos;
import util.TipoDeSugestao;

public class ProfileOBAAMinimo extends javax.swing.JPanel implements Profile {

    ArrayList<Categoria> categorias;
    
    public ProfileOBAAMinimo() {
        initComponents();
        
        categorias = new ArrayList<Categoria>();
        
        jPanelGeneral.setLayout(new GridLayout());
        JPanelGeneralParaOBAA generalParaOBAA = new JPanelGeneralParaOBAA(this);
        jPanelGeneral.add(generalParaOBAA);
        categorias.add(generalParaOBAA);
        
        jPanelLifeCycle.setLayout(new GridLayout());
        JPanelLifeCycleFull lifeCycleFull = new JPanelLifeCycleFull(this);
        jPanelLifeCycle.add(lifeCycleFull);
        categorias.add(lifeCycleFull);        
        
        jPanelRights.setLayout(new GridLayout());
        JPanelRightsFull rightsFull = new JPanelRightsFull(this);
        jPanelRights.add(rightsFull);
        categorias.add(rightsFull);
    }
    
    @Override
    public void gerarSugestoes(TipoDeSugestao tipo)
    {
        ArrayList<PacoteComCampos> valores_para_sugestoes = new ArrayList<PacoteComCampos>();
        for(Categoria c: categorias)
            valores_para_sugestoes.add(c.retornarCamposGeradoresDeSugestoes());
        
        boolean valido = false;
        for(PacoteComCampos pacote: valores_para_sugestoes)
        {
            for(String s: pacote.valores)
            {
                if(!s.isEmpty())
                {
                    valido = true;
                    break;
                }
            }
            if(valido)
                break;
        }
        
        if(!valido)
        {
            javax.swing.JOptionPane.showMessageDialog(this, "At least one of the fields must be filled!", "Warning", javax.swing.JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        TelaSugestoes tela = new TelaSugestoes(tipo, this);

        Main.control.obterSugestoes(tela.getTextArea(), valores_para_sugestoes, tipo);
    }

    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTabbedPane = new javax.swing.JTabbedPane();
        jPanelGeneral = new javax.swing.JPanel();
        jPanelLifeCycle = new javax.swing.JPanel();
        jPanel3 = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jTextFieldTechFormat = new javax.swing.JTextField();
        jPanelRights = new javax.swing.JPanel();
        jPanel5 = new javax.swing.JPanel();
        jPanel6 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel5 = new javax.swing.JLabel();
        jSeparator1 = new javax.swing.JSeparator();
        jLabel6 = new javax.swing.JLabel();
        jSeparator2 = new javax.swing.JSeparator();
        jLabel18 = new javax.swing.JLabel();
        jLabel17 = new javax.swing.JLabel();
        jLabel19 = new javax.swing.JLabel();
        jLabel16 = new javax.swing.JLabel();
        jLabel20 = new javax.swing.JLabel();
        jLabel21 = new javax.swing.JLabel();
        jLabel22 = new javax.swing.JLabel();
        jLabel23 = new javax.swing.JLabel();
        jLabel24 = new javax.swing.JLabel();

        setPreferredSize(new java.awt.Dimension(1148, 744));

        javax.swing.GroupLayout jPanelGeneralLayout = new javax.swing.GroupLayout(jPanelGeneral);
        jPanelGeneral.setLayout(jPanelGeneralLayout);
        jPanelGeneralLayout.setHorizontalGroup(
            jPanelGeneralLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1143, Short.MAX_VALUE)
        );
        jPanelGeneralLayout.setVerticalGroup(
            jPanelGeneralLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 714, Short.MAX_VALUE)
        );

        jTabbedPane.addTab("<html><b>1. General</b></html>", jPanelGeneral);

        javax.swing.GroupLayout jPanelLifeCycleLayout = new javax.swing.GroupLayout(jPanelLifeCycle);
        jPanelLifeCycle.setLayout(jPanelLifeCycleLayout);
        jPanelLifeCycleLayout.setHorizontalGroup(
            jPanelLifeCycleLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1143, Short.MAX_VALUE)
        );
        jPanelLifeCycleLayout.setVerticalGroup(
            jPanelLifeCycleLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 714, Short.MAX_VALUE)
        );

        jTabbedPane.addTab("<html><b>2. LifeCycle</b></html>", jPanelLifeCycle);

        jLabel7.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel7.setText("1. Format:");

        jLabel8.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel8.setToolTipText("<html>MIME type(s) of (all the components of) this learning object.<br><br>\nEx.: application/pdf; image/jpeg; text/html<br>\nLista de MIME types: http://www.iana.org/assignments/media-types<br><br>\nCaso haja mais de uma informaÃ§Ã£o separe os valores com ;\n</html>");

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel7)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel8)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextFieldTechFormat, javax.swing.GroupLayout.PREFERRED_SIZE, 412, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(618, Short.MAX_VALUE))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jTextFieldTechFormat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addGap(5, 5, 5)
                        .addComponent(jLabel7))
                    .addComponent(jLabel8))
                .addContainerGap(679, Short.MAX_VALUE))
        );

        jTabbedPane.addTab("<html><b>4. Technical</b></html>", jPanel3);

        javax.swing.GroupLayout jPanelRightsLayout = new javax.swing.GroupLayout(jPanelRights);
        jPanelRights.setLayout(jPanelRightsLayout);
        jPanelRightsLayout.setHorizontalGroup(
            jPanelRightsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1143, Short.MAX_VALUE)
        );
        jPanelRightsLayout.setVerticalGroup(
            jPanelRightsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 714, Short.MAX_VALUE)
        );

        jTabbedPane.addTab("<html><i>6. Rights</i></html>", jPanelRights);

        jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        jLabel1.setText("Legenda:");

        jLabel2.setFont(new java.awt.Font("Tahoma", 2, 13)); // NOI18N
        jLabel2.setText("- campo opcional");

        jLabel3.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jLabel3.setText("- campo obrigatorio");

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel4.setText("Perfil Compati­vel Mi­nimo com OBAA (PM-OBAA-CORE)");

        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        jTextArea1.setEditable(false);
        jTextArea1.setColumns(20);
        jTextArea1.setLineWrap(true);
        jTextArea1.setRows(5);
        jTextArea1.setText("O perfil PM-OBAA-CORE consiste no conjunto de metadados mi­nimos considerados essenciais para todo objeto de aprendizagem descrito conforme o padrao OBAA. A utilizacao desse conjunto visa integracao com os OAs legados, com reduzido esforco humano.");
        jTextArea1.setWrapStyleWord(true);
        jScrollPane1.setViewportView(jTextArea1);

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jLabel5.setText("Referencia:");

        jLabel6.setText("Relatorio Tecnico RT-OBAA-01");

        jLabel18.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel18.setText("Categorias:");

        jLabel17.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel17.setText("1. General");

        jLabel19.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel19.setText("2. LifeCycle");

        jLabel16.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel16.setToolTipText("<html>This category groups the general information<br>\nthat describes this learning object as a whole.</html>");

        jLabel20.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel20.setToolTipText("<html>This category describes the history and<br>\ncurrent state of this learning object and those<br>\nentities that have affected this learning object<br>\nduring its evolution.</html>");

        jLabel21.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel21.setText("4. Technical");

        jLabel22.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel22.setToolTipText("<html>This category describes the technical<br>\nrequirements and characteristics of this<br>\nlearning object.</html>");

        jLabel23.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel23.setText("6. Rights");

        jLabel24.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel24.setToolTipText("<html>This category describes the intellectual<br>\nproperty rights and conditions of use for this<br>\nlearning object.</html>");

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1)
                    .addComponent(jLabel3)
                    .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 626, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel6))
                    .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 379, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addGroup(jPanel6Layout.createSequentialGroup()
                            .addComponent(jLabel17)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jLabel16)
                            .addGap(182, 182, 182))
                        .addComponent(jLabel18)
                        .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 275, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addComponent(jLabel19)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel20))
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addComponent(jLabel21)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel22))
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addComponent(jLabel23)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel24)))
                .addContainerGap(505, Short.MAX_VALUE))
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2)
                .addGap(72, 72, 72)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 243, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(jLabel6))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel18)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel17)
                    .addComponent(jLabel16))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel19)
                    .addComponent(jLabel20))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel21)
                    .addComponent(jLabel22))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel23)
                    .addComponent(jLabel24))
                .addContainerGap(76, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1143, Short.MAX_VALUE)
            .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel5Layout.createSequentialGroup()
                    .addGap(0, 0, Short.MAX_VALUE)
                    .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, Short.MAX_VALUE)))
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 714, Short.MAX_VALUE)
            .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(jPanel5Layout.createSequentialGroup()
                    .addGap(0, 0, Short.MAX_VALUE)
                    .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, Short.MAX_VALUE)))
        );

        jTabbedPane.addTab("?", jPanel5);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTabbedPane, javax.swing.GroupLayout.Alignment.TRAILING)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTabbedPane, javax.swing.GroupLayout.Alignment.TRAILING)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel19;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel20;
    private javax.swing.JLabel jLabel21;
    private javax.swing.JLabel jLabel22;
    private javax.swing.JLabel jLabel23;
    private javax.swing.JLabel jLabel24;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanelGeneral;
    private javax.swing.JPanel jPanelLifeCycle;
    private javax.swing.JPanel jPanelRights;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JTabbedPane jTabbedPane;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField jTextFieldTechFormat;
    // End of variables declaration//GEN-END:variables
}

\end{lstlisting}

\subsection{TelaSugestoes.java}

\begin{lstlisting}[frame=tb]
package user_interface;

import util.TipoDeSugestao;

public class TelaSugestoes extends javax.swing.JDialog {

    public TelaSugestoes(TipoDeSugestao campoName, javax.swing.JPanel panel)
    {
        initComponents();
        jLabelCampo.setText(campoName.toString());
        this.setVisible(true);
        this.setLocationRelativeTo(panel);
        // modal?
    }
    
    public javax.swing.JTextArea getTextArea()
    {
        return jTextArea1;
    }
    
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jButtonAceitar = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabelCampo = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        jTextArea1.setEditable(false);
        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane2.setViewportView(jTextArea1);

        jButtonAceitar.setText("Ok");
        jButtonAceitar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonAceitarActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jLabel1.setText("Suggestions for");

        jLabelCampo.setText("jLabelCampo");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabelCampo)))
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(297, 297, 297)
                .addComponent(jButtonAceitar, javax.swing.GroupLayout.PREFERRED_SIZE, 96, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(308, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabelCampo))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 322, Short.MAX_VALUE)
                .addGap(13, 13, 13)
                .addComponent(jButtonAceitar)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonAceitarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonAceitarActionPerformed
        this.setVisible(false);
    }//GEN-LAST:event_jButtonAceitarActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonAceitar;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabelCampo;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables
}

\end{lstlisting}

\subsection{Categoria.java}

\begin{lstlisting}[frame=tb]
package user_interface.categorias;

public interface Categoria
{
    public PacoteComCampos retornarCamposGeradoresDeSugestoes();
}
\end{lstlisting}

\subsection{JPanelContribute.java}

\begin{lstlisting}[frame=tb]
package user_interface.categorias;

public class JPanelContribute extends javax.swing.JPanel{

    public JPanelContribute() {
        initComponents();
    }
  
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel11 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        jLabel14 = new javax.swing.JLabel();
        jLabel15 = new javax.swing.JLabel();
        jLabel16 = new javax.swing.JLabel();
        jComboBox1 = new javax.swing.JComboBox();
        jComboBox2 = new javax.swing.JComboBox();
        jComboBox3 = new javax.swing.JComboBox();
        jComboBox4 = new javax.swing.JComboBox();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jTextField1 = new javax.swing.JTextField();
        jTextField2 = new javax.swing.JTextField();
        jTextField3 = new javax.swing.JTextField();
        jTextField4 = new javax.swing.JTextField();
        jTextField5 = new javax.swing.JTextField();
        jSeparator1 = new javax.swing.JSeparator();
        jSeparator2 = new javax.swing.JSeparator();

        jLabel11.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel11.setText("3.1. Role");

        jLabel13.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel13.setToolTipText("<html>Kind of contribution.</html>");

        jLabel12.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel12.setText("3.2. Entity");

        jLabel14.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel14.setToolTipText("<html>\nThe identification of and information about<br>\nentities (i.e., people, organizations)<br>\ncontributing to this learning object. The<br>\nentities shall be ordered as most relevant first.<br>\n</html>");

        jLabel15.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel15.setText("3.3. Date");

        jLabel16.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel16.setToolTipText("<html>The date of the contribution.\n</html>");

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "author", "publisher", "unknown", "initiator", "terminator", "validator", "editor", "graphical designer", "technical implementer", "content provider", "technical validator", "educational validator", "script writer", "instructional designer", "subject matter expert" }));

        jComboBox2.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31" }));

        jComboBox3.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "jan", "fev", "mar", "abr", "maio", "jun", "jul", "ago", "set", "out", "nov", "dez" }));

        jComboBox4.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "2020", "2019", "2018", "2017", "2016", "2015", "2014", "2013", "2012", "2011", "2010", "2009", "2008", "2007", "2006", "2005", "2004", "2003", "2002", "2001", "2000", "1999", "1998", "1997", "1996", "1995", "1994", "1993", "1992", "1991", "1990", "1989", "1988", "1987", "1986", "1985", "1984", "1983", "1982", "1981", "1980" }));
        jComboBox4.setSelectedIndex(7);

        jLabel1.setText("First Name:");

        jLabel2.setText("Middle Name:");

        jLabel3.setText("Last Name:");

        jLabel4.setText("E-mail:");

        jLabel5.setText("Organization:");

        jSeparator2.setOrientation(javax.swing.SwingConstants.VERTICAL);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jSeparator1)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel15)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel16)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jComboBox2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jComboBox3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jComboBox4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel12)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel14))
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                    .addComponent(jLabel5)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jTextField5))
                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                    .addComponent(jLabel4)
                                    .addGap(41, 41, 41)
                                    .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, 194, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel1))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 148, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel2))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel3)
                                    .addComponent(jTextField4, javax.swing.GroupLayout.PREFERRED_SIZE, 156, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel11)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel13)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(18, 18, 18)
                        .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(0, 11, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel11)
                            .addComponent(jLabel13)
                            .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(23, 23, 23)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel12)
                            .addComponent(jLabel14))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jLabel2)
                                .addComponent(jLabel3))
                            .addComponent(jLabel1))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jTextField4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel4)
                            .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel5)
                            .addComponent(jTextField5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel15)
                            .addComponent(jLabel16)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jComboBox2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jComboBox3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jComboBox4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))
                    .addComponent(jSeparator2, javax.swing.GroupLayout.Alignment.TRAILING))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox jComboBox1;
    private javax.swing.JComboBox jComboBox2;
    private javax.swing.JComboBox jComboBox3;
    private javax.swing.JComboBox jComboBox4;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField2;
    private javax.swing.JTextField jTextField3;
    private javax.swing.JTextField jTextField4;
    private javax.swing.JTextField jTextField5;
    // End of variables declaration//GEN-END:variables
}

\end{lstlisting}

\subsection{JPanelGeneralParaOBAA.java}

\begin{lstlisting}[frame=tb]
package user_interface.categorias;

import java.awt.Color;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import java.util.ArrayList;
import util.TipoDeSugestao;
import user_interface.Main;
import user_interface.Profile;

public class JPanelGeneralParaOBAA extends javax.swing.JPanel implements Categoria{

    Profile profile;
    
    public JPanelGeneralParaOBAA(Profile profile) {
        initComponents();
        this.profile = profile;
        jTableIdentifier.getColumnModel().getColumn(0).setMinWidth(270);
        jTableIdentifier.getColumnModel().getColumn(0).setMaxWidth(270);
        jTableIdentifier.setShowGrid(true);
        jTableIdentifier.setGridColor(new Color(0,0,153));
        jTableIdentifier.setTableHeader(null);
    }
    
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTableIdentifier = new javax.swing.JTable();
        jLabel12 = new javax.swing.JLabel();
        jLabel14 = new javax.swing.JLabel();
        jButtonTableIdentifierAdd = new javax.swing.JButton();
        jButtonTableIdentifierDel = new javax.swing.JButton();
        jLabel9 = new javax.swing.JLabel();
        jSeparator1 = new javax.swing.JSeparator();
        jTextFieldLanguage = new javax.swing.JTextField();
        jComboBoxTitleLang = new javax.swing.JComboBox();
        jLabel10 = new javax.swing.JLabel();
        jSeparator2 = new javax.swing.JSeparator();
        jLabel15 = new javax.swing.JLabel();
        jLabel16 = new javax.swing.JLabel();
        jTextFieldTitle = new javax.swing.JTextField();
        jSeparator3 = new javax.swing.JSeparator();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextAreaDescription = new javax.swing.JTextArea();
        jComboBoxDescriptionLang = new javax.swing.JComboBox();
        jLabel17 = new javax.swing.JLabel();
        jSeparator4 = new javax.swing.JSeparator();
        jLabel2 = new javax.swing.JLabel();
        jLabel18 = new javax.swing.JLabel();
        jTextFieldKeywords = new javax.swing.JTextField();
        jComboBoxKeywordsLang = new javax.swing.JComboBox();
        jButtonSugestoesParaTitle = new javax.swing.JButton();
        jButtonSugestoesParaDescription = new javax.swing.JButton();
        jButtonSugestoesParaKeywords = new javax.swing.JButton();

        jLabel7.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel7.setText("1. Identifier:");

        jLabel8.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel8.setToolTipText("<html>A globally unique label that identifies this learning object.</html>");

        jLabel11.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel11.setText("1.1. Catalog");

        jLabel13.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel13.setToolTipText("<html>The name or designator of the identification or cataloging\nscheme for this entry. A namespace scheme.<br><br>\ne.g: \"ISBN\", \"ARIADNE\", \"URI\"</html>");

        jTableIdentifier.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 153)));
        jTableIdentifier.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jTableIdentifier.setModel(new javax.swing.table.DefaultTableModel(1,2));
        jTableIdentifier.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_LAST_COLUMN);
        jTableIdentifier.setRowHeight(24);
        jTableIdentifier.setSelectionBackground(new java.awt.Color(199, 230, 251));
        jTableIdentifier.setSelectionForeground(new java.awt.Color(0, 0, 0));
        jTableIdentifier.getTableHeader().setReorderingAllowed(false);
        jScrollPane2.setViewportView(jTableIdentifier);

        jLabel12.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel12.setText("1.2. Entry");

        jLabel14.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel14.setToolTipText("<html>\nThe value of the identifier within the identification<br>\nor cataloging scheme that designates or identifies<br>\nthis learning object. A namespace specific string.<br>\n<br>\ne.g: \"2-7342-0318\", \"LEAO875\",<br>\n\"http://www.ieee.org/documents/1234\"\n</html>");

        jButtonTableIdentifierAdd.setText("+");
        jButtonTableIdentifierAdd.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonTableIdentifierAddActionPerformed(evt);
            }
        });

        jButtonTableIdentifierDel.setText("-");
        jButtonTableIdentifierDel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonTableIdentifierDelActionPerformed(evt);
            }
        });

        jLabel9.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel9.setText("2. Title:");

        jComboBoxTitleLang.setEditable(true);
        jComboBoxTitleLang.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "en", "pt" }));

        jLabel10.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel10.setToolTipText("<html>Name given to this learning object and the language that the title is writen.</html>");

        jLabel15.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel15.setToolTipText("<html>The primary human language or languages used within this learning<br>\nobject to communicate to the intended user.<br><br>\n\nEx.: en; en-GB; fr-CA; pt-BR; pt-PT<br><br>\n\nCaso haja mais de uma informaÃ§Ã£o separe os valores com ;</html>");

        jLabel16.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel16.setText("3. Language:");

        jTextFieldTitle.setBackground(new java.awt.Color(204, 255, 204));

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel1.setText("4. Description:");

        jTextAreaDescription.setBackground(new java.awt.Color(204, 255, 204));
        jTextAreaDescription.setColumns(20);
        jTextAreaDescription.setLineWrap(true);
        jTextAreaDescription.setRows(5);
        jTextAreaDescription.setWrapStyleWord(true);
        jScrollPane1.setViewportView(jTextAreaDescription);

        jComboBoxDescriptionLang.setEditable(true);
        jComboBoxDescriptionLang.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "en", "pt" }));

        jLabel17.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel17.setToolTipText("<html>A textual description of the content of this learning object.<br><br>\n\nEx.: \"In this video clip, the life and works of Leonardo da Vinci are briefly presented. (...)</html>");

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel2.setText("5. Keywords:");

        jLabel18.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel18.setToolTipText("<html>A keyword or phrase describing the topic of this learning object.<br><br>\n\nEx.: \"Mona Lisa\"<br><br>\n\nCaso haja mais de uma informaÃ§Ã£o separe os valores com ;</html>");

        jTextFieldKeywords.setBackground(new java.awt.Color(204, 255, 204));

        jComboBoxKeywordsLang.setEditable(true);
        jComboBoxKeywordsLang.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "en", "pt" }));

        jButtonSugestoesParaTitle.setBackground(new java.awt.Color(204, 255, 204));
        jButtonSugestoesParaTitle.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jButtonSugestoesParaTitle.setForeground(new java.awt.Color(0, 102, 51));
        jButtonSugestoesParaTitle.setText("Help me!");
        jButtonSugestoesParaTitle.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonSugestoesParaTitleActionPerformed(evt);
            }
        });

        jButtonSugestoesParaDescription.setBackground(new java.awt.Color(204, 255, 204));
        jButtonSugestoesParaDescription.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jButtonSugestoesParaDescription.setForeground(new java.awt.Color(0, 102, 51));
        jButtonSugestoesParaDescription.setText("Help me!");
        jButtonSugestoesParaDescription.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonSugestoesParaDescriptionActionPerformed(evt);
            }
        });

        jButtonSugestoesParaKeywords.setBackground(new java.awt.Color(204, 255, 204));
        jButtonSugestoesParaKeywords.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jButtonSugestoesParaKeywords.setForeground(new java.awt.Color(0, 102, 51));
        jButtonSugestoesParaKeywords.setText("Help me!");
        jButtonSugestoesParaKeywords.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonSugestoesParaKeywordsActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jSeparator4)
                            .addComponent(jSeparator3)
                            .addComponent(jSeparator2)
                            .addComponent(jSeparator1)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel7)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jLabel8))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(10, 10, 10)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(jScrollPane2)
                                            .addGroup(layout.createSequentialGroup()
                                                .addComponent(jLabel11)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(jLabel13)
                                                .addGap(168, 168, 168)
                                                .addComponent(jLabel12)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(jLabel14)
                                                .addGap(310, 492, Short.MAX_VALUE)))))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jButtonTableIdentifierAdd, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jButtonTableIdentifierDel, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE))))
                        .addGap(214, 214, 214))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addComponent(jTextFieldKeywords, javax.swing.GroupLayout.PREFERRED_SIZE, 674, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jComboBoxKeywordsLang, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(jButtonSugestoesParaKeywords))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel18)))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel9)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel10))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel16)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel15))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel17))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jTextFieldTitle, javax.swing.GroupLayout.PREFERRED_SIZE, 523, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jComboBoxTitleLang, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(jButtonSugestoesParaTitle))
                                    .addComponent(jTextFieldLanguage, javax.swing.GroupLayout.PREFERRED_SIZE, 523, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 678, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(jComboBoxDescriptionLang, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(jButtonSugestoesParaDescription)))))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(5, 5, 5)
                        .addComponent(jLabel7))
                    .addComponent(jLabel8))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(jLabel11)
                        .addComponent(jLabel13))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(jLabel12)
                        .addComponent(jLabel14)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 75, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButtonTableIdentifierAdd)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonTableIdentifierDel)))
                .addGap(18, 18, 18)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel9)
                    .addComponent(jLabel10))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jComboBoxTitleLang, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jTextFieldTitle, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonSugestoesParaTitle))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel16)
                    .addComponent(jLabel15))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jTextFieldLanguage, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 79, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jComboBoxDescriptionLang, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jButtonSugestoesParaDescription))))
                    .addComponent(jLabel17))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator4, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addComponent(jLabel18))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jComboBoxKeywordsLang, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jTextFieldKeywords, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonSugestoesParaKeywords))
                .addContainerGap(195, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public PacoteComCampos retornarCamposGeradoresDeSugestoes()
    {
        ArrayList<String> campos_valores = new ArrayList<String>();
        campos_valores.add(jTextFieldTitle.getText());
        campos_valores.add(jTextAreaDescription.getText());
        campos_valores.add(jTextFieldKeywords.getText());
        
        return new PacoteComCampos(util.TipoDeCategoria.GeneralParaOBAA, campos_valores);
    }
    
    private void jButtonTableIdentifierAddActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonTableIdentifierAddActionPerformed
        if(jTableIdentifier.getRowCount() == 10)
        {
            JOptionPane.showMessageDialog(this, "VocÃª nÃ£o pode ter mais de 10 linhas na tabela!", "Aviso", JOptionPane.WARNING_MESSAGE);
            return;
        }
        DefaultTableModel model = (DefaultTableModel)jTableIdentifier.getModel();
        model.addRow(new String[2]);
    }//GEN-LAST:event_jButtonTableIdentifierAddActionPerformed

    private void jButtonTableIdentifierDelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonTableIdentifierDelActionPerformed
        if(jTableIdentifier.getRowCount() == 1)
        {
            JOptionPane.showMessageDialog(this, "VocÃª nÃ£o pode ter deletar a Ãºltima linha de uma tabela!", "Aviso", JOptionPane.WARNING_MESSAGE);
            return;
        }
        if(jTableIdentifier.getSelectedRow() == -1)
        {
            JOptionPane.showMessageDialog(this, "VocÃª precisa selecionar a linha que deseja deletar!", "Aviso", JOptionPane.WARNING_MESSAGE);
            return;
        }

        DefaultTableModel model = (DefaultTableModel)jTableIdentifier.getModel();
        model.removeRow(jTableIdentifier.getSelectedRow());
    }//GEN-LAST:event_jButtonTableIdentifierDelActionPerformed

    private void jButtonSugestoesParaTitleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonSugestoesParaTitleActionPerformed
        profile.gerarSugestoes(TipoDeSugestao.SUGESTAO_TITLE);
    }//GEN-LAST:event_jButtonSugestoesParaTitleActionPerformed

    private void jButtonSugestoesParaDescriptionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonSugestoesParaDescriptionActionPerformed
        profile.gerarSugestoes(TipoDeSugestao.SUGESTAO_DESCRIPTION);
    }//GEN-LAST:event_jButtonSugestoesParaDescriptionActionPerformed

    private void jButtonSugestoesParaKeywordsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonSugestoesParaKeywordsActionPerformed
        profile.gerarSugestoes(TipoDeSugestao.SUGESTAO_KEYWORDS);
    }//GEN-LAST:event_jButtonSugestoesParaKeywordsActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonSugestoesParaDescription;
    private javax.swing.JButton jButtonSugestoesParaKeywords;
    private javax.swing.JButton jButtonSugestoesParaTitle;
    private javax.swing.JButton jButtonTableIdentifierAdd;
    private javax.swing.JButton jButtonTableIdentifierDel;
    private javax.swing.JComboBox jComboBoxDescriptionLang;
    private javax.swing.JComboBox jComboBoxKeywordsLang;
    private javax.swing.JComboBox jComboBoxTitleLang;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JSeparator jSeparator4;
    private javax.swing.JTable jTableIdentifier;
    private javax.swing.JTextArea jTextAreaDescription;
    private javax.swing.JTextField jTextFieldKeywords;
    private javax.swing.JTextField jTextFieldLanguage;
    private javax.swing.JTextField jTextFieldTitle;
    // End of variables declaration//GEN-END:variables
}

\end{lstlisting}

\subsection{JPanelLifeCycleFull.java}

\begin{lstlisting}[frame=tb]
package user_interface.categorias;

import java.awt.GridLayout;
import java.awt.Dimension;
import java.util.ArrayList;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import user_interface.Profile;

public class JPanelLifeCycleFull extends javax.swing.JPanel implements Categoria {

    Profile profile;
    
    public JPanelLifeCycleFull(Profile profile)
    {
        initComponents();
        this.profile = profile;
        jPanelContribute.setLayout(new GridLayout(10,1));
        jPanelContribute.add(new JPanelContribute());
    }
    
    @Override
    public PacoteComCampos retornarCamposGeradoresDeSugestoes()
    {
        return new PacoteComCampos(util.TipoDeCategoria.LifeCycleFull, new ArrayList<String>());
    }

    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jTextFieldVersion = new javax.swing.JTextField();
        jComboBoxVersionLang = new javax.swing.JComboBox();
        jLabel2 = new javax.swing.JLabel();
        jComboBoxStatus = new javax.swing.JComboBox();
        jLabel3 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jSeparator1 = new javax.swing.JSeparator();
        jSeparator2 = new javax.swing.JSeparator();
        jScrollPane1 = new javax.swing.JScrollPane();
        jPanelContribute = new javax.swing.JPanel();
        jButtonAddContribute = new javax.swing.JButton();

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel1.setText("1. Version:");

        jLabel8.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel8.setToolTipText("<html>The edition of this learning object.<br><br>\nEx.: 1.2.alpha</html>");

        jTextFieldVersion.setBackground(new java.awt.Color(204, 255, 204));

        jComboBoxVersionLang.setEditable(true);
        jComboBoxVersionLang.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "en", "pt" }));

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel2.setText("2. Status:");

        jComboBoxStatus.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "draft", "final", "revised", "unavailable" }));
        jComboBoxStatus.setSelectedIndex(1);

        jLabel3.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel3.setText("3. Contribute:");

        jLabel9.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel9.setToolTipText("<html>Those entities (i.e., people, organizations)<br>\nthat have contributed to the state of this<br>\nlearning object during its life cycle <br>\n(e.g., creation, edits, publication).</html>");

        jPanelContribute.setBackground(new java.awt.Color(204, 204, 204));

        javax.swing.GroupLayout jPanelContributeLayout = new javax.swing.GroupLayout(jPanelContribute);
        jPanelContribute.setLayout(jPanelContributeLayout);
        jPanelContributeLayout.setHorizontalGroup(
            jPanelContributeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1096, Short.MAX_VALUE)
        );
        jPanelContributeLayout.setVerticalGroup(
            jPanelContributeLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 555, Short.MAX_VALUE)
        );

        jScrollPane1.setViewportView(jPanelContribute);
        jPanelContribute.getAccessibleContext().setAccessibleDescription("");

        jButtonAddContribute.setText("+");
        jButtonAddContribute.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonAddContributeActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(jSeparator2)
                        .addComponent(jSeparator1)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel8)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jTextFieldVersion, javax.swing.GroupLayout.PREFERRED_SIZE, 202, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jComboBoxVersionLang, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jComboBoxStatus, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel9)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jButtonAddContribute))))
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 710, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(421, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel8)
                    .addComponent(jLabel1)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jTextFieldVersion, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jComboBoxVersionLang, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jComboBoxStatus, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel9)
                    .addComponent(jLabel3)
                    .addComponent(jButtonAddContribute))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 451, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(109, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonAddContributeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonAddContributeActionPerformed
        if(jPanelContribute.getComponentCount() == 30)
        {
            JOptionPane.showMessageDialog(this, "VocÃª nÃ£o pode ter mais de 30 itens!", "Aviso", JOptionPane.WARNING_MESSAGE);
            return;
        }
        jPanelContribute.add(new JPanelContribute());
    }//GEN-LAST:event_jButtonAddContributeActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonAddContribute;
    private javax.swing.JComboBox jComboBoxStatus;
    private javax.swing.JComboBox jComboBoxVersionLang;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanelContribute;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JTextField jTextFieldVersion;
    // End of variables declaration//GEN-END:variables
}

\end{lstlisting}

\subsection{JPanelRightsFull.java}

\begin{lstlisting}[frame=tb]
package user_interface.categorias;

import user_interface.Profile;
import java.util.ArrayList;

public class JPanelRightsFull extends javax.swing.JPanel implements Categoria{

    Profile profile;
    
    public JPanelRightsFull(Profile profile) {
        initComponents();
        this.profile = profile;
    }

    @Override
    public PacoteComCampos retornarCamposGeradoresDeSugestoes()
    {
        return new PacoteComCampos(util.TipoDeCategoria.RightsFull, new ArrayList<String>());
    }
    
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jComboBoxCost = new javax.swing.JComboBox();
        jSeparator1 = new javax.swing.JSeparator();
        jLabel2 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jComboBoxCopyright = new javax.swing.JComboBox();
        jSeparator2 = new javax.swing.JSeparator();
        jLabel3 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextAreaDescription = new javax.swing.JTextArea();
        jComboBoxDescriptionLang = new javax.swing.JComboBox();

        jLabel1.setFont(new java.awt.Font("Tahoma", 2, 14)); // NOI18N
        jLabel1.setText("1. Cost:");

        jLabel8.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel8.setToolTipText("<html>Whether use of this learning object requires payment.</html>");

        jComboBoxCost.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "no", "yes" }));

        jLabel2.setFont(new java.awt.Font("Tahoma", 2, 14)); // NOI18N
        jLabel2.setText("2. Copyright and Other Restrictions:");

        jLabel9.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel9.setToolTipText("<html>Whether copyright or other restrictions apply<br>\nto the use of this learning object.</html>");

        jComboBoxCopyright.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "no", "yes" }));

        jLabel3.setFont(new java.awt.Font("Tahoma", 2, 14)); // NOI18N
        jLabel3.setText("3. Description:");

        jLabel10.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/help.png"))); // NOI18N
        jLabel10.setToolTipText("<html>Comments on the conditions of use of this learning object.<br><br>\nEx.: \"Use of this learning object is only permitted after(...)\"</html>");

        jTextAreaDescription.setColumns(20);
        jTextAreaDescription.setLineWrap(true);
        jTextAreaDescription.setRows(5);
        jTextAreaDescription.setWrapStyleWord(true);
        jScrollPane1.setViewportView(jTextAreaDescription);

        jComboBoxDescriptionLang.setEditable(true);
        jComboBoxDescriptionLang.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "en", "pt" }));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jSeparator1, javax.swing.GroupLayout.DEFAULT_SIZE, 1019, Short.MAX_VALUE)
                    .addComponent(jSeparator2, javax.swing.GroupLayout.DEFAULT_SIZE, 1019, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel8)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jComboBoxCost, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel9)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jComboBoxCopyright, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel10))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 386, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jComboBoxDescriptionLang, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jComboBoxCost, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel8)
                    .addComponent(jLabel1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addComponent(jLabel9)
                    .addComponent(jComboBoxCopyright, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel3)
                    .addComponent(jLabel10))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jComboBoxDescriptionLang, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 75, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(493, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox jComboBoxCopyright;
    private javax.swing.JComboBox jComboBoxCost;
    private javax.swing.JComboBox jComboBoxDescriptionLang;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JTextArea jTextAreaDescription;
    // End of variables declaration//GEN-END:variables
}

\end{lstlisting}

\subsection{PacoteComCampos.java}

\begin{lstlisting}[frame=tb]
package user_interface.categorias;

import util.TipoDeCategoria;
import java.util.ArrayList;
import java.util.List;
import util.NLPTool;
import util.Rank;

public class PacoteComCampos
{
    public TipoDeCategoria categoria;
    public ArrayList<String> valores;
    
    public PacoteComCampos(TipoDeCategoria categoria, ArrayList<String> campos_valores)
    {
        this.categoria = categoria;
        this.valores = campos_valores;
    }
    
    public List<String> processarKeywords() // INCOMPLETO: Apenas para GeneralParaOBAA
    {
        if(categoria == TipoDeCategoria.GeneralParaOBAA)
        {
            ArrayList<String> title;
            ArrayList<String> description;
            ArrayList<String> keywords = new ArrayList<String>();
            ArrayList<String> keywords_final = new ArrayList<String>();
            
            //System.out.println("para processar: "+valores);
            
            title = NLPTool.stopWordsRemoval(NLPTool.toLowerCase(valores.get(0)));
            
            description = NLPTool.stopWordsRemoval(NLPTool.toLowerCase(valores.get(1)));
            
            keywords.add(valores.get(2));
            keywords = NLPTool.separateStringsByDotComma(keywords);

            keywords_final.addAll(title);
            keywords_final.addAll(description);
            keywords_final.addAll(keywords);
            NLPTool.removeEmptyStrings(keywords_final);

            //System.out.println("title: "+title);
            //System.out.println("description: "+description);
            //System.out.println("keywords: "+keywords);
            //System.out.println("keywords_final: "+keywords_final);
            
            keywords_final = NLPTool.toLowerCase(keywords_final);
            
            return Rank.rankByQuant(8, keywords_final);
        }
        else
        {
            return new ArrayList<String>();
        }
    }
}

\end{lstlisting}

\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Fim do documento                                
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Identificadores do trabalho
% Usados para preencher os elementos pré-textuais
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------
% Só preencher se não for a UFSC - Se for uma instituição "masculina",
% como um Instituto Federal, usar o parâmetro opcional [] - v. exemplo
%
%\instituicao[o]{Instituto Federal do Rio Grande do Sul}

%----------------------------------------------------------------------
% Só preencher se não for o departamento de Eng. Mecânica - o que deve 
% ser quase que certo. Se for um departamento "feminino", usar o
% parâmetro opcional [] - v. exemplo
%
%\departamento{Departamento de Informática e Estatística (INE)}

%----------------------------------------------------------------------
% Só preencher se não for o POSMEC - o que deve ser quase que certo.
% Se for um curso "feminino", usar o parâmetro opcional [] - v. exemplo
%
%\curso{Ciências da Computação}

%----------------------------------------------------------------------
% Só preencher se não for tese
% Se for um documento diferente de tese, dissertação, tcc, monografia
% ou relatório, indicar no parâmetro opcional o gênero - v. exemplo
%
%\documento[o]{Laudo}

%----------------------------------------------------------------------
% Título é obrigatório, mas subtítulo é opcional
%
%\titulo{Elaboração de documentos para a BU/UFSC}
%\subtitulo{Estilo \LaTeX~ Padrão}

%----------------------------------------------------------------------
% Autor é obrigatório. Não se atreva a não incluir ou vai ter surpresa
%
%\autor{Roberto Simoni, Carlos R Rocha}

%----------------------------------------------------------------------
%
% Só preencher se não for Doutor em Engenharia Mecânica
%\grau{Descomentar se não for Doutor em Engenharia Mecânica}

%----------------------------------------------------------------------
% Só preencher se não for Florianópolis
%
%\local{Simcity}

%----------------------------------------------------------------------
% Data deve ter as três partes entre chaves
%
%\data{01}{julho}{2010}

%----------------------------------------------------------------------
% Orientador é obrigatório. Coorientador é opcional
% Se o título for diferente (orientadora), indicar como no exemplo
%
%\orientador[Orientadora]{Profa. Dra. Fulana}
%\coorientador{Prof. Dr. Beltrano}

%----------------------------------------------------------------------
% Coordenador do programa é obrigatório
% Se o título for diferente (coordenadora), indicar como no exemplo
%
%\coordenador[Coordenadora]{Profa. Senhora, Dra. Eng.}

%----------------------------------------------------------------------
% Banca - Pode ter até 7 membros além de orientador e co-orientador
% Se estes são parte da banca, devem ser adicionados com os comandos
% \orientadornabanca{sim} e \coorientadornabanca{sim}
% do contrário, eles aparecerão antes da designação da banca
% O MembroA da banca é por definição o seu presidente
% O numero total de membros na defesa decide se a folha de aprovação
% deverá ser duplicada. Se passar de 4, uma folha adicional de assinaturas
% será gerada
%
%\numerodemembrosnabanca{4} % Isso decide se haverá uma folha adicional
%\orientadornabanca{sim} % Se faz parte da banca definir como sim
%\coorientadornabanca{sim} % Se faz parte da banca definir como sim
%\bancaMembroA{Prof. Presidente da banca} %Nome do presidente da banca
%\bancaMembroB{Prof. segundo membro}      % Nome do membro da Banca
%\bancaMembroC{Prof. terceiro membro}     % Nome do membro da Banca
%\bancaMembroD{Prof. quarto membro}       % Nome do membro da Banca
%\bancaMembroE{Prof. quinto membro}       % Nome do membro da Banca
%\bancaMembroF{Prof. sexto membro}        % Nome do membro da Banca
%\bancaMembroG{Prof. sétimo membro}       % Nome do membro da Banca

%----------------------------------------------------------------------
% Firulas opcionais - Dedicatória, Agradecimento e Epígrafe
%
% \dedicatoria{Dedicatória para alguem}
% \agradecimento{Agradecimentos, se for o caso...blabla blablablabla blabla ipsum loren e a sophia também blab ablablabl ablbalbalblab lablablbalb lab la}
% \epigrafe{Um bonito pensamento ou citação, se for o caso}{autor do pensamento}

%----------------------------------------------------------------------
% Resumo e abstract - É só definir como mostra o exemplo abaixo
% 
% \textoResumo {Aqui é redigido o resumo do documento...  blabla blablablabla blabla ipsum loren e a sophia também blab ablablabl ablbalbalblab lablablbalb lab lab lab labl a blab lablablab la blab alballbalba lba lba }
% \palavrasChave {chave 1. chave 2. ... chave n.}
% 
% \textAbstract {Here is written the abstract of the document}
% \keywords {key 1. key 2. ... key n.}
